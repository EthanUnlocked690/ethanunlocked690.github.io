<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Speedrun Challenge - MAX Graphics</title>
    <style>
        /* [CSS is unchanged from the previous version] */
        body { margin: 0; overflow: hidden; font-family: 'Consolas', monospace; color: white; background-color: #000; }
        canvas { display: block; }
        #info { position: absolute; top: 10px; width: 100%; text-align: center; z-index: 100; user-select: none; text-shadow: 2px 2px 4px #000; pointer-events: none; }
        #gameTimer { transition: color 0.1s; }
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 200; cursor: pointer; transition: opacity 0.5s; }
        #overlay h1 { color: #4CAF50; font-size: 4em; margin-bottom: 20px; animation: pulse 1.5s infinite alternate; }
        #overlay p { font-size: 1.5em; margin: 5px 0; }
        #error-message { color: #FF6347; font-weight: bold; margin-top: 20px; padding: 10px; background-color: #331f1c; border: 1px solid #FF6347; font-size: 1.1em; display: none; }
        
        /* Leaderboard styling */
        .score-list { 
            margin-top: 20px; 
            padding: 10px; 
            border: 2px solid gold; 
            text-align: left; 
            width: 350px; 
            background-color: rgba(0, 0, 0, 0.5);
        }
        .score-list h3 { 
            margin-top: 0; 
            color: gold; 
            text-align: center; 
        }
        #highScoreList {
            list-style-type: none;
            padding: 0;
        }
        #highScoreList li {
            display: flex;
            justify-content: space-between;
            font-size: 1.2em;
            padding: 5px 0;
            border-bottom: 1px dashed #444;
        }
        #highScoreList li:last-child {
            border-bottom: none;
        }
        .player-name {
            font-weight: bold;
            color: #f0e68c;
            width: 70%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .highlighted-player .player-name {
            color: #FFD700; /* Gold highlight */
            background-color: rgba(255, 215, 0, 0.1);
            padding: 2px 5px;
            border-radius: 3px;
        }
        .player-rank {
            width: 15%;
            text-align: right;
            color: silver;
        }
        .player-time {
            width: 15%;
            text-align: right;
            color: #fff;
        }
        
        @keyframes pulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        
        /* CONFETTI STYLES */
        .confetti { position: absolute; width: 10px; height: 10px; background-color: #f00; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        @keyframes fall {
            0% { transform: translate(var(--x, 0px), var(--y, 0px)) rotate(0deg); opacity: 1; }
            100% { transform: translate(var(--x, 0px), 100vh) rotate(720deg); opacity: 0; }
        }
        .confetti-active { animation: fall 3s ease-in-out forwards; }
        @keyframes popper-burst {
            0% { transform: scale(0) opacity: 1; }
            50% { transform: scale(1.5) opacity: 1; }
            100% { transform: scale(0.5) opacity: 0; }
        }
        .popper { position: fixed; top: 50%; left: 50%; width: 200px; height: 200px; background: radial-gradient(circle, #ff0 0%, #f90 50%, transparent 70%); border-radius: 50%; z-index: 999; pointer-events: none; opacity: 0; }
        .popper-active { animation: popper-burst 1s ease-out; }
    </style>
</head>
<body>
    <div id="confetti-container" style="position: fixed; top: 0; left: 0; width: 100%; height: 100vh; overflow: hidden; z-index: 50;"></div>
    
    <div id="overlay">
        <h1>SPEEDRUN CHALLENGE</h1>
        <p>Goal: Cross GREEN gate to start, navigate obstacles, and finish at RED gate!</p>
        <p>Click anywhere to start (Time starts when you cross the GREEN gate)</p>
        <p>Controls: **W A S D** to move, **SPACE** to jump. Falling resets you to the last checkpoint.</p>
        
        <div class="score-list">
            <h3>üåé GLOBAL RANKINGS (TOP 5) üåé</h3>
            <ul id="highScoreList">
                <li>Loading scores...</li>
            </ul>
        </div>

        <p id="error-message">
            ‚ö†Ô∏è **Pointer Lock Failed!** The game needs a secure connection. 
            **FIX:** You must run this file on a local web server (e.g., `http://localhost:8000`), not directly from your file system (`file://`).
        </p>
    </div>

    <div id="info">
        <p>Time: <span id="gameTimer" style="color:gray;">0.00</span>s | Distance to Goal: <span id="distance">--</span>m | Checkpoint: <span id="checkpointName">Start</span></p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script> 
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/SAOPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/SAOShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/DepthLimitedBlurShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/UnpackDepthRGBAShader.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/objects/Sky.js"></script>

    <script>
        // --- three.js GLOBAL VARIABLES ---
        let camera, scene, renderer, controls;
        let clock = new THREE.Clock();
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let gameActive = false;
        let timingActive = false;
        let startTime = 0;
        let finishGate, startGate;
        let playerName = "Runner";
        let obstacles = [];
        let checkpoints = [];
        let currentCheckpoint = new THREE.Vector3(0, 10, 60); 
        let canJump = true;
        let composer;
        
        let movingPlatform; 
        let platformVelocity = new THREE.Vector3(0, 0, 0); 
        const PLATFORM_MAX_Y = 50;
        const PLATFORM_MIN_Y = 10;
        const PLATFORM_SPEED = 10;

        // --- GAME CONSTANTS ---
        const MOVEMENT_SPEED = 400.0;
        const JUMP_VELOCITY = 1000.0;
        const GRAVITY = 3000.0;
        const PLAYER_HEIGHT = 10;
        const GOAL_REACH_DISTANCE = 30; 
        const FALL_Y_THRESHOLD = -50;
        const START_GATE_Z = 50;
        const localStorageKey = 'speedrunChallengeHighScoresV2'; 
        const MAX_LEADERBOARD_ENTRIES = 5;

        // --- DOM Elements ---
        const overlay = document.getElementById('overlay');
        const errorMessage = document.getElementById('error-message');
        const highScoreList = document.getElementById('highScoreList');
        const checkpointNameDisplay = document.getElementById('checkpointName');
        const gameTimerDisplay = document.getElementById('gameTimer');
        const confettiContainer = document.getElementById('confetti-container');

        // --- HIGH SCORE & NAME FUNCTIONS (Unchanged) ---
        function getHighScore() {
            const scores = localStorage.getItem(localStorageKey);
            return scores ? JSON.parse(scores) : [];
        }
        function isTopFive(time) {
            const scores = getHighScore();
            if (scores.length < MAX_LEADERBOARD_ENTRIES) return true;
            scores.sort((a, b) => a.time - b.time);
            return time < scores[MAX_LEADERBOARD_ENTRIES - 1].time;
        }
        function updateHighScoreDisplay() {
            const scores = getHighScore();
            scores.sort((a, b) => a.time - b.time); 

            highScoreList.innerHTML = '';

            if (scores.length === 0) {
                highScoreList.innerHTML = '<li>No records yet.</li>';
                return;
            }
            
            const topScores = scores.slice(0, MAX_LEADERBOARD_ENTRIES);

            topScores.forEach((score, index) => {
                const li = document.createElement('li');
                li.className = (score.name === playerName) ? 'highlighted-player' : '';
                
                li.innerHTML = `
                    <span class="player-rank">#${index + 1}</span>
                    <span class="player-name">${score.name}</span>
                    <span class="player-time">${score.time.toFixed(2)}s</span>
                `;
                highScoreList.appendChild(li);
            });
            
            if (scores.length > MAX_LEADERBOARD_ENTRIES) {
                const playerIndex = scores.findIndex(score => score.name === playerName);
                
                if (playerIndex !== -1 && playerIndex >= MAX_LEADERBOARD_ENTRIES) {
                    const playerRecord = scores[playerIndex];
                    
                    const li = document.createElement('li');
                    li.className = 'highlighted-player';
                    li.style.marginTop = '10px';
                    
                    li.innerHTML = `
                        <span class="player-rank">#${playerIndex + 1}</span>
                        <span class="player-name">${playerRecord.name} (Your Best)</span>
                        <span class="player-time">${playerRecord.time.toFixed(2)}s</span>
                    `;
                    highScoreList.appendChild(li);
                }
            }
        }
        function saveScore(time, name) {
            let scores = getHighScore();
            let existingRecordIndex = scores.findIndex(s => s.name === name);

            if (existingRecordIndex !== -1) {
                if (time < scores[existingRecordIndex].time) {
                    scores[existingRecordIndex].time = time;
                }
            } else {
                scores.push({ name: name, time: time });
            }

            scores.sort((a, b) => a.time - b.time); 
            localStorage.setItem(localStorageKey, JSON.stringify(scores));
            updateHighScoreDisplay();
        }
        function promptForName() {
            let name = prompt("Enter your runner name (3-10 characters):", playerName);
            if (name === null || name.trim() === "") {
                name = "Unnamed Runner";
            }
            playerName = name.trim().substring(0, 10);
        }
        function resetPlayerToCheckpoint() {
            camera.position.copy(currentCheckpoint);
            camera.position.y = currentCheckpoint.y;
            velocity.set(0, 0, 0);
            canJump = true;
        }

        function addObstacle(geometry, material, position, name) {
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            
            obstacles.push(mesh);
            scene.add(mesh);
            return mesh;
        }
        
        const confettiColors = ['#f00', '#0f0', '#00f', '#ff0', '#f0f', '#0ff'];
        function createConfetti(isTopFiveRank) {
            const count = isTopFiveRank ? 100 : 50;
            const duration = isTopFiveRank ? 4000 : 3000;
            
            confettiContainer.innerHTML = '';
            
            if (isTopFiveRank) {
                const popper = document.createElement('div');
                popper.className = 'popper popper-active';
                confettiContainer.appendChild(popper);
                setTimeout(() => popper.remove(), 1000);
            }

            for (let i = 0; i < count; i++) {
                const c = document.createElement('div');
                c.className = 'confetti confetti-active';
                c.style.backgroundColor = confettiColors[Math.floor(Math.random() * confettiColors.length)];
                
                const x = Math.random() * window.innerWidth;
                const y = -Math.random() * 200;
                const xEnd = Math.random() * 200 - 100;
                
                c.style.setProperty('--x', `${xEnd}px`);
                c.style.setProperty('--y', `${y}px`);
                c.style.left = `${x}px`;
                c.style.top = `${y}px`;
                c.style.animationDuration = `${duration / 1000}s`;
                
                confettiContainer.appendChild(c);
                setTimeout(() => c.remove(), duration + 100);
            }
        }
        
        // --- Collision Logic (FIXED & UNCHANGED from previous version) ---
        function checkCollision(pos, object, delta) {
            object.updateMatrixWorld(true);
            const box = new THREE.Box3().setFromObject(object);

            const playerHalfWidth = 5;
            const futurePos = pos.clone().add(velocity.clone().multiplyScalar(delta));

            // Player Bounding Box (AABB) using current position
            const playerMinY = pos.y - PLAYER_HEIGHT;
            const playerMaxY = pos.y + PLAYER_HEIGHT;
            
            // Check for overlap in all axes at CURRENT position
            const overlapX = (pos.x - playerHalfWidth < box.max.x && pos.x + playerHalfWidth > box.min.x);
            const overlapY = (playerMinY < box.max.y && playerMaxY > box.min.y);
            const overlapZ = (pos.z - playerHalfWidth < box.max.z && pos.z + playerHalfWidth > box.min.z);

            if (overlapX && overlapY && overlapZ) {
                
                // 1. TOP Collision (Landing detection)
                if (velocity.y <= 0 && playerMinY >= box.max.y && futurePos.y - PLAYER_HEIGHT <= box.max.y) {
                    pos.y = box.max.y + PLAYER_HEIGHT; 
                    velocity.y = 0;
                    canJump = true;
                    
                    if (object.isMoving) {
                        return { type: 'top', movingObject: object };
                    }
                    return { type: 'top' };
                }

                // 2. HEAD Collision
                if (velocity.y > 0 && playerMaxY <= box.min.y && futurePos.y + PLAYER_HEIGHT >= box.min.y) {
                    velocity.y = 0;
                    return { type: 'head' };
                }

                // 3. SIDE Collision (The core fix)
                return { type: 'side' };
            }
            return { type: 'none' };
        }

        function handleObstacleCollisions(delta) {
            let onGround = false;
            const playerPos = camera.position;
            const prevPosition = camera.position.clone();
            
            let platformMovement = new THREE.Vector3(0, 0, 0);

            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                const collision = checkCollision(playerPos, obstacle, delta);
                
                if (collision.type === 'top') {
                    onGround = true;
                    if (collision.movingObject) {
                        platformMovement.copy(collision.movingObject.deltaPosition);
                    }
                } else if (collision.type === 'side' || collision.type === 'head') {
                    // Revert horizontal position only
                    playerPos.x = prevPosition.x;
                    playerPos.z = prevPosition.z;
                }
            }

            // Default floor collision
            if (playerPos.y < PLAYER_HEIGHT && !onGround) {
                playerPos.y = PLAYER_HEIGHT;
                velocity.y = 0;
                onGround = true;
            }
            
            // Apply platform movement only if on the ground and moving
            if (onGround && platformMovement.lengthSq() > 0) {
                camera.position.add(platformMovement);
            }
            
            return onGround;
        }

        // --- INIT FUNCTION ---
        function init() {
            promptForName();
            updateHighScoreDisplay(); 

            // RENDERER SETUP
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding; 
            document.body.appendChild(renderer.domElement);

            // SCENE SETUP
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 1, 1000);
            camera.position.copy(currentCheckpoint); 

            // 1. SKYBOX (Unchanged)
            const sky = new THREE.Sky();
            sky.scale.setScalar(450000);
            scene.add(sky);
            const sun = new THREE.Vector3();
            const uniforms = sky.material.uniforms;
            uniforms[ 'turbidity' ].value = 10;
            uniforms[ 'rayleigh' ].value = 3;
            uniforms[ 'mieCoefficient' ].value = 0.005;
            uniforms[ 'mieDirectionalG' ].value = 0.8;
            const parameters = { inclination: 0.5, azimuth: 0.1 };
            const theta = Math.PI * (parameters.inclination - 0.5);
            const phi = 2 * Math.PI * (parameters.azimuth - 0.5);
            sun.x = Math.cos(phi);
            sun.y = Math.sin(phi) * Math.sin(theta);
            sun.z = Math.sin(phi) * Math.cos(theta);
            uniforms[ 'sunPosition' ].value.copy(sun);


            // Floor 
            const floorGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);
            floorGeometry.rotateX(-Math.PI / 2);
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x4caf50, 
                metalness: 0.5, 
                roughness: 0.8  
            });
            addObstacle(floorGeometry, floorMaterial, new THREE.Vector3(0, 0, 0), "Floor");
            
            // --- START ZONE ENCLOSURE ---
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, 
                side: THREE.DoubleSide,
                metalness: 0.1,
                roughness: 0.9 
            });
            const wallHeight = 100;
            const wallLength = 100;
            const wallThickness = 5;

            // Back Wall (Z=110)
            addObstacle(new THREE.BoxGeometry(wallLength * 2 + 10, wallHeight, wallThickness), wallMaterial, new THREE.Vector3(0, wallHeight/2, START_GATE_Z + 60), "BackWall");
            // Right Wall (X=110)
            addObstacle(new THREE.BoxGeometry(wallThickness, wallHeight, wallLength * 2 + 10), wallMaterial, new THREE.Vector3(wallLength + 10, wallHeight/2, START_GATE_Z), "RightWall");
            // Left Wall (X=-110)
            addObstacle(new THREE.BoxGeometry(wallThickness, wallHeight, wallLength * 2 + 10), wallMaterial, new THREE.Vector3(-(wallLength + 10), wallHeight/2, START_GATE_Z), "LeftWall");


            // --- GATES ---
            const gateMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
            const startPostL = new THREE.Mesh(new THREE.BoxGeometry(5, 50, 5), gateMaterial);
            startPostL.position.set(-50, 25, START_GATE_Z);
            scene.add(startPostL);
            const startPostR = new THREE.Mesh(new THREE.BoxGeometry(5, 50, 5), gateMaterial);
            startPostR.position.set(50, 25, START_GATE_Z);
            scene.add(startPostR);
            startGate = { z: START_GATE_Z }; 

            // Finish Gate
            const finishMaterial = new THREE.MeshStandardMaterial({ color: 0xff4500, metalness: 0.9, roughness: 0.2, transparent: true, opacity: 0.8 }); 
            finishGate = new THREE.Mesh(new THREE.BoxGeometry(20, 100, 20), finishMaterial);
            finishGate.position.set(550, 50, -150); 
            finishGate.castShadow = true;
            scene.add(finishGate);
            
            // --- OBSTACLES & CHECKPOINTS ---
            const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0x5a2d07, metalness: 0.3, roughness: 0.7 });
            const movingPlatformMaterial = new THREE.MeshStandardMaterial({ color: 0x0000ff, metalness: 0.8, roughness: 0.2 }); 

            // Static Obstacles
            addObstacle(new THREE.BoxGeometry(30, 20, 30), obstacleMaterial, new THREE.Vector3(0, 10, -50), "Obs1");
            addObstacle(new THREE.BoxGeometry(100, 5, 20), obstacleMaterial, new THREE.Vector3(100, 2.5, -100), "Obs2");

            // CHECKPOINT 1
            checkpoints.push({ name: "Platform 1", position: new THREE.Vector3(150, PLAYER_HEIGHT, -150), z_check: -120, activated: false });
            
            // MOVING PLATFORM
            movingPlatform = addObstacle(new THREE.BoxGeometry(40, 5, 40), movingPlatformMaterial, new THREE.Vector3(200, PLATFORM_MIN_Y, -250), "MovingPlatform");
            movingPlatform.isMoving = true;
            movingPlatform.deltaPosition = new THREE.Vector3(0, 0, 0);

            // Static Obstacles (Continued)
            addObstacle(new THREE.BoxGeometry(20, 40, 20), obstacleMaterial, new THREE.Vector3(250, 20, -150), "Obs3a");
            addObstacle(new THREE.BoxGeometry(20, 60, 20), obstacleMaterial, new THREE.Vector3(300, 30, -150), "Obs3b");

            // CHECKPOINT 2
            checkpoints.push({ name: "High Jump", position: new THREE.Vector3(350, PLAYER_HEIGHT, -150), z_check: -180, activated: false });

            addObstacle(new THREE.BoxGeometry(40, 80, 40), obstacleMaterial, new THREE.Vector3(400, 40, -100), "Obs4");


            // LIGHTING & POST-PROCESSING
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(200, 500, 300);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 300;
            dirLight.shadow.camera.bottom = -300;
            dirLight.shadow.camera.left = -300;
            dirLight.shadow.camera.right = 300;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));

            const saoPass = new THREE.SAOPass(scene, camera, false, true);
            saoPass.params.saoScale = 50; 
            saoPass.params.saoBias = 0.5; 
            saoPass.params.saoIntensity = 0.01;
            saoPass.params.saoKernelRadius = 100;
            saoPass.params.saoMinResolution = 0;
            saoPass.params.saoBlur = true;
            saoPass.params.saoBlurScale = 1;
            saoPass.params.saoBlurRadius = 10;
            saoPass.params.saoBlurStdDev = 10;
            composer.addPass(saoPass);

            controls = new THREE.PointerLockControls(camera, document.body);
            
            // Event Handlers
            controls.addEventListener('lock', () => {
                overlay.style.opacity = '0';
                setTimeout(() => overlay.style.display = 'none', 500);
                errorMessage.style.display = 'none';

                if (!gameActive) {
                    gameActive = true; 
                }
            });

            controls.addEventListener('unlock', () => {
                 if (gameActive) {
                     overlay.style.display = 'flex';
                     setTimeout(() => overlay.style.opacity = '1', 50);
                     overlay.querySelector('h1').textContent = 'GAME PAUSED';
                     overlay.querySelector('p:nth-child(2)').textContent = 'Press ESC to resume or Click to restart.';
                 }
                 gameActive = false;
            });
            
            // üñ±Ô∏è SIMPLIFIED START
            overlay.addEventListener('click', () => { 
                controls.lock(); 
            });
            
            document.addEventListener('pointerlockerror', () => {
                errorMessage.style.display = 'block'; controls.unlock(); 
            }, false);

            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);
        }

        // --- GAME LOOP / ANIMATE FUNCTION ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // Update Moving Platform Position
            if (movingPlatform) {
                const prevY = movingPlatform.position.y;
                movingPlatform.position.y = PLATFORM_MIN_Y + ((PLATFORM_MAX_Y - PLATFORM_MIN_Y) / 2) * (1 + Math.sin(clock.getElapsedTime() * PLATFORM_SPEED * 0.1));
                
                // Calculate movement delta for player transfer
                movingPlatform.deltaPosition.set(
                    0, 
                    movingPlatform.position.y - prevY, 
                    0
                );
            }

            if (controls.isLocked === true && gameActive) {
                
                // Physics
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta; 

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * MOVEMENT_SPEED * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * MOVEMENT_SPEED * delta;

                // Apply movement
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                camera.position.y += velocity.y * delta;
                
                // Collision Handling (Pass delta for collision prediction)
                canJump = handleObstacleCollisions(delta);

                // Fall Check (below map)
                if (camera.position.y < FALL_Y_THRESHOLD) {
                    resetPlayerToCheckpoint();
                    return; 
                }

                
                // --- GAME LOGIC (Timing, Checkpoints, Finish) ---
                const playerZ = camera.position.z;

                // START GATE CHECK
                if (!timingActive && playerZ < startGate.z) {
                    timingActive = true;
                    startTime = performance.now();
                    gameTimerDisplay.style.color = '#00ff00';
                }
                
                // CHECKPOINT ACTIVATION
                if (timingActive) {
                    for (let i = 0; i < checkpoints.length; i++) {
                        const cp = checkpoints[i];
                        if (!cp.activated && playerZ < cp.z_check) {
                            cp.activated = true;
                            currentCheckpoint = cp.position.clone();
                            currentCheckpoint.name = cp.name;
                            checkpointNameDisplay.textContent = cp.name;
                            break; 
                        }
                    }
                }
                
                // FINISH GATE CHECK
                const distanceToFinish = camera.position.distanceTo(finishGate.position);
                document.getElementById('distance').textContent = distanceToFinish.toFixed(1);

                if (timingActive && distanceToFinish < GOAL_REACH_DISTANCE) { 
                    const finalTime = (performance.now() - startTime) / 1000;
                    timingActive = false;
                    
                    const finalTimeFormatted = finalTime.toFixed(2);
                    const topFiveStatus = isTopFive(finalTime);
                    saveScore(finalTime, playerName);
                    
                    createConfetti(topFiveStatus);

                    checkpoints.forEach(cp => cp.activated = false);
                    currentCheckpoint = new THREE.Vector3(0, 10, 60);
                    checkpointNameDisplay.textContent = 'Start';
                    gameTimerDisplay.style.color = 'gray';

                    overlay.style.display = 'flex';
                    setTimeout(() => overlay.style.opacity = '1', 50);
                    
                    let completionMessage = `üèÅ RUN COMPLETE: ${finalTimeFormatted}s`;
                    if (topFiveStatus) {
                        completionMessage = `üéâ TOP ${MAX_LEADERBOARD_ENTRIES} RUN! ${finalTimeFormatted}s!`;
                    }
                    overlay.querySelector('h1').textContent = completionMessage;
                    overlay.querySelector('p:nth-child(2)').textContent = `Your time has been recorded, ${playerName}!`;

                    setTimeout(() => {
                        controls.unlock();
                        resetPlayerToCheckpoint();
                        promptForName();
                        updateHighScoreDisplay();
                    }, 500); 
                }

                // Update Timer
                if (timingActive) {
                    const elapsedTime = (performance.now() - startTime) / 1000;
                    gameTimerDisplay.textContent = elapsedTime.toFixed(2);
                }
            }

            // RENDER: Use the composer for enhanced graphics
            composer.render(delta);
        }

        // Helper functions
        function onKeyDown(event) {
            if (!controls.isLocked) return;
            switch (event.keyCode) {
                case 87: moveForward = true; break; 
                case 65: moveLeft = true; break;    
                case 83: moveBackward = true; break; 
                case 68: moveRight = true; break;   
                case 32: 
                    if (canJump) {
                        velocity.y = JUMP_VELOCITY;
                        canJump = false;
                    }
                    break;
            }
        }
        function onKeyUp(event) {
            switch (event.keyCode) {
                case 87: moveForward = false; break;
                case 65: moveLeft = false; break;
                case 83: moveBackward = false; break;
                case 68: moveRight = false; break;
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- START GAME ---
        init();
        animate();
    </script>
</body>
</html>
