<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chronosynapse - Chronal-Kinetic Fiction</title>
    <style>
        /* ========================================================= */
        /* CSS STYLES - CHRONAL-KINETIC INTERFACE */
        /* ========================================================= */
        :root {
            --bg-color: #0d0d1a;
            --main-color: #33ccff;
            --accent-color: #ff33cc;
            --error-color: #ff3333;
            --font-family: 'Space Mono', monospace;
            --pulse-duration: 0.8s;
        }

        body {
            background-color: var(--bg-color);
            color: var(--main-color);
            font-family: var(--font-family);
            margin: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            perspective: 800px; /* 3D Perspective for the interface */
        }

        .game-container {
            width: 90vw;
            max-width: 800px;
            padding: 30px;
            border: 1px solid var(--main-color);
            box-shadow: 0 0 40px rgba(51, 204, 255, 0.5), inset 0 0 10px rgba(51, 204, 255, 0.2);
            background-color: rgba(0, 0, 0, 0.5);
            transition: all 0.5s ease-out;
        }

        /* --- Narrative Display --- */
        #narrative-display {
            min-height: 150px;
            font-size: 1.1em;
            margin-bottom: 20px;
        }

        /* --- Decision Interface --- */
        #decision-interface {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .decision-button {
            background-color: rgba(51, 204, 255, 0.1);
            color: var(--main-color);
            border: 1px solid var(--main-color);
            padding: 12px;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
        }

        .decision-button:hover:not(.disabled) {
            background-color: rgba(51, 204, 255, 0.4);
        }

        .decision-button.disabled {
            opacity: 0.5;
            cursor: default;
        }

        /* --- Kinetic Interface (The core advanced element) --- */
        #kinetic-interface {
            margin-top: 30px;
            height: 100px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 30px var(--accent-color), inset 0 0 15px rgba(255, 51, 204, 0.4);
            transform: rotateX(15deg); /* Tilt for 3D effect */
            transition: opacity 0.3s;
            opacity: 0;
            pointer-events: none;
            position: relative;
        }
        
        #kinetic-interface.active {
            opacity: 1;
            pointer-events: all;
        }

        .indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: var(--main-color);
            opacity: 0.1;
            transition: opacity 0.1s;
        }

        .indicator.target {
            opacity: 0.8;
            box-shadow: 0 0 15px var(--main-color);
        }
        
        .indicator.hit {
            background-color: #00ff00;
            box-shadow: 0 0 20px #00ff00;
            animation: pulse-success 0.2s;
        }
        
        .indicator.miss {
            background-color: var(--error-color);
            box-shadow: 0 0 20px var(--error-color);
            animation: pulse-fail 0.2s;
        }

        /* Rhythmic Animation */
        #rhythm-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: rgba(255, 255, 255, 0.1);
            bottom: 0;
        }

        #rhythm-bar {
            position: absolute;
            width: 50px;
            height: 5px;
            background-color: var(--accent-color);
            box-shadow: 0 0 10px var(--accent-color);
            left: 0;
            bottom: 0;
            /* JS will apply the keyframe animation */
        }
        
        /* Keyframe for the rhythmic movement */
        @keyframes rhythm-move {
            0% { transform: translateX(0); }
            100% { transform: translateX(calc(100% - 50px)); }
        }

        @keyframes pulse-success {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); }
            100% { transform: scale(1); }
        }
        @keyframes pulse-fail {
            0% { background-color: var(--error-color); }
            50% { background-color: var(--error-color); transform: scale(0.5); }
            100% { background-color: var(--error-color); transform: scale(1); }
        }

        /* --- Status Bar --- */
        #status-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            font-size: 0.9em;
        }
        .paradox { color: var(--error-color); font-weight: bold; }
        .score { color: var(--accent-color); font-weight: bold; }
    </style>
</head>
<body>

<div class="game-container">
    <div id="status-bar">
        <span>Paradox Level: <span id="paradox-level" class="paradox">0</span></span>
        <span>Integrity Score: <span id="integrity-score" class="score">0</span></span>
    </div>

    <div id="narrative-display">
        <p>:: **Temporal Archival Unit 7** ::</p>
        <p>Reviewing Event **EON-47: The Council Collapse**. You must intervene to stabilize the timeline. Each choice requires a successful kinetic sync. Failures increase the Paradox Level.</p>
    </div>

    <div id="decision-interface">
        <button class="decision-button" data-choice="start">Begin Chronosynapse</button>
    </div>

    <div id="kinetic-interface">
        <div id="rhythm-line">
            <div class="indicator" data-key="a" style="left: 10%;"></div>
            <div class="indicator" data-key="s" style="left: 30%;"></div>
            <div class="indicator" data-key="d" style="left: 50%;"></div>
            <div class="indicator" data-key="f" style="left: 70%;"></div>
            <div class="indicator" data-key="g" style="left: 90%;"></div>
            <div id="rhythm-bar"></div>
        </div>
    </div>
</div>

<script>
    // =========================================================
    //                          JAVASCRIPT LOGIC
    // =========================================================

    // --- Global State ---
    const state = {
        paradoxLevel: 0,
        integrityScore: 0,
        currentScene: 'start',
        awaitingChoice: false,
        awaitingKinetic: false,
        kineticSequence: [],
        sequenceResolver: null,
        rhythmDuration: 3000, // 3 seconds for the bar to cross
    };

    // --- DOM Elements ---
    const $ = id => document.getElementById(id);
    const elements = {
        narrative: $('narrative-display'),
        decisions: $('decision-interface'),
        kinetic: $('kinetic-interface'),
        rhythmBar: $('rhythm-bar'),
        paradox: $('paradox-level'),
        score: $('integrity-score')
    };

    // --- Core Data: The Narrative Tree ---
    const scenes = {
        'start': {
            text: "Event EON-47 initiated. The Council is voting on the deployment of the Chronal Barrier. History shows a tie, but only one outcome is stable.",
            choices: [
                { text: "1. Push the 'Stabilization' vote through.", next: 'scene1_stabilize', keys: 'asdg' },
                { text: "2. Allow the 'Entropy' vote to proceed.", next: 'scene1_entropy', keys: 'fsda' }
            ]
        },
        'scene1_stabilize': {
            text: "Stabilization choice selected. Preparing kinetic lock. The barrier must deploy **precisely** as the final vote is cast. Sequence: 'A', 'S', 'D', 'G'.",
            choices: [], // The sequence is handled by the kinetic interface
            success: "SUCCESS. The barrier is deployed. History is stable. Integrity +10.",
            failure: "PARADOX. The barrier flickers, causing minor temporal echoes. Paradox +5.",
            nextSuccess: 'scene2_stable',
            nextFailure: 'scene2_unstable'
        },
        'scene1_entropy': {
            text: "Entropy choice selected. Preparing kinetic lock. You must delay the deployment **exactly** until the resulting collapse is minimized. Sequence: 'F', 'S', 'D', 'A'.",
            choices: [],
            success: "SUCCESS. The entropy wave is contained. You've adapted to the instability. Integrity +15.",
            failure: "PARADOX. The local chronal field collapses, forcing a risky jump. Paradox +10.",
            nextSuccess: 'scene2_unstable', // Different outcomes based on success/failure state
            nextFailure: 'end_paradox_major'
        },
        'scene2_stable': {
            text: "Timeline stable. A new crisis appears: The Barrier's core requires a reset code. Code: 7-4-3. You must execute this as a rapid sequence on the keyboard ('J', 'K', 'L').",
            choices: [
                { text: "Input Reset Code (J, K, L)", next: 'scene3_reset', keys: 'jkl' }
            ]
        },
        'scene2_unstable': {
            text: "Timeline unstable. The paradox energy is attracting a Chronal Predator. You must fire a warning shot ('Z', 'X', 'C') to repel it before it reaches the main archive.",
            choices: [
                { text: "Fire Warning Shot (Z, X, C)", next: 'scene3_shot', keys: 'zxc' }
            ]
        },
        'scene3_reset': { text: "Success! The Barrier is reset. The timeline is secure. (Game End - Stable Archive)", choices: [] },
        'scene3_shot': { text: "Success! The Predator retreats. But the paradox remains a threat. (Game End - Tense Stability)", choices: [] },
        'end_paradox_major': { text: "CRITICAL PARADOX FAILURE. The integrity of the Archivist is compromised. The timeline fragments.", choices: [] }
    };

    // --- State Update & Rendering ---
    function updateStatus() {
        elements.paradox.textContent = state.paradoxLevel;
        elements.score.textContent = state.integrityScore;
        if (state.paradoxLevel >= 20) {
            elements.paradox.classList.add('pulse-error');
            endGame();
        }
    }

    function renderScene(sceneId) {
        state.currentScene = sceneId;
        const scene = scenes[sceneId];

        // 1. Update Narrative
        elements.narrative.innerHTML = `<p>${scene.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</p>`;
        
        // 2. Render Choices
        elements.decisions.innerHTML = '';
        if (scene.choices && scene.choices.length > 0) {
            state.awaitingChoice = true;
            scene.choices.forEach((choice, index) => {
                const button = document.createElement('button');
                button.className = 'decision-button';
                button.textContent = choice.text;
                button.onclick = () => handleChoice(choice);
                elements.decisions.appendChild(button);
            });
        } else {
            state.awaitingChoice = false;
            // End of branch, allow game to rest
            if (sceneId.startsWith('end_') || sceneId.startsWith('scene3_')) {
                endGame(scene.text);
            }
        }
    }

    // --- Kinetic Sequence Logic (The CKF Core) ---

    async function handleChoice(choice) {
        // Disable all buttons during processing
        Array.from(elements.decisions.children).forEach(btn => btn.classList.add('disabled'));
        state.awaitingChoice = false;

        if (choice.keys) {
            // Initiate Kinetic Sequence for the decision lock
            elements.decisions.style.display = 'none';
            const success = await startKineticSequence(choice.keys);

            // Once the sequence is resolved, update narrative based on success/failure
            const nextSceneID = success 
                ? scenes[state.currentScene].nextSuccess 
                : scenes[state.currentScene].nextFailure;
            
            elements.narrative.innerHTML += success
                ? `<p style="color: green;">:: SYNCHRONIZATION ACHIEVED :: ${scenes[state.currentScene].success}</p>`
                : `<p style="color: var(--error-color);">:: SYNCHRONIZATION FAILED :: ${scenes[state.currentScene].failure}</p>`;

            if (success) {
                state.integrityScore += 10;
            } else {
                state.paradoxLevel += 5;
            }
            updateStatus();

            // Wait a moment for the player to see the result, then proceed
            setTimeout(() => {
                elements.decisions.style.display = 'flex';
                renderScene(nextSceneID);
            }, 1500);

        } else {
            // Simple narrative jump (e.g., the 'start' button)
            renderScene(choice.next);
        }
    }
    
    function startKineticSequence(keys) {
        return new Promise(resolve => {
            state.awaitingKinetic = true;
            state.kineticSequence = keys.toUpperCase().split(''); // ['A', 'S', 'D', 'G']
            state.sequenceResolver = resolve;
            
            elements.kinetic.classList.add('active');
            elements.rhythmBar.style.animation = `rhythm-move ${state.rhythmDuration}ms linear 0s infinite`;

            // Prepare visual targets
            elements.kinetic.querySelectorAll('.indicator').forEach(ind => {
                ind.classList.remove('target', 'hit', 'miss');
                if (state.kineticSequence.includes(ind.dataset.key.toUpperCase())) {
                    ind.classList.add('target');
                }
            });
        });
    }

    // --- Input Listener ---
    document.addEventListener('keydown', handleKeyInput);

    function handleKeyInput(e) {
        if (!state.awaitingKinetic || e.repeat) return;
        
        const keyPressed = e.key.toUpperCase();
        
        // 1. Check if the key is part of the required sequence
        const keyIndex = state.kineticSequence.indexOf(keyPressed);
        if (keyIndex === -1) {
            // Key pressed not in sequence, penalize? (Optional: major failure)
            return;
        }

        // 2. Get the position of the rhythm bar (The heart of the timing challenge)
        const barRect = elements.rhythmBar.getBoundingClientRect();
        const interfaceRect = elements.kinetic.getBoundingClientRect();

        // Calculate current progress as a percentage (0 to 100)
        const currentX = barRect.left - interfaceRect.left;
        const progress = (currentX + barRect.width / 2) / interfaceRect.width;

        // 3. Check for proximity to the visual target
        const targetIndicator = elements.kinetic.querySelector(`.indicator[data-key="${e.key.toLowerCase()}"]`);
        if (!targetIndicator) return;
        
        const targetProgress = parseFloat(targetIndicator.style.left) / 100;
        const tolerance = 0.05; // 5% tolerance window around the target

        if (Math.abs(progress - targetProgress) < tolerance) {
            // HIT: Successful input
            targetIndicator.classList.remove('target');
            targetIndicator.classList.add('hit');
            state.kineticSequence.splice(keyIndex, 1); // Remove successfully hit key

            if (state.kineticSequence.length === 0) {
                // Sequence Complete!
                endKineticSequence(true);
            }
        } else {
            // MISS: Input was mistimed or wrong target was pressed
            targetIndicator.classList.remove('target');
            targetIndicator.classList.add('miss');
            endKineticSequence(false);
        }
    }

    function endKineticSequence(success) {
        state.awaitingKinetic = false;
        elements.rhythmBar.style.animation = 'none';
        elements.kinetic.classList.remove('active');
        
        // Reset indicators after a short delay
        setTimeout(() => {
             elements.kinetic.querySelectorAll('.indicator').forEach(ind => ind.classList.remove('hit', 'miss'));
        }, 300);

        if (state.sequenceResolver) {
            state.sequenceResolver(success);
        }
    }

    // --- Game Initialization and Ending ---
    function init() {
        // Initial setup
        const startButton = elements.decisions.querySelector('[data-choice="start"]');
        if(startButton) {
            startButton.onclick = () => renderScene('start');
        }
        updateStatus();
    }

    function endGame(finalMessage = "System Shutdown.") {
        state.awaitingChoice = false;
        state.awaitingKinetic = false;
        elements.decisions.innerHTML = `<h2 style="color: ${state.paradoxLevel >= 15 ? var(--error-color) : var(--main-color)};">${finalMessage}</h2>`;
        elements.kinetic.style.display = 'none';
        document.removeEventListener('keydown', handleKeyInput);
    }
    
    // Start the game when the window loads
    window.onload = init;
</script>

</body>
</html>
