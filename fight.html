<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sniper Challenge</title>
<style>
/* Provided Navbar CSS */
ul {
    list-style-type: none;
    margin: 0px;
    padding: 0px;
    overflow: hidden;
    background-color: #fa07e2;
    width: 800px; /* Adjusted to fit common game width */
    border-radius: 8px;
    margin-bottom: 10px;
}
li {
    float: left; /* Make list items go side-by-side */
}
li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none; /* No underline for links */
}
li a:hover {
    background-color: #60fa07;
    color: #000000
}

/* Game & Page Styling */
body {
    font-family: 'Courier New', Courier, monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-image: url('rickroll.gif'); /* Main body background. Ensure rickroll.gif is in the same folder. */
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
    background-attachment: fixed;
    color: white;
    margin-top: 20px;
    cursor: none; /* Hide default cursor so custom crosshair can be used. */
}

#sniping-game-container {
    position: relative;
    width: 800px; /* Game resolution width */
    height: 600px; /* Game resolution height */
    border: 4px solid #ff0000;
    border-radius: 8px;
    overflow: hidden; /* Hide anything outside */
    background-color: #000; /* Fallback if background_scene.jpg isn't loaded */
    background-image: url('background_scene.jpg'); /* Game background image. Ensure background_scene.jpg is in the same folder. */
    background-size: cover;
    background-position: center;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
}

canvas {
    display: block;
    /* Canvas will be used for targets, hits, score feedback directly on top of background */
    position: absolute; /* Allows it to overlay background-image on container */
    top: 0;
    left: 0;
    z-index: 1; /* Below the crosshair */
}

#crosshair {
    position: absolute;
    width: 60px; /* Size of your crosshair.png */
    height: 60px;
    background-image: url('crosshair.png'); /* Crosshair image. Ensure crosshair.png is in the same folder. */
    background-size: contain;
    background-repeat: no-repeat;
    transform: translate(-50%, -50%); /* Center the crosshair image on cursor */
    pointer-events: none; /* Allows clicks to pass through to canvas */
    z-index: 10; /* Above everything else */
    display: none; /* Hidden until game starts */
}

#game-ui {
    width: 800px;
    display: flex;
    justify-content: space-around; /* Distribute items */
    align-items: center;
    margin-top: 10px;
    padding: 10px 5px;
    background-color: rgba(0, 0, 0, 0.7);
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
}

#game-ui span {
    font-size: 1.5em;
    font-weight: bold;
    color: #60fa07; /* Green for UI text */
    text-shadow: 1px 1px 2px black;
}

/* Modal Styles - Shared for Start Menu and Game Over */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.85); /* Darker overlay */
    justify-content: center;
    align-items: center;
    color: black;
}

.modal-content {
    background-color: #fefefe;
    padding: 30px;
    border: 1px solid #888;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 5px 25px rgba(255, 0, 0, 0.5); /* Red glowing shadow */
    max-width: 600px;
    width: 90%;
}

.modal-content h2 {
    color: #ff0000; /* Red title */
    margin-bottom: 20px;
    font-size: 2.5em;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.3);
}

.modal-content p {
    font-size: 1.2em;
    margin-bottom: 25px;
    color: #333;
}

.modal-content button {
    background-color: #4CAF50;
    color: white;
    border: none;
    padding: 15px 30px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 1.3em;
    font-weight: bold;
    margin: 10px;
    transition: background-color 0.3s, transform 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}

.modal-content button:hover {
    background-color: #45a049;
    transform: translateY(-2px);
}

.modal-content button:active {
    transform: translateY(0);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* Game Over Modal Specifics */
#gameOverModal .modal-content h2 {
    color: #007bff; /* Blue for win, red for loss is handled in JS */
}

/* Muzzle Flash Effect */
@keyframes muzzleFlash {
    0% { opacity: 1; transform: scale(1); }
    100% { opacity: 0; transform: scale(2); }
}

#muzzle-flash {
    position: absolute;
    width: 80px; /* Size of flash */
    height: 80px;
    background-color: yellow; /* Placeholder, replace with image if desired */
    border-radius: 50%; /* Circular flash */
    opacity: 0;
    pointer-events: none;
    z-index: 15; /* Above crosshair */
    transform: translate(-50%, -50%); /* Center on click */
}
.flash-animation {
    animation: muzzleFlash 0.1s ease-out forwards;
}

</style>
</head>
<body>
<ul>
    <li><a href="turtle.html">â¬… Back to game selection</a></li>
</ul>

<h1 style="color: black; text-shadow: 1px 1px 2px white;">Sniper Challenge</h1>

<div id="sniping-game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <div id="crosshair"></div>
    <div id="muzzle-flash"></div>
</div>

<div id="game-ui">
    <span id="score-display">Score: 0</span>
    <span id="ammo-display">Ammo: 10</span>
    <span id="time-display">Time: 60s</span>
</div>

<div id="startGameModal" class="modal">
    <div class="modal-content">
        <h2>Welcome comrade! Choose your mode!</h2>
        <button id="singlePlayerButton">Start Game (Singleplayer)</button>
        <button id="multiPlayerButton" style="background-color: #6c757d;">Multiplayer (Local/Coming Soon)</button>
        <p style="font-size: 0.9em; color: #666;">Note: Real-time multiplayer requires a server, which isn't included in this file. The "Multiplayer" button here is a placeholder.</p>
    </div>
</div>

<div id="gameOverModal" class="modal">
    <div class="modal-content">
        <h2 id="gameOverMessage"></h2>
        <p id="finalScore"></p>
        <button id="restartGameButton">Play Again</button>
        <button id="backToMenuButton">Back to Menu</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const crosshair = document.getElementById('crosshair');
const muzzleFlash = document.getElementById('muzzle-flash');

// UI Elements
const scoreDisplay = document.getElementById('score-display');
const ammoDisplay = document.getElementById('ammo-display');
const timeDisplay = document.getElementById('time-display');

// Modals
const startGameModal = document.getElementById('startGameModal');
const singlePlayerButton = document.getElementById('singlePlayerButton');
const multiPlayerButton = document.getElementById('multiPlayerButton'); // Placeholder
const gameOverModal = document.getElementById('gameOverModal');
const gameOverMessage = document.getElementById('gameOverMessage');
const finalScore = document.getElementById('finalScore');
const restartGameButton = document.getElementById('restartGameButton');
const backToMenuButton = document.getElementById('backToMenuButton');

// Game Settings
const GAME_DURATION = 60; // seconds
const START_AMMO = 20;
const TARGET_SPAWN_INTERVAL = 1500; // milliseconds
const TARGET_DESPAWN_TIME = 2000; // milliseconds
const TARGET_SCORE = 10;
const TARGET_SIZE = { min: 40, max: 80 }; // Min/Max size for targets

// Game State
let score = 0;
let ammo = START_AMMO;
let timeLeft = GAME_DURATION;
let gameRunning = false;
let targets = [];
let spawnIntervalId = null;
let gameTimerId = null;
let animationFrameId = null; // For the main game loop

// --- Image Loading (Crucial for "Real Graphics") ---
const images = {};
const imagePaths = {
    crosshair: 'crosshair.png', // Ensure crosshair.png is in the same folder.
    target: 'target.png',       // Ensure target.png is in the same folder.
    hitEffect: 'hit_effect.png' // Optional: Ensure hit_effect.png is in the same folder if you use it.
};
let imagesLoaded = 0;
let totalImages = Object.keys(imagePaths).length;

function loadImage(name, path) {
    const img = new Image();
    img.src = path;
    img.onload = () => {
        images[name] = img;
        imagesLoaded++;
        if (imagesLoaded === totalImages) {
            console.log("All game images loaded!");
            // Potentially show start button here if you want to wait for assets
        }
    };
    img.onerror = () => {
        console.warn(`Failed to load image: ${path}. Using fallback.`);
        // Remove from totalImages if you want to proceed without it
        totalImages--;
        if (imagesLoaded === totalImages) {
            // All 'loadable' images done
        }
    };
}

// Load all images at start
for (const key in imagePaths) {
    loadImage(key, imagePaths[key]);
}

// --- Target Class ---
class Target {
    constructor() {
        this.width = Math.random() * (TARGET_SIZE.max - TARGET_SIZE.min) + TARGET_SIZE.min;
        this.height = this.width; // Keep square for simplicity
        this.x = Math.random() * (canvas.width - this.width);
        this.y = Math.random() * (canvas.height - this.height);
        this.spawnTime = Date.now();
        this.hit = false;
        this.fadeAlpha = 1; // For hit animation fade
        this.scoreGiven = false; // To prevent multiple scores for one target
    }

    draw() {
        ctx.save();
        if (this.hit) {
            ctx.globalAlpha = this.fadeAlpha;
            // Draw hit effect if available
            if (images.hitEffect) {
                ctx.drawImage(images.hitEffect, this.x - this.width/2, this.y - this.height/2, this.width * 2, this.height * 2); // Bigger for effect
            } else {
                ctx.fillStyle = `rgba(255, 255, 0, ${this.fadeAlpha})`; // Yellow flash fallback
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2 + 10, 0, Math.PI * 2);
                ctx.fill();
            }
            this.fadeAlpha -= 0.1; // Fade out
            if (this.fadeAlpha < 0) this.fadeAlpha = 0;

        } else {
            // Draw target image if available
            if (images.target) {
                ctx.drawImage(images.target, this.x, this.y, this.width, this.height);
            } else {
                // Fallback: Draw a simple red circle
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        ctx.restore();
    }

    isClicked(mouseX, mouseY) {
        if (this.hit) return false; // Can't hit an already hit target
        return mouseX > this.x && mouseX < this.x + this.width &&
               mouseY > this.y && mouseY < this.y + this.height;
    }
}

// --- Game Functions ---

function startGame() {
    score = 0;
    ammo = START_AMMO;
    timeLeft = GAME_DURATION;
    targets = [];
    gameRunning = true;
    
    crosshair.style.display = 'block'; // Show crosshair
    startGameModal.style.display = 'none';
    gameOverModal.style.display = 'none';

    updateUI();
    
    // Clear any existing intervals/timeouts to prevent duplicates on restart
    if (spawnIntervalId) clearInterval(spawnIntervalId);
    if (gameTimerId) clearInterval(gameTimerId);
    if (animationFrameId) cancelAnimationFrame(animationFrameId);

    spawnIntervalId = setInterval(spawnTarget, TARGET_SPAWN_INTERVAL);
    gameTimerId = setInterval(updateTimer, 1000); // Update timer every second
    
    gameLoop(); // Start the main game loop
}

function endGame(reason) {
    gameRunning = false;
    clearInterval(spawnIntervalId);
    clearInterval(gameTimerId);
    cancelAnimationFrame(animationFrameId);
    crosshair.style.display = 'none'; // Hide crosshair

    gameOverModal.style.display = 'flex';
    if (reason === 'time') {
        gameOverMessage.textContent = "Time's Up!";
        gameOverMessage.style.color = '#dc3545'; // Red for loss
    } else if (reason === 'ammo') {
        gameOverMessage.textContent = "Out of Ammo!";
        gameOverMessage.style.color = '#dc3545'; // Red for loss
    } else { // Could be a custom win message if goals are added
        gameOverMessage.textContent = "Game Over!";
        gameOverMessage.style.color = '#dc3545';
    }
    finalScore.textContent = `Final Score: ${score}`;
}

function spawnTarget() {
    targets.push(new Target());
}

function updateTimer() {
    timeLeft--;
    if (timeLeft <= 0) {
        timeLeft = 0;
        endGame('time');
    }
    updateUI();
}

function updateUI() {
    scoreDisplay.textContent = `Score: ${score}`;
    ammoDisplay.textContent = `Ammo: ${ammo}`;
    timeDisplay.textContent = `Time: ${timeLeft}s`;
}

// --- Game Loop ---
function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas (background handled by CSS on container)

    // Update and draw targets
    const now = Date.now();
    targets = targets.filter(target => {
        target.draw(); // Draw targets
        // Remove targets that are hit and faded, or despawned
        return (target.hit && target.fadeAlpha > 0) || (!target.hit && (now - target.spawnTime) < TARGET_DESPAWN_TIME);
    });

    if (gameRunning) {
        animationFrameId = requestAnimationFrame(gameLoop);
    }
}

// --- Event Listeners ---

// Mouse movement for crosshair
canvas.addEventListener('mousemove', (e) => {
    if (gameRunning) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        crosshair.style.left = `${mouseX}px`;
        crosshair.style.top = `${mouseY}px`;
    }
});

// Shooting mechanism
canvas.addEventListener('click', (e) => {
    if (!gameRunning || ammo <= 0) return;

    ammo--;
    updateUI();

    // Trigger muzzle flash
    muzzleFlash.style.left = `${e.clientX - canvas.getBoundingClientRect().left}px`;
    muzzleFlash.style.top = `${e.clientY - canvas.getBoundingClientRect().top}px`;
    muzzleFlash.classList.remove('flash-animation'); // Reset animation
    void muzzleFlash.offsetWidth; // Trigger reflow
    muzzleFlash.classList.add('flash-animation');

    let hit = false;
    for (let i = targets.length - 1; i >= 0; i--) {
        const target = targets[i];
        if (target.isClicked(e.offsetX, e.offsetY)) {
            if (!target.hit) { // Ensure target isn't already hit by this click
                target.hit = true;
                if (!target.scoreGiven) { // Only give score once
                    score += TARGET_SCORE;
                    target.scoreGiven = true;
                }
                hit = true;
                // Add a hit visual effect, maybe make target disappear faster
                break; // Only hit one target per shot
            }
        }
    }

    if (ammo <= 0 && targets.length === 0) { // If ran out of ammo and no targets left
        endGame('ammo');
    }
});

// Modal button listeners
singlePlayerButton.addEventListener('click', startGame);
restartGameButton.addEventListener('click', startGame);
backToMenuButton.addEventListener('click', () => {
    gameOverModal.style.display = 'none';
    startGameModal.style.display = 'flex';
});

// Initial load: Show the start game modal
window.onload = () => {
    startGameModal.style.display = 'flex';
    // Ensure `back.mp3` path is correct if you want background music
};

</script>
<audio autoplay loop>
    <source src="back.mp3" type="audio/mpeg"> Your browser does not support the audio element.
</audio>
</body>
</html>
