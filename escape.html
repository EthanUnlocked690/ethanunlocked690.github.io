<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Escape</title>
<style>
/* Provided Navbar CSS */
ul {
    list-style-type: none;
    margin: 0px;
    padding: 0px;
    overflow: hidden;
    background-color: #fa07e2;
    width: 800px;
    border-radius: 8px;
    margin-bottom: 10px;
}
li {
    float: left; /* Make list items go side-by-side */
}
li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none; /* No underline for links */
}
li a:hover {
    background-color: #60fa07;
    color: #000000
}
/* Game & Page Styling */
body {
    font-family: 'Courier New', Courier, monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-image: url('rickroll.gif'); /* REPLACE WITH YOUR IMAGE PATH/URL */
    background-size: cover; /* Ensures the image covers the entire background */
    background-position: center center; /* Centers the image */
    background-repeat: no-repeat; /* Prevents the image from repeating */
    background-attachment: fixed; /* Keeps the background image fixed when scrolling */
    color: white;
    margin-top: 20px;
}
#game-container {
    border: 4px solid #ff0000;
    border-radius: 8px;
    padding: 10px; /* Adjust if button is absolutely positioned within padding */
    background-color: #000;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    position: relative; /* Crucial for absolute positioning of pause button */
}
canvas {
    background-color: #111;
    display: block;
}
#game-ui {
    width: 800px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 10px;
    padding: 0 5px;
    flex-wrap: wrap; /* Allow items to wrap on smaller screens */
    gap: 5px; /* Spacing between UI elements */
}
#status-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #000000;
    flex-basis: 100%; /* Take full width on a new line */
    text-align: center;
    margin-bottom: 10px;
}
#hp-text, #bomb-text, #timer-text, #level-text, #score-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #FFFFFF; /* Default white for all these */
    margin: 0 5px;
}
#hp-text { color: #28a745; } /* Green for health */
#bomb-text { color: #FFA500; } /* Orange for bombs */
#timer-text { color: #FFFFFF; } /* Default white for timer */


button#resetButton { /* Removed #pauseButton from here */
    background-color: #ff0000;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    font-weight: bold;
    transition: background-color 0.3s;
    margin: 0 5px;
}
button#resetButton:hover {
    background-color: #32a852;
    color: black
}

/* Specific styling for the new pause button */
button#pauseButton {
    position: absolute; /* Position relative to game-container */
    top: 15px; /* Adjust as needed */
    left: 15px; /* Adjust as needed */
    z-index: 10; /* Ensure it's above the canvas */
    
    /* Styling for the button itself */
    background-color: rgba(255, 0, 0, 0.7); /* Semi-transparent red */
    border: 2px solid #ff0000;
    padding: 5px; /* Smaller padding for an icon button */
    border-radius: 8px; /* Slightly more rounded */
    cursor: pointer;
    transition: background-color 0.3s, border-color 0.3s, transform 0.1s;
    width: 50px; /* Fixed width for icon button */
    height: 50px; /* Fixed height for icon button */
    display: flex; /* To center the image */
    justify-content: center;
    align-items: center;
}

button#pauseButton:hover {
    background-color: #ff0000; /* Solid red on hover */
    border-color: #32a852;
}
button#pauseButton:active {
    transform: translateY(1px); /* Little press effect */
}

button#pauseButton img {
    width: 30px; /* Size of the pause icon */
    height: 30px; /* Size of the pause icon */
    display: block; /* Remove extra space below image */
    /* Optional: filter to make the icon white if it's black */
    /* filter: invert(1); */ 
}


/* Mobile Controls (Arrow Buttons) Styling */
#mobile-controls {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px; /* Space between rows */
}

.d-pad-row {
    display: flex;
    gap: 5px; /* Space between buttons in a row */
}

.arrow-button {
    background-color: #4CAF50; /* Green */
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 1.5em;
    font-weight: bold;
    transition: background-color 0.3s, transform 0.1s;
    min-width: 60px; /* Ensure good touch target */
    min-height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.arrow-button:hover {
    background-color: #45a049;
    transform: translateY(-2px);
}

.arrow-button:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* Specific style for the bomb button to distinguish it */
#bombButton {
    background-color: #FF4500; /* OrangeRed */
    border: 2px solid #CD3333; /* Darker red */
}
#bombButton:hover {
    background-color: #E04000;
}


/* Modal Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1000; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%; /* Could be responsive */
    max-width: 500px;
    border-radius: 10px;
    text-align: center;
    position: relative;
    color: black; /* Ensure text is visible */
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.modal-content h2 {
    color: #ff0000;
    margin-top: 0;
}

/* Style for buttons inside modals (general) */
.modal-content button {
    background-color: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    margin: 5px; /* Spacing between buttons in modal */
    
    /* Flexbox for image + text buttons */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-width: 120px; /* Ensure buttons are wide enough for content */
    min-height: 120px; /* Ensure buttons are tall enough for content */
}

.modal-content button img {
    width: 50px; /* Adjust size of the icon */
    height: 50px; /* Adjust size of the icon */
    margin-bottom: 8px; /* Space between icon and text */
    /* Optional: filter to make icons white if they are black on a dark background */
    /* filter: invert(1); */
}

.modal-content button span {
    font-size: 1.2em; /* Make the text bigger */
    font-weight: bold;
}


.modal-content button:hover {
    background-color: #45a049;
}

.close-button {
    color: #aaa;
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close-button:hover,
.close-button:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}

/* Pause Menu Specifics */
#pauseMenuModal .modal-content {
    display: flex; /* Use flexbox for modal content to layout buttons horizontally */
    flex-direction: column; /* Stack title and buttons vertically */
    align-items: center; /* Center items horizontally */
}

#pauseMenuModal .modal-content h2 {
    font-size: 3em; /* Make "Paused!" larger */
    margin-bottom: 20px;
}

#pauseMenuModal .button-container {
    display: flex; /* Container for the buttons to make them row-wise */
    gap: 20px; /* Space between buttons */
    justify-content: center;
    width: 100%;
    flex-wrap: wrap; /* Allow buttons to wrap if screen is too small */
}

/* Specific colors for pause menu buttons if desired */
#pauseMenuModal #pauseMenuPlayButton {
    background-color: #007bff; /* Blue for play */
}
#pauseMenuModal #pauseMenuPlayButton:hover {
    background-color: #0056b3;
}
#pauseMenuModal #pauseMenuRestartButton {
    background-color: #dc3545; /* Red for restart */
}
#pauseMenuModal #pauseMenuRestartButton:hover {
    background-color: #c82333;
}
#pauseMenuModal #pauseMenuQuitButton {
    background-color: #6c757d; /* Grey for quit */
}
#pauseMenuModal #pauseMenuQuitButton:hover {
    background-color: #5a6268;
}

</style>
</head>
<body>
<ul>
    <li><a href="turtle.html">‚¨Ö Back to game selection</a></li>
</ul>
<h1 style="color:black;">Controls</h1>
<p style="color:black;">Use arrow keys, WASD, or the on-screen buttons</p>
<p style="color:black;">Press 'R' or click "New Game" to reset</p>
<p style="color:black;">If you want to heal, get the heart (Potion) Max: 100 (Health in bottom-right corner)</p>
<p style="color:black;">Press 'X' or the bomb button to use a bomb (stuns nearby enemies, or damages you if no enemies are in range!)</p>
<p style="color:black;">Press 'P' or the 'Pause' button to pause the game.</p>


<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <button id="pauseButton"><img src="path/to/pause_icon.png" alt="Pause"></button> 
</div>
<div id="game-ui">
    <span id="status-text" style="color:black;">Find the key üîë and escape through the doorüö™!</span>
    <span id="level-text">Level: 1</span>
    <span id="score-text">Score: 0 üèÜ</span>
    <span id="bomb-text">Bombs: 3 üí£</span>
    <button id="resetButton">New Game</button>
    <span id="hp-text">HP: 100</span>
    <span id="timer-text">Time: 01:00</span>
</div>

<div id="mobile-controls">
    <div class="d-pad-row">
        <button id="upButton" class="arrow-button">‚¨ÜÔ∏è</button>
    </div>
    <div class="d-pad-row">
        <button id="leftButton" class="arrow-button">‚¨ÖÔ∏è</button>
        <button id="bombButton" class="arrow-button">üí£</button>
        <button id="rightButton" class="arrow-button">‚û°Ô∏è</button>
    </div>
    <div class="d-pad-row">
        <button id="downButton" class="arrow-button">‚¨áÔ∏è</button>
    </div>
</div>

<div id="warningModal" class="modal">
    <div class="modal-content">
        <span class="close-button" onclick="closeModal()">&times;</span>
        <h2>WARNING!</h2>
        <p>This game is SO hard that the creator himself could only beat it ONCE!! If you beat it, tell me in the comments of ANY of my videos and I will give you a shoutout!! Good luck and have fun!!</p>
        <button onclick="closeModal()">Got It!</button>
    </div>
</div>

<div id="pauseMenuModal" class="modal">
    <div class="modal-content">
        <h2>Paused!</h2>
        <div class="button-container">
            <button id="pauseMenuPlayButton">
                <img src="path/to/play_icon.png" alt="Play Icon">
                <span>Play</span>
            </button>
            <button id="pauseMenuRestartButton">
                <img src="path/to/restart_icon.png" alt="Restart Icon">
                <span>Restart</span>
            </button>
            <button id="pauseMenuQuitButton">
                <img src="path/to/quit_icon.png" alt="Quit Icon">
                <span>Quit</span>
            </button>
        </div>
    </div>
</div>

<script>
// --- Game Configuration ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 40; // Size of each tile in pixels
const MAP_WIDTH_TILES = Math.floor(canvas.width / TILE_SIZE);
const MAP_HEIGHT_TILES = Math.floor(canvas.height / TILE_SIZE);

// --- UI Elements ---
const statusText = document.getElementById('status-text');
const hpText = document.getElementById('hp-text');
const bombText = document.getElementById('bomb-text');
const resetButton = document.getElementById('resetButton');
const timerText = document.getElementById('timer-text');
const levelText = document.getElementById('level-text');
const scoreText = document.getElementById('score-text');

// Mobile Controls
const upButton = document.getElementById('upButton');
const downButton = document.getElementById('downButton');
const leftButton = document.getElementById('leftButton');
const rightButton = document.getElementById('rightButton');
const bombButton = document.getElementById('bombButton');

// Pause Menu Elements
const pauseButton = document.getElementById('pauseButton');
const pauseMenuModal = document.getElementById('pauseMenuModal');
const pauseMenuPlayButton = document.getElementById('pauseMenuPlayButton');
const pauseMenuRestartButton = document.getElementById('pauseMenuRestartButton');
const pauseMenuQuitButton = document.getElementById('pauseMenuQuitButton');

// --- Game Assets/Symbols ---
const Player = 'üö∂‚Äç‚ôÄÔ∏è'; // Changed to woman walking emoji
const Wall = 'ü™®';
const Floor = ' '; // Empty space
const Enemy = 'üêâ'; // Dragon
const FrozenEnemy = '‚ùÑÔ∏è'; // Changed to snowflake emoji
const Key = 'üîë';
const Exit = 'üö™';
const Potion = '‚ù§Ô∏è';
const PlayerWin = 'üèÜ'; // Player symbol on win

// --- Game State ---
let gameState = {};
let animationFrameId = null; // For managing the game loop

// --- Game Initialization ---
function initGame() {
    if(animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }

    gameState = {
        map: [],
        player: { x: 0, y: 0, hp: 100, maxHp: 100, bombs: 3 },
        enemies: [],
        key: { x: 0, y: 0 },
        exit: { x: 0, y: 0 },
        potions: [],
        hasKey: false,
        gameOver: false,
        gameWon: false, // Overall game won (e.g., after boss)
        levelComplete: false, // For regular level progression
        gameOverReason: null,
        turn: 0,
        startTime: null,
        initialTime: 60 * 1000,
        remainingTime: 60 * 1000,
        score: 0,
        currentLevel: 0, // Starts at 0, startGame() increments to 1 for first level
        isBossLevel: false,
        isPaused: false, // Pause state
        messageOnCanvas: null, // New: For displaying messages on canvas
        messageDisplayDuration: 0 // New: How long the message should display
    };
    
    // Call startGame to properly initialize the first level
    startGame();
    // Ensure the pause menu is hidden when a new game starts
    pauseMenuModal.style.display = 'none';
}

// --- Level Management ---
function startGame() {
    // Reset flags for new level load
    gameState.gameOver = false;
    gameState.gameWon = false;
    gameState.levelComplete = false; // Reset level complete flag
    gameState.gameOverReason = null;
    gameState.messageOnCanvas = null; // Clear any lingering canvas messages
    gameState.isPaused = false; // Ensure game is unpaused when starting new level

    // If currentLevel is 0 (initial load or full reset), set to 1.
    // Otherwise, assume currentLevel has already been set/incremented by handleGameEndOrLevelComplete
    if (gameState.currentLevel === 0) {
        gameState.currentLevel = 1;
    }

    gameState.isBossLevel = false; // Reset boss flag

    // Define level parameters
    const baseTimer = 75 * 1000; // Starting timer for Level 1 (75 seconds)
    const timerDecreasePerLevel = 5 * 1000; // 5 seconds decrease per level

    const levelParams = {
        1: { name: "Baby Easy", enemyCount: 3, potionCount: 3, timer: baseTimer, mapSizeMultiplier: 1.0, enemySpeedFactor: 1.0 },
        2: { name: "Easy", enemyCount: 5, potionCount: 3, timer: baseTimer - timerDecreasePerLevel, mapSizeMultiplier: 1.0, enemySpeedFactor: 1.1 },
        3: { name: "Medium", enemyCount: 7, potionCount: 2, timer: baseTimer - (timerDecreasePerLevel * 2), mapSizeMultiplier: 1.1, enemySpeedFactor: 1.2 },
        4: { name: "Difficult", enemyCount: 9, potionCount: 2, timer: baseTimer - (timerDecreasePerLevel * 3), mapSizeMultiplier: 1.2, enemySpeedFactor: 1.3 },
        5: { name: "Impossible", enemyCount: 12, potionCount: 1, timer: baseTimer - (timerDecreasePerLevel * 4), mapSizeMultiplier: 1.3, enemySpeedFactor: 1.4 }
    };

    // Boss Level Logic
    if (gameState.currentLevel > 5) {
        gameState.isBossLevel = true;
        
        gameState.map = generateBossMap(); // Special map for boss
        
        gameState.player.maxHp = 150; // Give player more max HP for boss fight
        gameState.player.hp = gameState.player.maxHp; // Heal player to new max HP
        
        const bossMaxHP = 1000; // Define boss max HP
        gameState.enemies = [{
            x: 0, y: 0,
            hp: bossMaxHP, maxHp: bossMaxHP,
            frozenTurns: 0,
            isBoss: true,
            symbol: 'üëπ',
            abilityCooldown: 3, // Turns until next ability use
            abilityTimer: 3, // Current countdown
        }];
        
        gameState.player.bombs = 5; // Give more bombs for boss
        gameState.initialTime = 90 * 1000; // More time for boss

        // Clear regular level specific entities
        gameState.key = { x: -1, y: -1 }; // No key on boss level
        gameState.exit = { x: -1, y: -1 }; // No exit on boss level
        gameState.potions = []; // No potions on boss level
        gameState.hasKey = false; // Player doesn't need key on boss level

        placeBossAndPlayer(); // Places boss and player on the map
        
        statusText.textContent = "Boss Level! Defeat the Demon Lord! üëπ";
    } else { // Regular Levels
        const params = levelParams[gameState.currentLevel];
        
        // Reset player health, bombs, and key status for new level
        gameState.player.maxHp = 100; // Reset player max HP for regular levels
        gameState.player.hp = gameState.player.maxHp; // Heal fully
        gameState.player.bombs = 3; // Reset bombs for each level
        gameState.hasKey = false;
        gameState.turn = 0;

        // Apply level parameters to map generation and entity placement
        const newMapWidth = Math.floor(MAP_WIDTH_TILES * params.mapSizeMultiplier);
        const newMapHeight = Math.floor(MAP_HEIGHT_TILES * params.mapSizeMultiplier);
        
        // Ensure map dimensions don't exceed canvas size, or adjust canvas size
        const effectiveMapWidth = Math.min(newMapWidth, Math.floor(canvas.width / TILE_SIZE));
        const effectiveMapHeight = Math.min(newMapHeight, Math.floor(canvas.height / TILE_SIZE));

        gameState.map = generateMap(effectiveMapWidth, effectiveMapHeight);
        gameState.enemies = []; // Clear enemies from previous level
        gameState.potions = []; // Clear potions from previous level
        
        placeEntities(params.enemyCount, params.potionCount, effectiveMapWidth, effectiveMapHeight);

        gameState.initialTime = params.timer;
        statusText.textContent = `Level ${gameState.currentLevel}: ${params.name}!`;
    }

    gameState.remainingTime = gameState.initialTime; // Reset timer for new level
    gameState.startTime = performance.now(); // Reset start time for countdown
    gameLoop(); // Start the game loop for the new level
    updateUI();
}

// --- Map Generation ---
function generateMap(width = MAP_WIDTH_TILES, height = MAP_HEIGHT_TILES) {
    // Cellular automata for organic-looking dungeons
    let map = Array.from({ length: height }, () =>
        Array.from({ length: width }, () => Math.random() < 0.45 ? Wall : Floor)
    );

    for (let i = 0; i < 4; i++) {
        let newMap = JSON.parse(JSON.stringify(map)); // Deep copy
        for (let y = 1; y < height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
                let wallCount = 0;
                for (let ny = y - 1; ny <= y + 1; ny++) {
                    for (let nx = x - 1; nx <= x + 1; nx++) {
                        if (map[ny][nx] === Wall) {
                            wallCount++;
                        }
                    }
                }
                newMap[y][x] = wallCount > 4 ? Wall : Floor;
            }
        }
        map = newMap;
    }

    // Add a border of walls
    for(let y = 0; y < height; y++) {
        map[y][0] = Wall;
        map[y][width-1] = Wall;
    }
    for(let x = 0; x < width; x++) {
        map[0][x] = Wall;
        map[height-1][x] = Wall;
    }

    return map;
}

// --- Entity Placement ---
function placeEntities(numEnemies, numPotions, mapWidth, mapHeight) {
    const floorTiles = [];
    for (let y = 0; y < mapHeight; y++) {
        for (let x = 0; x < mapWidth; x++) {
            if (gameState.map[y][x] === Floor) {
                floorTiles.push({ x, y });
            }
        }
    }

    const getRandomTile = () => {
        if (floorTiles.length === 0) {
            console.warn("No more floor tiles available for entity placement!");
            return { x: 1, y: 1 }; // Fallback
        }
        const index = Math.floor(Math.random() * floorTiles.length);
        return floorTiles.splice(index, 1)[0];
    };

    // Place Player, Key, Exit
    Object.assign(gameState.player, getRandomTile());
    Object.assign(gameState.key, getRandomTile());
    Object.assign(gameState.exit, getRandomTile());

    // Place Enemies
    for (let i = 0; i < numEnemies; i++) {
        if (floorTiles.length > 0) {
            const enemyPos = getRandomTile();
            gameState.enemies.push({ x: enemyPos.x, y: enemyPos.y, frozenTurns: 0 });
        }
    }

    // Place Potions
    for (let i = 0; i < numPotions; i++) {
        if(floorTiles.length > 0) gameState.potions.push(getRandomTile());
    }
}

// --- Boss Level Specific Functions ---
function generateBossMap() {
    let map = Array.from({ length: MAP_HEIGHT_TILES }, () =>
        Array.from({ length: MAP_WIDTH_TILES }, () => Floor) // Mostly open floor
    );
    // Add a border of walls
    for(let y = 0; y < MAP_HEIGHT_TILES; y++) {
        map[y][0] = Wall;
        map[y][MAP_WIDTH_TILES-1] = Wall;
    }
    for(let x = 0; x < MAP_WIDTH_TILES; x++) {
        map[0][x] = Wall;
        map[MAP_HEIGHT_TILES-1][x] = Wall;
    }
    // Some central obstacles for the boss fight
    map[5][5] = Wall; map[5][6] = Wall;
    map[6][5] = Wall; map[6][6] = Wall;
    map[3][10] = Wall; map[4][10] = Wall;
    map[8][2] = Wall; map[8][3] = Wall;

    return map;
}

function placeBossAndPlayer() {
    // Place player near the bottom/center
    gameState.player.x = Math.floor(MAP_WIDTH_TILES / 2);
    gameState.player.y = MAP_HEIGHT_TILES - 2;

    // Place boss near the top/center
    gameState.enemies[0].x = Math.floor(MAP_WIDTH_TILES / 2);
    gameState.enemies[0].y = 1;

    // Ensure they are not on a wall (shouldn't happen with generateBossMap)
    if (gameState.map[gameState.player.y][gameState.player.x] === Wall) {
        gameState.player.y--; // Move up if on wall (simple fallback)
    }
    if (gameState.map[gameState.enemies[0].y][gameState.enemies[0].x] === Wall) {
        gameState.enemies[0].y++; // Move down if on wall
    }
}

// --- Boss Abilities ---
function activateBossAbility() {
    const boss = gameState.enemies.find(e => e.isBoss);
    if (!boss || boss.frozenTurns > 0) return; // Only if boss exists and isn't frozen

    if (boss.abilityTimer <= 0) {
        const abilityRoll = Math.random();
        const mapWidth = gameState.map[0].length;
        const mapHeight = gameState.map.length;

        const getEmptyTile = () => {
            const floorTiles = [];
            for (let y = 0; y < mapHeight; y++) {
                for (let x = 0; x < mapWidth; x++) {
                    if (gameState.map[y][x] === Floor &&
                        !(x === gameState.player.x && y === gameState.player.y) && // Not on player
                        !gameState.enemies.some(e => e.x === x && e.y === y)) { // Not on any other enemy
                        floorTiles.push({ x, y });
                    }
                }
            }
            if (floorTiles.length > 0) {
                return floorTiles[Math.floor(Math.random() * floorTiles.length)];
            }
            return null;
        };

        if (abilityRoll < 0.5) { // 50% chance for teleport
            const newPos = getEmptyTile();
            if (newPos) {
                boss.x = newPos.x;
                boss.y = newPos.y;
                statusText.textContent = "Demon Lord Teleported! ‚ö°Ô∏è";
            }
        } else { // 50% chance for summon
            if (gameState.enemies.length < 5) { // Limit total enemies to 5 (Boss + 4 minions)
                const summonPos = getEmptyTile();
                if (summonPos) {
                    gameState.enemies.push({ x: summonPos.x, y: summonPos.y, frozenTurns: 0 });
                    statusText.textContent = "Demon Lord Summoned a Minion! üòà";
                }
            }
        }
        boss.abilityTimer = boss.abilityCooldown; // Reset timer after ability use
    } else {
        boss.abilityTimer--; // Countdown
    }
}


// --- Game Logic ---
function isWalkable(x, y) {
    const currentMapHeight = gameState.map.length;
    const currentMapWidth = gameState.map[0].length;
    return x >= 0 && x < currentMapWidth && y >= 0 && y < currentMapHeight && gameState.map[y][x] === Floor;
}

function movePlayer(dx, dy) {
    if (gameState.gameOver || gameState.gameWon || gameState.isPaused || gameState.levelComplete) return; // Prevent movement during level complete transition

    const nextX = gameState.player.x + dx;
    const nextY = gameState.player.y + dy;

    if (isWalkable(nextX, nextY)) {
        gameState.player.x = nextX;
        gameState.player.y = nextY;
        gameState.score += 10; // Add score for movement

        // Only move enemies and check interactions after player moves
        moveEnemies();
        checkInteractions();
        updateUI();
    }
}

function moveEnemies() {
    // Filter out enemies that have been "killed" by freezing
    gameState.enemies = gameState.enemies.filter(enemy => {
        if (enemy.frozenTurns > 0) {
            enemy.frozenTurns--;
            // If turns run out and it was marked for killed (regular enemy)
            // OR if it's the boss and its HP is 0 (boss killed)
            if (enemy.frozenTurns === 0 && (enemy.killed || (enemy.isBoss && enemy.hp <= 0))) {
                if (enemy.isBoss) {
                    gameState.score += 500; // Big points for boss
                    gameState.gameWon = true; // Win the game when boss is defeated
                    gameState.messageOnCanvas = "You defeated the Demon Lord! üéâ"; // Message on canvas
                    gameState.messageDisplayDuration = 3000;
                    handleGameEndOrLevelComplete(true); // Handle game won scenario
                } else {
                    gameState.score += 100; // Regular enemy points
                    statusText.textContent = "Dragon defeated! +100 Score! üèÜ";
                }
                return false; // Remove the enemy
            }
            return true; // Keep enemy if still frozen or not killed
        }
        return true; // Keep regular enemies
    });

    // Boss ability check per turn
    if (gameState.isBossLevel && !gameState.gameWon) { // Only activate if boss is alive and game isn't won
        activateBossAbility();
    }

    gameState.enemies.forEach(enemy => {
        if (enemy.frozenTurns > 0) {
            // No movement if frozen
            return;
        }

        let dx = 0, dy = 0;

        // If it's the boss or a random chance to hunt player
        const huntPlayer = Math.random() > 0.5; // Regular enemies sometimes just wander

        if (enemy.isBoss || huntPlayer) {
            dx = Math.sign(gameState.player.x - enemy.x);
            dy = Math.sign(gameState.player.y - enemy.y);
            // Prioritize horizontal or vertical movement randomly
            if (dx !== 0 && dy !== 0) {
                if (Math.random() < 0.5) {
                    dy = 0;
                } else {
                    dx = 0;
                }
            }
        } else {
            // Random movement for non-hunting enemies
            dx = Math.floor(Math.random() * 3) - 1;
            dy = Math.floor(Math.random() * 3) - 1;
        }

        const nextX = enemy.x + dx;
        const nextY = enemy.y + dy;

        // Ensure enemy doesn't move onto another enemy
        const collisionWithOtherEnemy = gameState.enemies.some(otherEnemy =>
            otherEnemy !== enemy && otherEnemy.x === nextX && otherEnemy.y === nextY
        );

        if (isWalkable(nextX, nextY) && !collisionWithOtherEnemy) {
            enemy.x = nextX;
            enemy.y = nextY;
        }

        // Check for collision with player after enemy move
        if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
            takeDamage(enemy.isBoss ? 30 : 15); // Boss deals more damage
            enemy.frozenTurns = enemy.isBoss ? 1 : 2; // Boss might freeze for less turns
        }
    });
}

function takeDamage(amount) {
    gameState.player.hp = Math.max(0, gameState.player.hp - amount);
    if (gameState.player.hp <= 0) {
        gameState.gameOver = true;
        gameState.gameOverReason = 'hp';
        handleGameEndOrLevelComplete(false); // Handle game over scenario
    }
    updateUI();
}

function useBomb() {
    if (gameState.gameOver || gameState.gameWon || gameState.isPaused || gameState.levelComplete) return;
    if (gameState.player.bombs <= 0) {
        statusText.textContent = "No bombs left! üí•";
        return;
    }

    gameState.player.bombs--;
    let enemiesAffected = false;
    const bombRange = 3;

    gameState.enemies.forEach(enemy => {
        const distance = Math.abs(gameState.player.x - enemy.x) + Math.abs(gameState.player.y - enemy.y);
        if (distance <= bombRange) {
            enemiesAffected = true;
            if (enemy.isBoss) {
                enemy.hp -= 25; // Boss takes damage from bomb
                enemy.frozenTurns = 1; // Boss only freezes for 1 turn
                statusText.textContent = `BOMB! Boss hit! Boss HP: ${enemy.hp} üëπ`;
            } else {
                enemy.frozenTurns = 2; // Stun for 2 turns
                enemy.killed = true; // Mark for killing once frozen turns expire
            }
        }
    });

    if (enemiesAffected) {
        // Only set general message if no specific boss hit message was set
        if (!gameState.enemies.some(e => e.isBoss && e.frozenTurns > 0)) {
            statusText.textContent = "BOMB! Enemies affected! üí•";
        }
    } else {
        takeDamage(20); // Damage player if no enemies in range
        statusText.textContent = "BOMB! No enemies in range, you took damage! ü§ï";
    }
    updateUI();
    draw(); // Redraw immediately to show frozen enemies
}

function handleGameEndOrLevelComplete(isWin) {
    if (animationFrameId) { // Stop game loop
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }
    pauseMenuModal.style.display = 'none'; // Ensure pause menu is hidden

    draw(); // Draw final state with message on canvas

    setTimeout(() => {
        if (isWin) {
            if (gameState.isBossLevel) {
                // Game completely won (boss defeated)
                alert("CONGRATULATIONS! You have escaped the dungeon and defeated the Demon Lord!");
                window.location.href = 'turtle.html'; // Or a dedicated win page
            } else {
                // Regular level complete, proceed to next
                gameState.currentLevel++; // THIS IS WHERE THE LEVEL IS INCREMENTED FOR REGULAR WINS
                // Check if next level is boss level
                if (gameState.currentLevel > 5) {
                    statusText.textContent = "You escaped the dungeon! Prepare for the Final Boss! üòà";
                } else {
                    statusText.textContent = `Level ${gameState.currentLevel} Unlocked!`;
                }
                startGame(); // Start next level
            }
        } else { // Game Over (lost)
            // Level degradation logic
            if (gameState.isBossLevel) {
                gameState.currentLevel = 1; // Die on boss, go back to level 1
            } else {
                gameState.currentLevel = Math.max(1, gameState.currentLevel - 1); // Go back one level, min is 1
            }
            // Reset core game state to prepare for new level load
            gameState.score = 0; // Reset score on death
            
            startGame(); // Restart the game from the adjusted currentLevel
        }
    }, gameState.messageDisplayDuration || 3000); // Wait for message duration or 3 seconds
}


function checkInteractions() {
    if (gameState.isBossLevel) {
        // Boss level win condition: all enemies (just the boss) are defeated, handled in moveEnemies filter
        return;
    }

    // Normal level key interaction
    if (!gameState.hasKey && gameState.player.x === gameState.key.x && gameState.player.y === gameState.key.y) {
        gameState.hasKey = true;
        statusText.textContent = "You found the key! Now find the door! üö™";
    }

    // Normal level exit interaction
    if (gameState.hasKey && gameState.player.x === gameState.exit.x && gameState.player.y === gameState.exit.y) {
        gameState.levelComplete = true; // Set flag that level is complete
        gameState.messageDisplayDuration = 3000; // Display message for 3 seconds

        if (gameState.currentLevel < 5) {
            gameState.messageOnCanvas = `Level ${gameState.currentLevel} Complete!`;
        } else {
            gameState.messageOnCanvas = "You escaped the dungeon! Prepare for the Final Boss! üòà";
        }
        handleGameEndOrLevelComplete(true);
    }

    // Potions interaction
    gameState.potions = gameState.potions.filter(potion => {
        if (potion.x === gameState.player.x && potion.y === gameState.player.y) {
            gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 50);
            statusText.textContent = "Healed! +50 HP! ‚ù§Ô∏è";
            return false; // Remove potion
        }
        return true;
    });
}

// --- Game Loop and Drawing ---
function update() {
    gameState.turn++;
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Adjust drawing based on current map size (important if map size changes per level)
    const currentMapHeight = gameState.map.length;
    const currentMapWidth = gameState.map[0].length;

    for (let y = 0; y < currentMapHeight; y++) {
        for (let x = 0; x < currentMapWidth; x++) {
            if (gameState.map[y][x] === Floor) {
                // Optionally draw floor tiles if they have a specific background
                // ctx.fillStyle = '#111';
                // ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            } else if (gameState.map[y][x] === Wall) {
                ctx.font = `${TILE_SIZE * 0.8}px monospace`; // Standard font for entities
                ctx.fillText(Wall, x * TILE_SIZE, y * TILE_SIZE + TILE_SIZE);
            }
        }
    }

    const drawEntity = (entity, symbol) => {
        ctx.font = `${TILE_SIZE * 0.8}px monospace`;
        ctx.fillText(symbol, entity.x * TILE_SIZE, entity.y * TILE_SIZE + TILE_SIZE);
    };

    // Only draw key and exit if not boss level AND not in a levelComplete/gameWon state
    if (!gameState.isBossLevel && !gameState.levelComplete && !gameState.gameWon) {
        if(!gameState.hasKey) drawEntity(gameState.key, Key);
        drawEntity(gameState.exit, Exit);
    }
    // Draw exit specifically if player is on it during level completion
    else if (!gameState.isBossLevel && (gameState.levelComplete || gameState.gameWon) && gameState.player.x === gameState.exit.x && gameState.player.y === gameState.exit.y) {
         drawEntity(gameState.exit, Exit);
    }

    gameState.potions.forEach(potion => drawEntity(potion, Potion));

    gameState.enemies.forEach(enemy => {
        let enemySymbol = Enemy;
        if (gameState.gameWon && enemy.isBoss) { // If game won and it's the boss (meaning it's defeated)
            enemySymbol = 'üíÄ'; // Show boss as defeated
        } else if (enemy.isBoss) {
            enemySymbol = enemy.frozenTurns > 0 ? 'ü•∂' : enemy.symbol; // Use 'ü•∂' for frozen boss
        } else if (enemy.frozenTurns > 0) {
            enemySymbol = FrozenEnemy;
        }
        drawEntity(enemy, enemySymbol);

        // Draw boss HP bar
        if (enemy.isBoss && !gameState.gameWon && !gameState.gameOver) {
            const barWidth = TILE_SIZE * 2; // Make boss HP bar wider
            const barHeight = 5;
            const hpRatio = enemy.hp / enemy.maxHp;
            const barX = enemy.x * TILE_SIZE + (TILE_SIZE - barWidth) / 2; // Center the bar above the boss
            const barY = enemy.y * TILE_SIZE - 10; // Position it 10 pixels above the boss

            ctx.fillStyle = 'red';
            ctx.fillRect(barX, barY, barWidth, barHeight);
            ctx.fillStyle = 'lime';
            ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
            ctx.strokeStyle = 'gray';
            ctx.strokeRect(barX, barY, barWidth, barHeight);
        }
    });

    let currentPlayerSymbol = Player;
    if (gameState.gameOver) {
        currentPlayerSymbol = 'üíÄ';
    } else if (gameState.gameWon) {
        currentPlayerSymbol = PlayerWin;
    }
    // Always draw player, even if on exit during level complete
    drawEntity(gameState.player, currentPlayerSymbol);


    // Draw messages on canvas (Game Over, Game Won, Level Complete)
    if (gameState.gameOver || gameState.gameWon || gameState.levelComplete) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = 'bold 60px Courier New';
        ctx.textAlign = 'center';
        
        let message = '';
        if (gameState.gameWon) {
            message = gameState.messageOnCanvas || 'YOU ESCAPED! üéâ';
            ctx.fillStyle = '#28a745';
        } else if (gameState.levelComplete) {
             message = gameState.messageOnCanvas || 'Level Complete! üéâ';
             ctx.fillStyle = '#007bff'; // Blue for level complete
        } else { // Game Over
            message = gameState.messageOnCanvas || (gameState.gameOverReason === 'time' ? 'Times up! ‚åõ' : 'Game Over! üíÄ');
            ctx.fillStyle = '#dc3545';
        }
        
        ctx.fillText(message, canvas.width / 2, canvas.height / 2 - 30);

        // Only show final score on definitive game over/win (not just level complete)
        if (gameState.gameOver || (gameState.gameWon && gameState.isBossLevel)) {
            ctx.font = 'bold 30px Courier New';
            ctx.fillStyle = 'white';
            ctx.fillText(`Final Score: ${gameState.score} üèÜ`, canvas.width / 2, canvas.height / 2 + 20);
        }
        ctx.textAlign = 'left'; // Reset text alignment
    }
}

function updateUI() {
    // UI status text is for ongoing game, not for game over/win messages on canvas
    if (gameState.gameOver || gameState.gameWon || gameState.levelComplete) {
        statusText.textContent = ""; // Clear UI status text during end screens
    } else if (gameState.hasKey) {
        statusText.textContent = "You found the key! Now find the door! üö™";
    } else if (gameState.isBossLevel) {
        statusText.textContent = "Defeat the Demon Lord! üëπ";
    } else {
        statusText.textContent = "Find the key üîë and escape!";
    }

    hpText.textContent = `HP: ${gameState.player.hp}`;
    bombText.textContent = `Bombs: ${gameState.player.bombs} üí£`;
    scoreText.textContent = `Score: ${gameState.score} üèÜ`;
    levelText.textContent = gameState.isBossLevel ? "Level: Boss" : `Level: ${gameState.currentLevel}`;

    const minutes = Math.floor(gameState.remainingTime / 60000);
    const seconds = Math.floor((gameState.remainingTime % 60000) / 1000);
    const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    timerText.textContent = `Time: ${formattedTime}`;

    if (gameState.remainingTime <= 10000 && gameState.remainingTime > 0) {
        timerText.style.color = 'orange'; // Change to orange when 10 seconds left
    } else if (gameState.remainingTime <= 0) {
        timerText.style.color = 'red'; // Change to red when time is up
    } else {
        timerText.style.color = 'white'; // Default color
    }
}

// Game loop (handles animation and timer)
function gameLoop(currentTime) {
    if (!gameState.startTime) {
        gameState.startTime = currentTime;
    }

    // Only update game logic and timer if not paused, game over, won, or level complete
    if (!gameState.isPaused && !gameState.gameOver && !gameState.gameWon && !gameState.levelComplete) {
        // Calculate elapsed time from the start
        const elapsedTimeFromStart = currentTime - gameState.startTime;
        // Calculate remaining time
        gameState.remainingTime = gameState.initialTime - elapsedTimeFromStart;

        if (gameState.remainingTime <= 0) {
            gameState.remainingTime = 0; // Cap at 0
            if (!gameState.gameOver && !gameState.gameWon && !gameState.levelComplete) {
                gameState.gameOver = true;
                gameState.gameOverReason = 'time';
                handleGameEndOrLevelComplete(false);
                return; // Stop current frame if game over
            }
        }
    }

    draw();
    updateUI();
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Event Listeners ---
document.addEventListener('keydown', handleInput);
resetButton.addEventListener('click', initGame);
bombButton.addEventListener('click', useBomb);

// Mobile D-pad listeners
upButton.addEventListener('click', () => movePlayer(0, -1));
downButton.addEventListener('click', () => movePlayer(0, 1));
leftButton.addEventListener('click', () => movePlayer(-1, 0));
rightButton.addEventListener('click', () => movePlayer(1, 0));

// Pause Button & Menu Listeners
pauseButton.addEventListener('click', togglePause);
pauseMenuPlayButton.addEventListener('click', togglePause);
pauseMenuRestartButton.addEventListener('click', () => {
    initGame(); // Resets everything to Level 1
    // togglePause() is not needed here as initGame() hides the modal
});
pauseMenuQuitButton.addEventListener('click', () => {
    window.location.href = 'turtle.html'; // Navigate back to turtle.html
});


// --- Pause Logic ---
function togglePause() {
    // Prevent pausing if game is already over or won
    if (gameState.gameOver || gameState.gameWon || gameState.levelComplete) return;

    gameState.isPaused = !gameState.isPaused; // Toggle the pause state

    if (gameState.isPaused) {
        pauseMenuModal.style.display = 'flex'; // Show the menu
        // Stop the game loop
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
    } else {
        pauseMenuModal.style.display = 'none'; // Hide the menu
        // Adjust startTime to account for the paused duration
        gameState.startTime = performance.now() - (gameState.initialTime - gameState.remainingTime);
        // Restart the game loop
        gameLoop(performance.now());
    }
}

function handleInput(event) {
    let dx = 0, dy = 0;

    // Handle pause key first, regardless of pause state
    if (event.key === 'p' || event.key === 'P') {
        togglePause();
        return; // Stop further processing if pause key was pressed
    }

    // If game is paused or over/won/level complete, prevent other inputs
    if (gameState.isPaused || gameState.gameOver || gameState.gameWon || gameState.levelComplete) return;

    switch (event.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            dy = -1;
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            dy = 1;
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            dx = -1;
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            dx = 1;
            break;
        case 'r':
        case 'R':
            initGame(); // Reset to Level 1
            return;
        case 'x':
        case 'X':
            useBomb();
            return;
        default:
            return;
    }
    movePlayer(dx, dy);
}


// --- Initial Setup ---
// Display the warning modal on game load
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('warningModal').style.display = 'flex';
});

function closeModal() {
    document.getElementById('warningModal').style.display = 'none';
    initGame(); // Start the game only after the warning modal is closed
}
</script>
<audio autoplay loop>
    <source src="back.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
</audio>
</body>
</html>
