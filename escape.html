<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Escape</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
    /* Global styles for the body */
    body {
        font-family: 'Courier New', Courier, monospace;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #2c2c2c;
        color: white;
        margin-top: 20px;
    }

    /* Navbar and header styling */
    ul {
        list-style-type: none;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #fa07e2;
        width: 1000px;
        border-radius: 8px;
        margin-bottom: 10px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    li {
        float: left;
    }
    li a {
        display: block;
        color: white;
        text-align: center;
        padding: 14px 16px;
        text-decoration: none;
        transition: background-color 0.3s;
    }
    li a:hover {
        background-color: #60fa07;
        color: #000000;
    }

    h1, p {
        color: #f3f4f6;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        text-align: center;
    }

    /* Game container and canvas styling */
    #game-container {
        border: 4px solid #ff0000;
        border-radius: 12px;
        padding: 10px;
        background-color: #000;
        box-shadow: 0 0 25px rgba(255, 0, 0, 0.7);
        margin-bottom: 20px;
        position: relative;
    }
    canvas {
        background-color: #111;
        display: block;
        width: 1000px;
        height: 750px;
    }

    /* Game UI (status, buttons) styling */
    #game-ui {
        width: 1000px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-top: 10px;
        padding: 0 5px;
    }
    #status-text {
        font-size: 1.2em;
        font-weight: bold;
        color: #f3f4f6;
        flex-grow: 1;
        text-align: left;
        margin-right: 10px;
    }
    #bomb-text, #hp-text, #timer-text {
        font-size: 1.2em;
        font-weight: bold;
        margin: 0 10px;
        white-space: nowrap;
    }
    #hp-text {
        color: #28a745;
    }
    #bomb-text {
        color: #FFA500;
    }
    #timer-text {
        color: #FFFFFF;
    }

    /* Button styling */
    button#resetButton {
        background-color: #ff0000;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 5px;
        cursor: pointer;
        font-family: inherit;
        font-size: 1em;
        font-weight: bold;
        transition: background-color 0.3s, transform 0.2s;
    }
    button#resetButton:hover {
        background-color: #32a852;
        color: black;
        transform: scale(1.05);
    }

    /* Mobile controls styling */
    #mobile-controls {
        margin-top: 20px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        padding-bottom: 20px;
    }
    .d-pad-row {
        display: flex;
        gap: 10px;
    }
    .arrow-button {
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 15px 20px;
        border-radius: 12px;
        cursor: pointer;
        font-size: 1.5em;
        font-weight: bold;
        transition: background-color 0.3s, transform 0.1s, box-shadow 0.2s;
        min-width: 65px;
        min-height: 65px;
        display: flex;
        justify-content: center;
        align-items: center;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    .arrow-button:hover {
        background-color: #45a049;
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0,0,0,0.4);
    }
    .arrow-button:active {
        transform: translateY(0);
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    #bombButton {
        background-color: #FF4500;
        border: 2px solid #CD3333;
    }
    #bombButton:hover {
        background-color: #E04000;
    }

    /* Modal styles */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.8);
        justify-content: center;
        align-items: center;
        transition: opacity 0.5s;
        opacity: 0;
    }
    .modal.show {
        display: flex;
        opacity: 1;
    }
    .modal-content {
        background-color: #333;
        color: #f3f4f6;
        padding: 30px;
        border: 2px solid #60fa07;
        border-radius: 15px;
        width: 90%;
        max-width: 550px;
        text-align: center;
        position: relative;
        box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        animation: bounceIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    }
    .modal-content h2 {
        color: #ff0000;
        margin-top: 0;
        font-size: 2em;
    }
    .modal-content p {
        color: #ccc;
        font-size: 1.1em;
    }
    .modal-content button {
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 12px 25px;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1.1em;
        margin-top: 20px;
        transition: background-color 0.3s, transform 0.2s;
    }
    .modal-content button:hover {
        background-color: #45a049;
        transform: scale(1.05);
    }
    .close-button {
        color: #aaa;
        position: absolute;
        top: 15px;
        right: 20px;
        font-size: 32px;
        font-weight: bold;
        cursor: pointer;
        transition: color 0.3s;
    }
    .close-button:hover, .close-button:focus {
        color: white;
    }
    @keyframes bounceIn {
        0% { transform: scale(0.8); opacity: 0; }
        60% { transform: scale(1.1); opacity: 1; }
        100% { transform: scale(1); }
    }
</style>
</head>
<body>
<!-- Tone.js for audio synthesis -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

<ul>
    <li><a href="turtle.html">‚¨Ö Back to game selection</a></li>
</ul>
<h1 class="text-3xl font-bold">Dungeon Escape</h1>
<p class="mt-2 text-sm">Use arrow keys, WASD, or the on-screen buttons</p>
<p class="text-sm">Press 'R' or click "New Game" to reset</p>

<div id="game-container">
    <canvas id="gameCanvas" width="1000" height="750"></canvas>
    <canvas id="confettiCanvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
</div>
<div id="game-ui">
    <span id="status-text">Find the key üîë and escape through the doorüö™!</span>
    <span id="bomb-text">Bombs: 3 üí£</span>
    <button id="resetButton">New Game</button>
    <span id="hp-text">HP: 100</span>
    <span id="timer-text">Time: 01:00</span>
</div>

<div id="mobile-controls">
    <div class="d-pad-row">
        <button id="upButton" class="arrow-button">‚¨ÜÔ∏è</button>
    </div>
    <div class="d-pad-row">
        <button id="leftButton" class="arrow-button">‚¨ÖÔ∏è</button>
        <button id="bombButton" class="arrow-button">üí£</button>
        <button id="rightButton" class="arrow-button">‚û°Ô∏è</button>
    </div>
    <div class="d-pad-row">
        <button id="downButton" class="arrow-button">‚¨áÔ∏è</button>
    </div>
</div>

<div id="warningModal" class="modal">
    <div class="modal-content">
        <span class="close-button" onclick="closeModal()">&times;</span>
        <h2>WARNING!</h2>
        <p>This game is SO hard that the creator himself could only beat it ONCE!! If you beat it, tell me in the comments of ANY of my videos and I will give you a shoutout!! Good luck and have fun!!</p>
        <button onclick="closeModal()">Got It!</button>
    </div>
</div>

<script>
    // --- Game Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const confettiCanvas = document.getElementById('confettiCanvas');
    const confettiCtx = confettiCanvas.getContext('2d');
    const resetButton = document.getElementById('resetButton');
    const statusText = document.getElementById('status-text');
    const hpText = document.getElementById('hp-text');
    const bombText = document.getElementById('bomb-text');
    const timerText = document.getElementById('timer-text');
    const bombButton = document.getElementById('bombButton');

    const TILE_SIZE = 40;
    const MAP_WIDTH_TILES = Math.floor(1000 / TILE_SIZE);
    const MAP_HEIGHT_TILES = Math.floor(750 / TILE_SIZE);

    // Constants for map and entity symbols
    const Wall = 'ü™®';
    const Floor = ' ';
    const Player = 'üö∂';
    const Enemy = 'üêâ';
    const GIANT_DRAGON_BOSS = 'üê≤';
    const Key = 'üîë';
    const Exit = 'üö™';
    const Potion = '‚ù§Ô∏è';
    const FrozenEnemy = '‚ùÑÔ∏è';
    const PlayerWin = 'ü•≥';

    let gameState = {};
    let animationFrameId;
    let audioContextStarted = false;

    // Confetti variables
    let confetti = [];
    const confettiCount = 300;
    const confettiColors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];

    /**
     * Confetti particle class
     */
    class Confetti {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.size = Math.random() * 10 + 5;
            this.color = color;
            this.tilt = Math.random() * 360;
            this.tiltAngle = Math.random() * 0.1 + 0.05;
            this.velocity = {
                x: Math.random() * 4 - 2,
                y: Math.random() * -10 - 5
            };
            this.gravity = 0.3;
        }

        update() {
            this.velocity.y += this.gravity;
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.tilt += this.tiltAngle;
        }

        draw() {
            confettiCtx.beginPath();
            confettiCtx.lineWidth = this.size;
            confettiCtx.strokeStyle = this.color;
            confettiCtx.moveTo(this.x, this.y);
            confettiCtx.lineTo(this.x + this.size, this.y + Math.sin(this.tilt));
            confettiCtx.stroke();
        }
    }

    /**
     * Generates a new confetti burst.
     */
    function startConfetti() {
        confetti = [];
        for (let i = 0; i < confettiCount; i++) {
            const x = Math.random() * confettiCanvas.width;
            const y = Math.random() * confettiCanvas.height / 2;
            const color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
            confetti.push(new Confetti(x, y, color));
        }
        playVictoryMusic();
    }

    /**
     * Animates the confetti.
     */
    function updateConfetti() {
        confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
        confetti = confetti.filter(p => p.y < confettiCanvas.height);
        confetti.forEach(p => {
            p.update();
            p.draw();
        });
    }

    // New explosion particle class for more graphics
    class ExplosionParticle {
        constructor(x, y, color, speed) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = Math.random() * 4 + 1;
            this.angle = Math.random() * 2 * Math.PI;
            this.speed = speed * (Math.random() * 0.5 + 0.5);
            this.velocity = {
                x: Math.cos(this.angle) * this.speed,
                y: Math.sin(this.angle) * this.speed
            };
            this.alpha = 1;
            this.gravity = 0.1;
        }

        update() {
            this.x += this.velocity.x;
            this.y += this.velocity.y;
            this.velocity.y += this.gravity;
            this.alpha -= 0.02;
        }

        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.alpha);
            ctx.fillStyle = this.color;
            ctx.fillRect(this.x, this.y, this.size, this.size);
            ctx.restore();
        }
    }

    // --- Sound Effects with Tone.js ---
    // New, more adventurous background music
    const backgroundSynth = new Tone.PolySynth(Tone.Synth, {
        volume: -10,
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.1, decay: 0.2, sustain: 0.8, release: 0.5 }
    }).toDestination();
    const backgroundLoop = new Tone.Loop(time => {
        backgroundSynth.triggerAttackRelease(["E4", "G#4", "B4"], "4n", time);
        backgroundSynth.triggerAttackRelease(["C#4", "E4", "G#4"], "4n", time + Tone.Time("4n"));
        backgroundSynth.triggerAttackRelease(["A4", "C#5", "E5"], "4n", time + Tone.Time("2n"));
        backgroundSynth.triggerAttackRelease(["F#4", "A4", "C#5"], "4n", time + Tone.Time("2n") + Tone.Time("4n"));
    }, "1n");

    function playBackgroundMusic() {
        if (backgroundLoop.state !== "started") {
            backgroundLoop.start();
        }
    }
    function stopBackgroundMusic() {
        if (backgroundLoop.state === "started") {
            backgroundLoop.stop();
        }
    }

    // Glitching sound effect for level transition
    const glitchSynth = new Tone.NoiseSynth({
        noise: { type: 'pink' },
        envelope: { attack: 0.001, decay: 0.05, sustain: 0.01, release: 0.05 }
    });
    const bitCrusher = new Tone.BitCrusher(4).toDestination();
    const pingPongDelay = new Tone.PingPongDelay("4n", 0.5).connect(bitCrusher);
    const filter = new Tone.Filter(300, 'lowpass').connect(pingPongDelay);
    glitchSynth.connect(filter);

    // New, more intense boss music
    const bassSynth = new Tone.MonoSynth({
        volume: -10,
        oscillator: { type: "square" },
        envelope: { attack: 0.1, decay: 0.2, sustain: 0.8, release: 0.5 },
        filter: { Q: 2, type: "lowpass", rolloff: -24 },
        filterEnvelope: { attack: 0.02, decay: 0.8, sustain: 0.5, release: 0.5, basePath: 200, octaves: 4 }
    }).toDestination();
    const melodySynth = new Tone.Synth({
        volume: -15,
        oscillator: { type: 'sawtooth' },
        envelope: { attack: 0.05, decay: 0.3, sustain: 0.6, release: 0.8 }
    }).toDestination();

    const bossLoop = new Tone.Loop(time => {
        bassSynth.triggerAttackRelease("A1", "8n", time);
        bassSynth.triggerAttackRelease("A1", "8n", time + Tone.Time("4n"));
        bassSynth.triggerAttackRelease("D2", "8n", time + Tone.Time("2n"));
        bassSynth.triggerAttackRelease("D2", "8n", time + Tone.Time("2n") + Tone.Time("4n"));

        melodySynth.triggerAttackRelease("C4", "16n", time + Tone.Time("8n"));
        melodySynth.triggerAttackRelease("C4", "16n", time + Tone.Time("4n") + Tone.Time("8n"));
        melodySynth.triggerAttackRelease("C#4", "16n", time + Tone.Time("2n") + Tone.Time("8n"));
        melodySynth.triggerAttackRelease("C#4", "16n", time + Tone.Time("2n") + Tone.Time("4n") + Tone.Time("8n"));

    }, "1n");

    function playBossMusic() {
        if (bossLoop.state !== "started") {
            bossLoop.start();
        }
    }
    function stopBossMusic() {
        if (bossLoop.state === "started") {
            bossLoop.stop();
        }
    }

    // New victory music
    const victorySynth = new Tone.PolySynth(Tone.Synth, {
        volume: -8,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.1, decay: 0.4, sustain: 0.7, release: 1.2 }
    }).toDestination();

    function playVictoryMusic() {
        victorySynth.triggerAttackRelease(["C5", "E5", "G5"], "2n");
        victorySynth.triggerAttackRelease(["A5", "C6", "E6"], "2n", Tone.Time("2n"));
        victorySynth.triggerAttackRelease(["F5", "A5", "C6"], "1n", Tone.Time("1n"));
    }

    // Proper explosion sound with multiple synths
    const explosionNoise = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }
    }).toDestination();
    const explosionThump = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 5,
        envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.4, attackCurve: 'exponential' }
    }).toDestination();
    const explosionMetal = new Tone.MetalSynth({
        frequency: 200,
        envelope: { attack: 0.001, decay: 0.1, release: 0.1 },
        harmonicity: 3.1,
        modulationIndex: 16,
        resonance: 4000,
        octaves: 1.5
    }).toDestination();
    const explosionReverb = new Tone.Reverb(2).toDestination();

    function playExplosionSound() {
        explosionNoise.triggerAttackRelease("4n");
        explosionThump.triggerAttackRelease("C1", "2n");
        explosionMetal.triggerAttackRelease("8n");
    }


    // --- Game Logic ---
    /**
     * Initializes or resets the game state.
     */
    function initGame() {
        if(animationFrameId) { cancelAnimationFrame(animationFrameId); }

        gameState = {
            map: [],
            player: { x: 0, y: 0, hp: 100, maxHp: 100, bombs: 5, attackDamage: 15 },
            enemies: [],
            key: { x: 0, y: 0 },
            exit: { x: 0, y: 0 },
            potions: [],
            hasKey: false,
            gameOver: false,
            gameWon: false,
            gameOverReason: null,
            turn: 0,
            startTime: null,
            initialTime: 0,
            elapsedTime: 0,
            completionTime: null,
            isTypingTime: false,
            typedCompletionTime: '',
            typedTimeLeft: '',
            currentLevel: 1,
            boss: null,
            bossDefeated: false,
            showingLevelTransition: false,
            levelTransitionMessage: '',
            cinematicActive: false,
            bossCinematicText: '',
            bossCinematicAlpha: 0,
            explosionActive: false,
            explosion: null,
            warning60sTriggered: false,
            warning30sTriggered: false,
            warning10sTriggered: false,
            countdownActive: false,
            glitchActive: false,
            glitchStartTime: 0,
            glitchDuration: 1500,
            glitchSoundInterval: null,
            glitchingTimer: false,
            bossIntroCountdownActive: false,
            bossIntroCountdownValue: 3,
            bossIntroCountdownStartTime: 0,
            bossIntroCountdownMessage: '',
            dragonMasterIntroCinematicActive: false,
            dragonMasterIntroCinematicText: '',
            dragonMasterIntroCinematicAlpha: 0,
            dragonMasterIntroCinematicStartTime: 0,
            confettiActive: false
        };
        stopBackgroundMusic();
        stopBossMusic();
        setupLevel(gameState.currentLevel);
        gameLoop();
    }

    /**
     * Sets up the game for a specific level.
     */
    function setupLevel(level) {
        gameState.player.x = 0;
        gameState.player.y = 0;
        gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 20);
        
        if (level === 3) {
            gameState.player.bombs = 8;
        } else {
            gameState.player.bombs += 2;
        }
        
        gameState.player.attackDamage = 15;

        gameState.hasKey = false;
        gameState.enemies = [];
        gameState.potions = [];
        gameState.boss = null;
        gameState.bossDefeated = false;

        gameState.warning60sTriggered = false;
        gameState.warning30sTriggered = false;
        gameState.warning10sTriggered = false;
        gameState.countdownActive = false;
        gameState.glitchActive = false;
        gameState.bossIntroCountdownActive = false;
        gameState.dragonMasterIntroCinematicActive = false;
        gameState.glitchingTimer = false;
        gameState.explosionActive = false;
        gameState.explosion = null;
        gameState.confettiActive = false;

        if (level < 3) {
            playBackgroundMusic();
        } else {
            stopBackgroundMusic();
        }

        switch(level) {
            case 1: gameState.initialTime = 90 * 1000; break;
            case 2: gameState.initialTime = 120 * 1000; break;
            case 3: gameState.initialTime = Infinity; gameState.glitchingTimer = true; break;
            default: gameState.initialTime = 60 * 1000;
        }

        let isMapValid = false;
        while (!isMapValid) {
            if (level === 3) {
                gameState.map = generateBossMap();
            } else {
                gameState.map = generateMap();
            }
            if (placeEntitiesForLevel(level)) {
                if (checkConnectivity()) {
                    isMapValid = true;
                } else {
                    console.log("Map not connected. Regenerating...");
                }
            }
        }
        
        if (level !== 3) {
            gameState.startTime = performance.now();
        } else {
            gameState.startTime = null;
            playBossMusic();
        }
        updateUI();
    }

    /**
     * Checks if all key entities are on a connected path.
     * Uses Breadth-First Search (BFS) to check reachability.
     */
    function checkConnectivity() {
        const start = {x: gameState.player.x, y: gameState.player.y};
        const key = {x: gameState.key.x, y: gameState.key.y};
        const exit = {x: gameState.exit.x, y: gameState.exit.y};

        // Check if player can reach the key and exit
        if (!canReach(start, key) || !canReach(start, exit)) {
            return false;
        }
        return true;
    }

    function canReach(start, target) {
        const queue = [start];
        const visited = new Set();
        const key = (x, y) => `${x},${y}`;
        visited.add(key(start.x, start.y));

        while (queue.length > 0) {
            const {x, y} = queue.shift();
            if (x === target.x && y === target.y) {
                return true;
            }
            const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
            for (const [dx, dy] of directions) {
                const newX = x + dx;
                const newY = y + dy;
                if (
                    newX >= 0 && newX < MAP_WIDTH_TILES &&
                    newY >= 0 && newY < MAP_HEIGHT_TILES &&
                    gameState.map[newY][newX] === Floor &&
                    !visited.has(key(newX, newY))
                ) {
                    visited.add(key(newX, newY));
                    queue.push({x: newX, y: newY});
                }
            }
        }
        return false;
    }

    /**
     * Procedurally generates a cave-like map using cellular automata.
     */
    function generateMap() {
        let map = Array.from({ length: MAP_HEIGHT_TILES }, () =>
            Array.from({ length: MAP_WIDTH_TILES }, () => Math.random() < 0.45 ? Wall : Floor)
        );
        for (let i = 0; i < 4; i++) {
            let newMap = JSON.parse(JSON.stringify(map));
            for (let y = 1; y < MAP_HEIGHT_TILES - 1; y++) {
                for (let x = 1; x < MAP_WIDTH_TILES - 1; x++) {
                    let wallCount = 0;
                    for (let ny = y - 1; ny <= y + 1; ny++) {
                        for (let nx = x - 1; nx <= x + 1; nx++) {
                            if (ny >= 0 && ny < MAP_HEIGHT_TILES && nx >= 0 && nx < MAP_WIDTH_TILES && map[ny][nx] === Wall) {
                                wallCount++;
                            }
                        }
                    }
                    newMap[y][x] = wallCount > 4 ? Wall : Floor;
                }
            }
            map = newMap;
        }
        for(let y = 0; y < MAP_HEIGHT_TILES; y++) { map[y][0] = map[y][MAP_WIDTH_TILES-1] = Wall; }
        for(let x = 0; x < MAP_WIDTH_TILES; x++) { map[0][x] = map[MAP_HEIGHT_TILES-1][x] = Wall; }
        return map;
    }

    /**
     * Generates a simpler, more open map for the boss fight.
     */
    function generateBossMap() {
        let map = Array.from({ length: MAP_HEIGHT_TILES }, () => Array.from({ length: MAP_WIDTH_TILES }, () => Floor));
        for(let y = 0; y < MAP_HEIGHT_TILES; y++) { map[y][0] = map[y][MAP_WIDTH_TILES-1] = Wall; }
        for(let x = 0; x < MAP_WIDTH_TILES; x++) { map[0][x] = map[MAP_HEIGHT_TILES-1][x] = Wall; }
        return map;
    }

    /**
     * Places entities based on the current level. Returns true if successful.
     */
    function placeEntitiesForLevel(level) {
        const floorTiles = [];
        for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
            for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                if (gameState.map[y][x] === Floor) { floorTiles.push({ x, y }); }
            }
        }
        const getRandomTile = () => {
            if (floorTiles.length === 0) { return null; }
            const index = Math.floor(Math.random() * floorTiles.length);
            return floorTiles.splice(index, 1)[0];
        };

        const playerPos = getRandomTile();
        if (!playerPos) return false;
        Object.assign(gameState.player, playerPos);

        if (level < 3) {
            const keyPos = getRandomTile();
            const exitPos = getRandomTile();
            if (!keyPos || !exitPos) return false;
            Object.assign(gameState.key, keyPos);
            Object.assign(gameState.exit, exitPos);

            const NUM_ENEMIES = level === 1 ? 5 : 8;
            for (let i = 0; i < NUM_ENEMIES; i++) {
                if (floorTiles.length > 0) { const enemyPos = getRandomTile(); gameState.enemies.push({ x: enemyPos.x, y: enemyPos.y, frozenTurns: 0 }); }
            }
            const NUM_POTIONS = 3;
            for (let i = 0; i < NUM_POTIONS; i++) {
                if(floorTiles.length > 0) gameState.potions.push(getRandomTile());
            }
        } else {
            const bossSize = 3;
            let bossCenter = getRandomTile();
            while (!bossCenter || (Math.abs(bossCenter.x - gameState.player.x) < 5 && Math.abs(bossCenter.y - gameState.player.y) < 5)) {
                bossCenter = getRandomTile();
            }
            if (!bossCenter) return false;

            let bossX = bossCenter.x - Math.floor(bossSize / 2);
            let bossY = bossCenter.y - Math.floor(bossSize / 2);
            for (let by = 0; by < bossSize; by++) {
                for (let bx = 0; bx < bossSize; bx++) {
                    const index = floorTiles.findIndex(t => t.x === bossX + bx && t.y === bossY + by);
                    if (index !== -1) floorTiles.splice(index, 1);
                }
            }
            gameState.boss = { x: bossX, y: bossY, hp: 300, maxHp: 300, damage: 30, frozenTurns: 0, size: bossSize };
            const exitPos = getRandomTile();
            if (!exitPos) return false;
            Object.assign(gameState.exit, exitPos);
            gameState.hasKey = false;
            // Key is placed at the boss's location, will be updated on defeat
            gameState.key.x = bossCenter.x;
            gameState.key.y = bossCenter.y;
        }
        return true;
    }

    /**
     * Main game loop, handles updates and drawing. This is a requestAnimationFrame loop,
     * but the game logic is turn-based, so `update()` only runs after player input.
     */
    function gameLoop(currentTime) {
        const isGameActive = !gameState.showingLevelTransition && !gameState.cinematicActive && !gameState.glitchActive && !gameState.dragonMasterIntroCinematicActive && !gameState.bossIntroCountdownActive && !gameState.gameWon && !gameState.gameOver;

        if (isGameActive) {
            if (!gameState.glitchingTimer) {
                if (!gameState.startTime) { gameState.startTime = currentTime; }
                gameState.elapsedTime = currentTime - gameState.startTime;
                gameState.remainingTime = gameState.initialTime - gameState.elapsedTime;
                if (gameState.remainingTime <= 0) {
                    gameState.remainingTime = 0;
                    if (!gameState.gameOver && !gameState.gameWon) {
                        gameState.gameOver = true;
                        gameState.gameOverReason = 'time';
                        stopBackgroundMusic();
                    }
                }
                const remainingSeconds = Math.floor(gameState.remainingTime / 1000);
                if (remainingSeconds === 60 && !gameState.warning60sTriggered) { statusText.textContent = '1 minute remaining!'; statusText.style.color = 'orange'; gameState.warning60sTriggered = true; }
                else if (remainingSeconds === 30 && !gameState.warning30sTriggered) { statusText.textContent = '30 seconds remaining!'; statusText.style.color = 'red'; gameState.warning30sTriggered = true; }
                else if (remainingSeconds === 10 && !gameState.warning10sTriggered) { statusText.textContent = '10 seconds remaining!'; statusText.style.color = 'darkred'; gameState.warning10sTriggered = true; }
                else if (remainingSeconds <= 5 && remainingSeconds > 0) { gameState.countdownActive = true; }
                else if (remainingSeconds === 0 && gameState.countdownActive) { gameState.countdownActive = false; }
            }
        }
        draw(currentTime);
        updateUI();
        if (gameState.confettiActive) {
            updateConfetti();
        }

        animationFrameId = requestAnimationFrame(gameLoop);
    }

    /**
     * Moves all enemies and the boss. This function is called only after the player
     * has made a move, making the game turn-based.
     */
    function moveGameEntities() {
        if (gameState.currentLevel === 3 && gameState.boss && !gameState.bossDefeated) {
            moveBoss(gameState.boss);
        } else {
            moveEnemies();
        }
    }

    /**
     * Moves all regular enemies based on simple AI.
     */
    function moveEnemies() {
        gameState.enemies.forEach(enemy => {
            if (enemy.frozenTurns > 0) { enemy.frozenTurns--; return; }
            const huntPlayer = Math.random() > 0.5;
            let dx = 0, dy = 0;
            if (huntPlayer) {
                dx = Math.sign(gameState.player.x - enemy.x);
                dy = Math.sign(gameState.player.y - enemy.y);
            } else {
                dx = Math.floor(Math.random() * 3) - 1;
                dy = Math.floor(Math.random() * 3) - 1;
            }
            const nextX = enemy.x + dx;
            const nextY = enemy.y + dy;
            if (isWalkable(nextX, nextY)) {
                enemy.x = nextX;
                enemy.y = nextY;
            }
            if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
                takeDamage(15);
                enemy.frozenTurns = 2;
            }
        });
    }

    /**
     * Moves the boss based on simple AI.
     */
    function moveBoss(boss) {
        if (boss.frozenTurns > 0) { boss.frozenTurns--; return; }

        let dx = Math.sign(gameState.player.x - (boss.x + Math.floor(boss.size / 2)));
        let dy = Math.sign(gameState.player.y - (boss.y + Math.floor(boss.size / 2)));

        const originalBossX = boss.x;
        const originalBossY = boss.y;

        const potentialBossX = boss.x + dx;
        const potentialBossY = boss.y + dy;

        let canMove = false;
        if (isBossPositionWalkable(potentialBossX, potentialBossY, boss.size)) {
            canMove = true;
            boss.x = potentialBossX;
            boss.y = potentialBossY;
        } else {
            if (isBossPositionWalkable(potentialBossX, originalBossY, boss.size)) {
                canMove = true;
                boss.x = potentialBossX;
                boss.y = originalBossY;
            }
            else if (isBossPositionWalkable(originalBossX, potentialBossY, boss.size)) {
                canMove = true;
                boss.x = originalBossX;
                boss.y = potentialBossY;
            }
        }

        if (isPlayerCollidingWithBoss(gameState.player, boss)) {
            takeDamage(boss.damage);
            boss.frozenTurns = 1;
        }
    }

    /**
     * Checks if a potential boss position is valid.
     */
    function isBossPositionWalkable(bossX, bossY, bossSize) {
        for (let by = 0; by < bossSize; by++) {
            for (let bx = 0; bx < bossSize; bx++) {
                const checkX = bossX + bx;
                const checkY = bossY + by;
                if (checkX < 0 || checkX >= MAP_WIDTH_TILES || checkY < 0 || checkY >= MAP_HEIGHT_TILES || gameState.map[checkY][checkX] === Wall) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Checks if the player is occupying any tile of the boss.
     */
    function isPlayerCollidingWithBoss(player, boss) {
        if (!boss) return false;
        return player.x >= boss.x && player.x < (boss.x + boss.size) &&
               player.y >= boss.y && player.y < (boss.y + boss.size);
    }

    /**
     * Renders the entire game state to the canvas.
     */
    function draw(currentTime) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `${TILE_SIZE * 0.8}px monospace`;
        ctx.filter = 'none';

        // Draw the walls
        for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
            for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                if (gameState.map[y][x] === Wall) { ctx.fillText(Wall, x * TILE_SIZE, y * TILE_SIZE + TILE_SIZE); }
            }
        }

        const drawEntity = (entity, symbol) => ctx.fillText(symbol, entity.x * TILE_SIZE, entity.y * TILE_SIZE + TILE_SIZE);

        // Draw level-specific entities
        if (gameState.currentLevel === 3) {
            if (gameState.bossDefeated && !gameState.hasKey) { drawEntity(gameState.key, Key); }
            if (gameState.boss && !gameState.bossDefeated) {
                for (let by = 0; by < gameState.boss.size; by++) {
                    for (let bx = 0; bx < gameState.boss.size; bx++) {
                        ctx.fillText(GIANT_DRAGON_BOSS, (gameState.boss.x + bx) * TILE_SIZE, (gameState.boss.y + by) * TILE_SIZE + TILE_SIZE);
                    }
                }
                drawBossHealthBar();
            }
            drawEntity(gameState.exit, Exit);
        } else {
            if(!gameState.hasKey) drawEntity(gameState.key, Key);
            drawEntity(gameState.exit, Exit);
        }

        // Draw other entities
        gameState.potions.forEach(potion => drawEntity(potion, Potion));
        gameState.enemies.forEach(enemy => {
            let enemySymbol = enemy.frozenTurns > 0 ? FrozenEnemy : Enemy;
            if (gameState.gameWon) enemySymbol = 'üíÄ';
            drawEntity(enemy, enemySymbol);
        });

        // Draw the player
        let currentPlayerSymbol = Player;
        if (gameState.gameOver) currentPlayerSymbol = 'üíÄ';
        else if (gameState.gameWon) currentPlayerSymbol = PlayerWin;
        drawEntity(gameState.player, currentPlayerSymbol);

        // Draw special effects and cinematics
        if (gameState.explosionActive) {
            gameState.explosion.draw(ctx);
        }

        if (gameState.showingLevelTransition) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 30px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.levelTransitionMessage, canvas.width / 2, canvas.height / 2);
            ctx.textAlign = 'left';
            return;
        }
        if (gameState.glitchActive) {
            drawGlitchEffect(currentTime);
            return;
        }
        if (gameState.dragonMasterIntroCinematicActive) {
            drawDragonMasterIntroCinematic(currentTime);
            return;
        }
        if (gameState.bossIntroCountdownActive) {
            drawBossIntroCountdown(currentTime);
            return;
        }
        if (gameState.cinematicActive) {
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = `rgba(255, 255, 255, ${gameState.bossCinematicAlpha})`;
            ctx.font = 'bold 40px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.bossCinematicText, canvas.width / 2, canvas.height / 2);
            ctx.textAlign = 'left';
        }

        if (gameState.gameOver || gameState.gameWon) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = gameState.gameWon ? '#28a745' : '#dc3545';
            ctx.font = 'bold 40px Courier New'; // Font size changed from 60px to 40px
            ctx.textAlign = 'center';
            let message = '';
            if (gameState.gameWon) {
                message = gameState.currentLevel === 3 ? 'The final boss will NEVER return because of YOUR braveness! Well done!' : 'YOU ESCAPED! üéâ';
            } else {
                message = (gameState.gameOverReason === 'time' ? 'Times up! ‚åõ' : 'Game Over! üíÄ');
            }
            ctx.fillText(message, canvas.width / 2, canvas.height / 2);

            if (gameState.gameWon && gameState.completionTime !== null) {
                ctx.font = 'bold 30px Courier New';
                ctx.fillStyle = '#FFFFFF';
                if (!gameState.isTypingTime) {
                    gameState.isTypingTime = true;
                    typeCompletionAndRemainingTime();
                }
                ctx.fillText(gameState.typedCompletionTime, canvas.width / 2, canvas.height / 2 + 50);
                ctx.fillText(gameState.typedTimeLeft, canvas.width / 2, canvas.height / 2 + 100);
                if (gameState.currentLevel === 3) {
                    ctx.font = 'bold 25px Courier New';
                    ctx.fillText("Don't forget to subscribe to Ethan and Isabella Unlocked on YT!!", canvas.width / 2, canvas.height / 2 + 150);
                }
            }
            ctx.textAlign = 'left';
        }
    }

    /**
     * Draws the boss's health bar on the canvas.
     */
    function drawBossHealthBar() {
        if (!gameState.boss || gameState.bossDefeated) return;
        const barWidth = 250;
        const barHeight = 25;
        const barX = (canvas.width / 2) - (barWidth / 2);
        const barY = 20;
        ctx.fillStyle = '#880000';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        const currentHealthWidth = (gameState.boss.hp / gameState.boss.maxHp) * barWidth;
        ctx.fillStyle = '#00FF00';
        ctx.fillRect(barX, barY, currentHealthWidth, barHeight);
        ctx.strokeStyle = '#FFFFFF';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        ctx.fillStyle = '#FFFFFF';
        ctx.font = '18px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`DRAGON HP: ${gameState.boss.hp}/${gameState.boss.maxHp}`, canvas.width / 2, barY + barHeight + 25);
        ctx.textAlign = 'left';
    }

    /**
     * Handles the typewriter effect for displaying text.
     */
    function typewriterEffect(text, speed, onComplete) {
        let i = 0;
        const interval = setInterval(() => {
            if (i < text.length) {
                if (text.startsWith("Time: ")) { gameState.typedCompletionTime = text.substring(0, i + 1); }
                else if (text.startsWith("Time left: ")) { gameState.typedTimeLeft = text.substring(0, i + 1); }
                i++;
            } else {
                clearInterval(interval);
                if (onComplete) { onComplete(); }
            }
        }, speed);
    }

    /**
     * Sequences the typing of completion time and remaining time.
     */
    function typeCompletionAndRemainingTime() {
        const minutes = Math.floor(gameState.completionTime / 60000);
        const seconds = Math.floor((gameState.completionTime % 60000) / 1000);
        const formattedCompletionTime = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        const timeLeftMillis = Math.max(0, gameState.initialTime - gameState.completionTime);
        const timeLeftMinutes = Math.floor(timeLeftMillis / 60000);
        const timeLeftSeconds = Math.floor((timeLeftMillis % 60000) / 1000);
        const formattedTimeLeft = `Time left: ${timeLeftMinutes.toString().padStart(2, '0')}:${timeLeftSeconds.toString().padStart(2, '0')}`;
        gameState.typedCompletionTime = '';
        gameState.typedTimeLeft = '';
        typewriterEffect(formattedCompletionTime, 75, () => {
            typewriterEffect(formattedTimeLeft, 75, () => {
                gameState.isTypingTime = false;
            });
        });
    }

    /**
     * Updates the game's UI elements.
     */
    function updateUI() {
        if (gameState.gameOver) { statusText.textContent = gameState.gameOverReason === 'time' ? 'Times up! ‚åõ' : 'Game Over! üíÄ'; statusText.style.color = '#dc3545'; }
        else if (gameState.gameWon) { statusText.textContent = gameState.currentLevel < 3 ? 'Level Complete! üéâ' : 'YOU ESCAPED! üéâ'; statusText.style.color = '#28a745'; }
        else {
            if (!gameState.bossIntroCountdownActive && !gameState.dragonMasterIntroCinematicActive && !gameState.showingLevelTransition) {
                if (gameState.currentLevel === 3) {
                    statusText.textContent = gameState.bossDefeated ? 'Key dropped! Find the exit! üîëüö™' : 'Defeat the Dragon Boss! üê≤';
                } else {
                    statusText.textContent = gameState.hasKey ? 'Key found! Find the exit! üö™' : 'Find the key üîë and escape through the doorüö™!';
                }
                statusText.style.color = '#f3f4f6';
            } else if (gameState.showingLevelTransition) { statusText.textContent = gameState.levelTransitionMessage; statusText.style.color = '#FFFFFF'; }
            else if (gameState.dragonMasterIntroCinematicActive) { statusText.textContent = 'Prepare yourself...'; statusText.style.color = '#FFF'; }
            else if (gameState.bossIntroCountdownActive) { statusText.textContent = 'GET READY!'; statusText.style.color = '#FF0'; }
            else { statusText.textContent = 'Find the key üîë and escape through the doorüö™!'; statusText.style.color = '#f3f4f6'; }
        }

        hpText.textContent = `HP: ${gameState.player.hp}`;
        hpText.style.color = gameState.player.hp > 30 ? '#28a745' : '#dc3545';
        bombText.textContent = `Bombs: ${gameState.player.bombs} üí£`;
        bombText.style.color = gameState.player.bombs > 0 ? '#FFA500' : '#dc3545';

        if (gameState.glitchingTimer) {
            const glitchChars = '!@#$%^&*()-+=~`{}[]|\\:;"<>,.?/';
            let glitchString = '';
            for (let i = 0; i < 5; i++) { glitchString += glitchChars[Math.floor(Math.random() * glitchChars.length)]; }
            timerText.textContent = `Time: ${glitchString}`;
            timerText.style.fontSize = '1.2em';
            timerText.style.color = '#ff00ff';
        } else {
            const remainingSeconds = Math.max(0, Math.floor(gameState.remainingTime / 1000));
            const minutes = Math.floor(remainingSeconds / 60);
            const seconds = remainingSeconds % 60;
            if (gameState.countdownActive) {
                timerText.textContent = `${remainingSeconds}!`;
                timerText.style.fontSize = '2em';
                timerText.style.color = 'red';
            } else {
                timerText.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                timerText.style.fontSize = '1.2em';
                timerText.style.color = remainingSeconds > 10 ? '#FFFFFF' : '#dc3545';
            }
        }
    }

    /**
     * Checks if a tile is walkable (not a wall and within bounds).
     */
    function isWalkable(x, y) {
        return x >= 0 && x < MAP_WIDTH_TILES && y >= 0 && y < MAP_HEIGHT_TILES && gameState.map[y][x] === Floor && !isOccupiedByEnemy(x, y) && (gameState.currentLevel !== 3 || !isOccupiedByBoss(x, y));
    }

    function isOccupiedByEnemy(x, y) { return gameState.enemies.some(enemy => enemy.x === x && enemy.y === y); }
    function isOccupiedByBoss(x, y) {
        if (!gameState.boss) return false;
        const boss = gameState.boss;
        return x >= boss.x && y >= boss.y && x < (boss.x + boss.size) && y < (boss.y + boss.size);
    }

    function takeDamage(amount) {
        gameState.player.hp = Math.max(0, gameState.player.hp - amount);
        if (gameState.player.hp <= 0 && !gameState.gameOver) {
            gameState.gameOver = true;
            gameState.gameOverReason = 'hp';
            stopBackgroundMusic();
            stopBossMusic();
        }
    }

    /**
     * Handles player actions based on input.
     * This function now calls `moveGameEntities()` to trigger the enemy turn.
     */
    function handlePlayerMove(dx, dy) {
        if (gameState.gameOver || gameState.gameWon || gameState.showingLevelTransition ||
            gameState.cinematicActive || gameState.glitchActive ||
            gameState.dragonMasterIntroCinematicActive || gameState.bossIntroCountdownActive) {
            return;
        }

        const newPlayerX = gameState.player.x + dx;
        const newPlayerY = gameState.player.y + dy;

        if (gameState.currentLevel === 3 && gameState.boss && !gameState.bossDefeated && isPlayerAttackingBoss(newPlayerX, newPlayerY, gameState.boss)) {
            attackBoss(gameState.boss);
            moveGameEntities();
            return;
        }

        const targetEnemyIndex = gameState.enemies.findIndex(enemy => enemy.x === newPlayerX && enemy.y === newPlayerY);
        if (targetEnemyIndex !== -1) {
            attackEnemy(targetEnemyIndex);
            moveGameEntities();
            return;
        }

        if (isWalkable(newPlayerX, newPlayerY)) {
            gameState.player.x = newPlayerX;
            gameState.player.y = newPlayerY;
        } else {
            if (newPlayerX >= 0 && newPlayerX < MAP_WIDTH_TILES && newPlayerY >= 0 && newPlayerY < MAP_HEIGHT_TILES && gameState.map[newPlayerY][newPlayerX] === Wall) {
                takeDamage(5);
            }
        }
        checkPickupsAndGoals();
        moveGameEntities();
    }

    /**
     * Helper to check if player is trying to attack the boss.
     */
    function isPlayerAttackingBoss(x, y, boss) {
        return x >= boss.x && y >= boss.y && x < (boss.x + boss.size) && y < (boss.y + boss.size);
    }

    function checkPickupsAndGoals() {
        if (gameState.currentLevel === 3) {
            if (gameState.bossDefeated && !gameState.hasKey && gameState.player.x === gameState.key.x && gameState.player.y === gameState.key.y) {
                gameState.hasKey = true;
                statusText.textContent = 'Key dropped! Find the exit! üîëüö™';
                statusText.style.color = '#f3f4f6';
            }
        } else {
            if (!gameState.hasKey && gameState.player.x === gameState.key.x && gameState.player.y === gameState.key.y) {
                gameState.hasKey = true;
            }
        }
        const potionIndex = gameState.potions.findIndex(p => p.x === gameState.player.x && p.y === gameState.player.y);
        if (potionIndex !== -1) {
            gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 20);
            gameState.potions.splice(potionIndex, 1);
        }
        if (gameState.hasKey && gameState.player.x === gameState.exit.x && gameState.player.y === gameState.exit.y) {
            if (gameState.currentLevel < 3) {
                let message = gameState.currentLevel === 1 ? 'Level 1 complete! Moving to Level 2...' : 'Level 2 complete! Moving on to ‡§Ö‡§®‡•ç‡§§‡§ø‡§Æ ‡§∂‡§§‡•ç‡§∞‡•Å...';
                showLevelTransition(message);
                if (gameState.currentLevel === 2) {
                    setTimeout(() => {
                        gameState.showingLevelTransition = false;
                        stopBackgroundMusic();
                        startGlitchTransition();
                    }, 1500);
                } else {
                    setTimeout(() => {
                        gameState.currentLevel++;
                        setupLevel(gameState.currentLevel);
                        gameState.showingLevelTransition = false;
                        gameState.startTime = performance.now();
                    }, 1500);
                }
            } else {
                if (gameState.bossDefeated) {
                    gameState.gameWon = true;
                    gameState.completionTime = gameState.elapsedTime;
                    stopBossMusic();
                    startConfetti();
                }
            }
        }
    }

    function attackEnemy(enemyIndex) {
        const enemy = gameState.enemies[enemyIndex];
        gameState.enemies.splice(enemyIndex, 1);
    }

    /**
     * Handles attacking the boss.
     */
    function attackBoss(boss) {
        if (!boss || boss.frozenTurns > 0) return;
        boss.hp -= gameState.player.attackDamage;
        if (boss.hp <= 0) {
            boss.hp = 0;
            gameState.bossDefeated = true;
            const bossCenter = { x: boss.x + Math.floor(boss.size / 2), y: boss.y + Math.floor(boss.size / 2) };
            gameState.key.x = bossCenter.x;
            gameState.key.y = bossCenter.y;
            playExplosionSound();
            startExplosion();
        }
    }

    /**
     * Initiates the boss explosion animation with more graphics.
     */
    function startExplosion() {
        gameState.explosionActive = true;
        const bossCenter = {
            x: gameState.boss.x * TILE_SIZE + TILE_SIZE * gameState.boss.size / 2,
            y: gameState.boss.y * TILE_SIZE + TILE_SIZE * gameState.boss.size / 2
        };
        gameState.explosion = {
            x: bossCenter.x,
            y: bossCenter.y,
            particles: [],
            rings: [
                { radius: 0, maxRadius: TILE_SIZE * 3, color: '#FF4500', alpha: 1 },
                { radius: 0, maxRadius: TILE_SIZE * 2, color: '#FFD700', alpha: 1 },
                { radius: 0, maxRadius: TILE_SIZE * 1, color: '#FFFFFF', alpha: 1 }
            ]
        };
        // Add particles
        for (let i = 0; i < 50; i++) {
            gameState.explosion.particles.push(new ExplosionParticle(
                gameState.explosion.x,
                gameState.explosion.y,
                ['#FF4500', '#FFD700', '#FFA500'][Math.floor(Math.random() * 3)],
                Math.random() * 5 + 3
            ));
        }

        gameState.boss = null;
        let explosionDuration = 1000;
        let startTime = performance.now();

        function animateExplosion(currentTime) {
            const elapsed = currentTime - startTime;
            if (elapsed < explosionDuration) {
                const progress = elapsed / explosionDuration;
                gameState.explosion.rings.forEach(ring => {
                    ring.radius = progress * ring.maxRadius;
                    ring.alpha = 1 - progress;
                });
                gameState.explosion.particles.forEach(p => p.update());
                requestAnimationFrame(animateExplosion);
            } else {
                gameState.explosionActive = false;
                gameState.explosion = null;
            }
        }
        
        // Draw method for the new explosion object
        gameState.explosion.draw = (ctx) => {
            // Draw main explosion rings
            gameState.explosion.rings.forEach(ring => {
                ctx.save();
                ctx.globalAlpha = Math.max(0, ring.alpha);
                ctx.fillStyle = ring.color;
                ctx.beginPath();
                ctx.arc(gameState.explosion.x, gameState.explosion.y, ring.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
            // Draw particles
            gameState.explosion.particles.forEach(p => p.draw(ctx));
        };

        requestAnimationFrame(animateExplosion);
    }

    /**
     * Shows a level transition message.
     */
    function showLevelTransition(message) {
        gameState.showingLevelTransition = true;
        gameState.levelTransitionMessage = message;
    }

    /**
     * Starts the glitch transition effect.
     */
    function startGlitchTransition() {
        gameState.glitchActive = true;
        gameState.glitchStartTime = performance.now();
        
        // This is the fix for the late glitch sound
        if (audioContextStarted) {
            filter.frequency.value = 1000;
            glitchSynth.triggerAttackRelease("16n");
        }
    }

    /**
     * Draws the visual glitch effect on the canvas.
     */
    function drawGlitchEffect(currentTime) {
        const elapsed = currentTime - gameState.glitchStartTime;
        if (elapsed < gameState.glitchDuration) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.filter = 'none';
            for (let i = 0; i < 50; i++) {
                ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 0.8 + 0.2})`;
                ctx.fillRect(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 50 + 10, Math.random() * 50 + 10);
            }
            for (let i = 0; i < 10; i++) {
                ctx.strokeStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.8)`;
                ctx.lineWidth = Math.random() * 5;
                ctx.beginPath();
                ctx.moveTo(0, Math.random() * canvas.height);
                ctx.lineTo(canvas.width, Math.random() * canvas.height);
                ctx.stroke();
            }
            if (Math.random() < 0.6) { ctx.filter = `hue-rotate(${Math.random() * 360}deg) blur(${Math.random() * 3}px) saturate(${Math.random() * 2 + 0.5})`; }
            else { ctx.filter = 'none'; }
        } else {
            gameState.glitchActive = false;
            gameState.currentLevel = 3;
            setupLevel(gameState.currentLevel);
            startDragonMasterIntroCinematic();
        }
    }

    /**
     * Starts the "As the shadows loom..." cinematic.
     */
    function startDragonMasterIntroCinematic() {
        gameState.dragonMasterIntroCinematicActive = true;
        gameState.dragonMasterIntroCinematicText = 'As the shadows loom... the Dragon Master appears!';
        gameState.dragonMasterIntroCinematicAlpha = 0;
        gameState.dragonMasterIntroCinematicStartTime = performance.now();
    }

    function drawDragonMasterIntroCinematic(currentTime) {
        const elapsed = currentTime - gameState.dragonMasterIntroCinematicStartTime;
        let fadeDuration = 1000;
        let holdDuration = 2000;
        let fadeOutDuration = 1000;
        let totalDuration = fadeDuration + holdDuration + fadeOutDuration;
        if (elapsed < totalDuration) {
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (elapsed < fadeDuration) { gameState.dragonMasterIntroCinematicAlpha = elapsed / fadeDuration; }
            else if (elapsed < fadeDuration + holdDuration) { gameState.dragonMasterIntroCinematicAlpha = 1; }
            else { gameState.dragonMasterIntroCinematicAlpha = 1 - ((elapsed - (fadeDuration + holdDuration)) / fadeOutDuration); }
            ctx.fillStyle = `rgba(255, 255, 255, ${gameState.dragonMasterIntroCinematicAlpha})`;
            ctx.font = 'bold 40px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.dragonMasterIntroCinematicText, canvas.width / 2, canvas.height / 2);
            ctx.textAlign = 'left';
        } else {
            gameState.dragonMasterIntroCinematicActive = false;
            startBossIntroCountdown();
        }
    }

    function startBossIntroCountdown() {
        gameState.bossIntroCountdownActive = true;
        gameState.bossIntroCountdownValue = 3;
        gameState.bossIntroCountdownStartTime = performance.now();
        gameState.bossIntroCountdownMessage = '3';
    }

    function drawBossIntroCountdown(currentTime) {
        const elapsedCountdownTime = currentTime - gameState.bossIntroCountdownStartTime;
        const remainingCountdownSeconds = 3 - Math.floor(elapsedCountdownTime / 1000);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#FFFFFF';
        ctx.font = 'bold 100px Courier New';
        ctx.textAlign = 'center';
        if (remainingCountdownSeconds > 0) { gameState.bossIntroCountdownMessage = remainingCountdownSeconds.toString(); }
        else if (elapsedCountdownTime < 4000) { gameState.bossIntroCountdownMessage = 'GO!'; }
        else {
            gameState.bossIntroCountdownActive = false;
            gameState.startTime = performance.now();
            return;
        }
        ctx.fillText(gameState.bossIntroCountdownMessage, canvas.width / 2, canvas.height / 2);
        ctx.textAlign = 'left';
    }

    /**
     * Uses a bomb.
     */
    function useBomb() {
        if (gameState.gameOver || gameState.gameWon || gameState.showingLevelTransition ||
            gameState.cinematicActive || gameState.glitchActive ||
            gameState.dragonMasterIntroCinematicActive || gameState.bossIntroCountdownActive ||
            gameState.player.bombs <= 0) {
            return;
        }
        gameState.player.bombs--;
        bombText.textContent = `Bombs: ${gameState.player.bombs} üí£`;
        let enemiesStunnedOrDamaged = false;
        const bombRadius = 1;
        for (let yOffset = -bombRadius; yOffset <= bombRadius; yOffset++) {
            for (let xOffset = -bombRadius; xOffset <= bombRadius; xOffset++) {
                const targetX = gameState.player.x + xOffset;
                const targetY = gameState.player.y + yOffset;
                if (targetX >= 0 && targetX < MAP_WIDTH_TILES && targetY >= 0 && targetY < MAP_HEIGHT_TILES) {
                    const targetEnemyIndex = gameState.enemies.findIndex(enemy => enemy.x === targetX && enemy.y === targetY);
                    if (targetEnemyIndex !== -1) { gameState.enemies[targetEnemyIndex].frozenTurns = 3; enemiesStunnedOrDamaged = true; }
                    const isBorderWall = (targetX === 0 || targetX === MAP_WIDTH_TILES - 1 || targetY === 0 || targetY === MAP_HEIGHT_TILES - 1);
                    if (gameState.map[targetY][targetX] === Wall && !isBorderWall) { gameState.map[targetY][targetX] = Floor; enemiesStunnedOrDamaged = true; }
                }
            }
        }
        if (gameState.currentLevel === 3 && gameState.boss && !gameState.bossDefeated) {
            let bossAffected = false;
            for (let by = 0; by < gameState.boss.size; by++) {
                for (let bx = 0; bx < gameState.boss.size; bx++) {
                    const bossPartX = gameState.boss.x + bx;
                    const bossPartY = gameState.boss.y + by;
                    if (Math.abs(bossPartX - gameState.player.x) <= bombRadius && Math.abs(bossPartY - gameState.player.y) <= bombRadius) {
                        gameState.boss.hp = Math.max(0, gameState.boss.hp - 50);
                        gameState.boss.frozenTurns = 2;
                        bossAffected = true;
                        enemiesStunnedOrDamaged = true;
                        break;
                    }
                }
                if (bossAffected) break;
            }
            if (gameState.boss.hp <= 0 && !gameState.bossDefeated) {
                gameState.boss.hp = 0;
                gameState.bossDefeated = true;
                const bossCenter = { x: gameState.boss.x + Math.floor(gameState.boss.size / 2), y: gameState.boss.y + Math.floor(gameState.boss.size / 2) };
                gameState.key.x = bossCenter.x;
                gameState.key.y = bossCenter.y;
                playExplosionSound();
                startExplosion();
            }
        }
        if (!enemiesStunnedOrDamaged) { takeDamage(10); statusText.textContent = 'Bomb missed! Took 10 damage!'; statusText.style.color = '#dc3545'; }
        else { statusText.textContent = 'Bomb deployed! Effects applied!'; statusText.style.color = '#f3f4f6'; }
        moveGameEntities();
    }

    // --- Event Listeners ---
    document.addEventListener('keydown', (e) => {
        // Prevent default scrolling for arrow keys and WASD keys
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'].includes(e.key.toLowerCase())) {
            e.preventDefault();
        }

        if (e.key === 'r' || e.key === 'R') { initGame(); return; }
        if (gameState.gameOver || gameState.gameWon || gameState.showingLevelTransition || gameState.cinematicActive || gameState.glitchActive || gameState.dragonMasterIntroCinematicActive || gameState.bossIntroCountdownActive) { return; }
        switch (e.key) {
            case 'ArrowUp': case 'w': case 'W': handlePlayerMove(0, -1); break;
            case 'ArrowDown': case 's': case 'S': handlePlayerMove(0, 1); break;
            case 'ArrowLeft': case 'a': case 'A': handlePlayerMove(-1, 0); break;
            case 'ArrowRight': case 'd': case 'D': handlePlayerMove(1, 0); break;
            case 'x': case 'X': useBomb(); break;
        }
    });

    resetButton.addEventListener('click', initGame);
    bombButton.addEventListener('click', useBomb);
    document.getElementById('upButton').addEventListener('click', () => handlePlayerMove(0, -1));
    document.getElementById('downButton').addEventListener('click', () => handlePlayerMove(0, 1));
    document.getElementById('leftButton').addEventListener('click', () => handlePlayerMove(-1, 0));
    document.getElementById('rightButton').addEventListener('click', () => handlePlayerMove(1, 0));

    // --- Modal Logic ---
    const warningModal = document.getElementById('warningModal');
    function showModal() { warningModal.classList.add('show'); }
    function closeModal() {
        warningModal.classList.remove('show');
        confettiCanvas.width = canvas.width;
        confettiCanvas.height = canvas.height;
        Tone.start().then(() => {
            audioContextStarted = true;
            Tone.Transport.start();
            initGame();
        });
    }

    window.onload = showModal;
</script>
</body>
</html>
