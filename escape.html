<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Escape</title>
<link href="tailwind.css" rel="stylesheet">
<style>
Â  Â  body {
Â  Â  Â  Â  font-family: 'Courier New', Courier, monospace;
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  background-color: #2c2c2c;
Â  Â  Â  Â  color: white;
Â  Â  Â  Â  margin-top: 20px;
Â  Â  }
Â  Â  ul {
Â  Â  Â  Â  list-style-type: none;
Â  Â  Â  Â  margin: 0;
Â  Â  Â  Â  padding: 0;
Â  Â  Â  Â  overflow: hidden;
Â  Â  Â  Â  background-color: #fa07e2;
Â  Â  Â  Â  width: 1000px;
Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
Â  Â  }
Â  Â  li {
Â  Â  Â  Â  float: left;
Â  Â  }
Â  Â  li a {
Â  Â  Â  Â  display: block;
Â  Â  Â  Â  color: white;
Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  padding: 14px 16px;
Â  Â  Â  Â  text-decoration: none;
Â  Â  Â  Â  transition: background-color 0.3s;
Â  Â  }
Â  Â  li a:hover {
Â  Â  Â  Â  background-color: #60fa07;
Â  Â  Â  Â  color: #000000;
Â  Â  }
Â  Â  h1, p {
Â  Â  Â  Â  color: #f3f4f6;
Â  Â  Â  Â  text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
Â  Â  Â  Â  text-align: center;
Â  Â  }
Â  Â  #game-container {
Â  Â  Â  Â  border: 4px solid #ff0000;
Â  Â  Â  Â  border-radius: 12px;
Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  background-color: #000;
Â  Â  Â  Â  box-shadow: 0 0 25px rgba(255, 0, 0, 0.7);
Â  Â  Â  Â  margin-bottom: 20px;
Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  z-index: 5;
Â  Â  }
Â  Â  #gameCanvas {
Â  Â  Â  Â  background-color: #111;
Â  Â  Â  Â  display: block;
Â  Â  Â  Â  width: 1000px;
Â  Â  Â  Â  height: 750px;
Â  Â  Â  Â  z-index: 10;
Â  Â  Â  Â  position: relative;
Â  Â  }
Â  Â  #confettiCanvas {
Â  Â  Â  Â  z-index: 15;
Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  pointer-events: none;
Â  Â  }
Â  Â  #game-ui {
Â  Â  Â  Â  width: 1000px;
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  justify-content: space-between;
Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  margin-top: 10px;
Â  Â  Â  Â  padding: 0 5px;
Â  Â  }
Â  Â  #status-text {
Â  Â  Â  Â  font-size: 1.2em;
Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  color: #f3f4f6;
Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  text-align: left;
Â  Â  Â  Â  margin-right: 10px;
Â  Â  }
Â  Â  #bomb-text, #hp-text, #timer-text {
Â  Â  Â  Â  font-size: 1.2em;
Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  margin: 0 10px;
Â  Â  Â  Â  white-space: nowrap;
Â  Â  }
Â  Â  #hp-text { color: #28a745; }
Â  Â  #bomb-text { color: #FFA500; }
Â  Â  #timer-text { color: #FFFFFF; }
Â  Â  button#resetButton {
Â  Â  Â  Â  background-color: #ff0000;
Â  Â  Â  Â  color: white;
Â  Â  Â  Â  border: none;
Â  Â  Â  Â  padding: 10px 20px;
Â  Â  Â  Â  border-radius: 5px;
Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  font-family: inherit;
Â  Â  Â  Â  font-size: 1em;
Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  transition: background-color 0.3s, transform 0.2s;
Â  Â  }
Â  Â  button#resetButton:hover {
Â  Â  Â  Â  background-color: #32a852;
Â  Â  Â  Â  color: black;
Â  Â  Â  Â  transform: scale(1.05);
Â  Â  }
Â  Â  #mobile-controls {
Â  Â  Â  Â  margin-top: 20px;
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  flex-direction: column;
Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  gap: 10px;
Â  Â  Â  Â  padding-bottom: 20px;
Â  Â  }
Â  Â  .d-pad-row {
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  gap: 10px;
Â  Â  }
Â  Â  .arrow-button {
Â  Â  Â  Â  background-color: #4CAF50;
Â  Â  Â  Â  color: white;
Â  Â  Â  Â  border: none;
Â  Â  Â  Â  padding: 15px 20px;
Â  Â  Â  Â  border-radius: 12px;
Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  font-size: 1.5em;
Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  transition: background-color 0.3s, transform 0.1s, box-shadow 0.2s;
Â  Â  Â  Â  min-width: 65px;
Â  Â  Â  Â  min-height: 65px;
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
Â  Â  }
Â  Â  .arrow-button:hover {
Â  Â  Â  Â  background-color: #45a049;
Â  Â  Â  Â  transform: translateY(-2px);
Â  Â  Â  Â  box-shadow: 0 6px 12px rgba(0,0,0,0.4);
Â  Â  }
Â  Â  .arrow-button:active {
Â  Â  Â  Â  transform: translateY(0);
Â  Â  Â  Â  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
Â  Â  }
Â  Â  #bombButton {
Â  Â  Â  Â  background-color: #FF4500;
Â  Â  Â  Â  border: 2px solid #CD3333;
Â  Â  }
Â  Â  #bombButton:hover {
Â  Â  Â  Â  background-color: #E04000;
Â  Â  }
Â  Â  .modal {
Â  Â  Â  Â  display: none;
Â  Â  Â  Â  position: fixed;
Â  Â  Â  Â  z-index: 1000;
Â  Â  Â  Â  left: 0;
Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  background-color: rgba(0,0,0,0.8);
Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  transition: opacity 0.5s;
Â  Â  Â  Â  opacity: 0;
Â  Â  }
Â  Â  .modal.show {
Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  opacity: 1;
Â  Â  }
Â  Â  .modal-content {
Â  Â  Â  Â  background-color: #333;
Â  Â  Â  Â  color: #f3f4f6;
Â  Â  Â  Â  padding: 30px;
Â  Â  Â  Â  border: 2px solid #60fa07;
Â  Â  Â  Â  border-radius: 15px;
Â  Â  Â  Â  width: 90%;
Â  Â  Â  Â  max-width: 550px;
Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  box-shadow: 0 10px 20px rgba(0,0,0,0.5);
Â  Â  Â  Â  animation: bounceIn 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
Â  Â  }
Â  Â  .modal-content h2 {
Â  Â  Â  Â  color: #ff0000;
Â  Â  Â  Â  margin-top: 0;
Â  Â  Â  Â  font-size: 2em;
Â  Â  }
Â  Â  .modal-content p {
Â  Â  Â  Â  color: #ccc;
Â  Â  Â  Â  font-size: 1.1em;
Â  Â  }
Â  Â  .modal-content button {
Â  Â  Â  Â  background-color: #4CAF50;
Â  Â  Â  Â  color: white;
Â  Â  Â  Â  border: none;
Â  Â  Â  Â  padding: 12px 25px;
Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  font-size: 1.1em;
Â  Â  Â  Â  margin-top: 20px;
Â  Â  Â  Â  transition: background-color 0.3s, transform 0.2s;
Â  Â  }
Â  Â  .modal-content button:hover {
Â  Â  Â  Â  background-color: #45a049;
Â  Â  Â  Â  transform: scale(1.05);
Â  Â  }
Â  Â  .close-button {
Â  Â  Â  Â  color: #aaa;
Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  top: 15px;
Â  Â  Â  Â  right: 20px;
Â  Â  Â  Â  font-size: 32px;
Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  cursor: pointer;
Â  Â  Â  Â  transition: color 0.3s;
Â  Â  }
Â  Â  .close-button:hover, .close-button:focus {
Â  Â  Â  Â  color: white;
Â  Â  }
Â  Â  @keyframes bounceIn {
Â  Â  Â  Â  0% { transform: scale(0.8); opacity: 0; }
Â  Â  Â  Â  60% { transform: scale(1.1); opacity: 1; }
Â  Â  Â  Â  100% { transform: scale(1); }
Â  Â  }
</style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<ul>
Â  Â  <li><a href="turtle.html">â¬… Back to others</a></li>
</ul>
<h1 class="text-3xl font-bold">Dungeon Escape</h1>
<p class="mt-2 text-sm">Use arrow keys, WASD, or the on-screen buttons</p>
<p class="text-sm">Press 'R' or click "New Game" to reset</p>
<audio id="glitchAudio" src="glitch.mp3" preload="auto"></audio>
<audio id="backgroundMusic" loop autoplay>
Â  Â  <source src="dungeon.mp3" type="audio/mpeg">
Â  Â  Your browser does not support the audio element.
</audio>
<audio id="explodeAudio" src="explode.mp3" preload="auto"></audio>
<img id="explosionImage" src="explode.gif" style="display: none;" onload="console.log('Explosion GIF loaded successfully');" onerror="console.error('Failed to load explosion GIF. Check file path or server setup.');">
<div id="game-container">
Â  Â  <canvas id="gameCanvas" width="1000" height="750"></canvas>
Â  Â  <canvas id="confettiCanvas" width="1000" height="750"></canvas>
</div>
<div id="game-ui">
Â  Â  <span id="status-text">Find the key ğŸ”‘ and escape through the doorğŸšª!</span>
Â  Â  <span id="bomb-text">Bombs: 3 ğŸ’£</span>
Â  Â  <button id="resetButton">New Game</button>
Â  Â  <span id="hp-text">HP: 100</span>
Â  Â  <span id="timer-text">Time: 01:00</span>
</div>
<div id="mobile-controls">
Â  Â  <div class="d-pad-row">
Â  Â  Â  Â  <button id="upButton" class="arrow-button">â¬†ï¸</button>
Â  Â  </div>
Â  Â  <div class="d-pad-row">
Â  Â  Â  Â  <button id="leftButton" class="arrow-button">â¬…ï¸</button>
Â  Â  Â  Â  <button id="bombButton" class="arrow-button">ğŸ’£</button>
Â  Â  Â  Â  <button id="rightButton" class="arrow-button">â¡ï¸</button>
Â  Â  </div>
Â  Â  <div class="d-pad-row">
Â  Â  Â  Â  <button id="downButton" class="arrow-button">â¬‡ï¸</button>
Â  Â  </div>
</div>
<div id="warningModal" class="modal">
Â  Â  <div class="modal-content">
Â  Â  Â  Â  <span class="close-button" onclick="closeModal()">&times;</span>
Â  Â  Â  Â  <h2>WARNING!</h2>
Â  Â  Â  Â  <p>This game is SO hard that the creator himself could only beat it ONCE!! If you beat it, tell me in the comments of ANY of my videos and I will give you a shoutout!! Good luck and have fun!!</p>
Â  Â  Â  Â  <button onclick="closeModal()">Got It!</button>
Â  Â  </div>
</div>
<script>
Â  Â  const canvas = document.getElementById('gameCanvas');
Â  Â  const ctx = canvas.getContext('2d');
Â  Â  const confettiCanvas = document.getElementById('confettiCanvas');
Â  Â  const confettiCtx = confettiCanvas.getContext('2d');
Â  Â  const resetButton = document.getElementById('resetButton');
Â  Â  const statusText = document.getElementById('status-text');
Â  Â  const hpText = document.getElementById('hp-text');
Â  Â  const bombText = document.getElementById('bomb-text');
Â  Â  const timerText = document.getElementById('timer-text');
Â  Â  const bombButton = document.getElementById('bombButton');
Â  Â  const glitchAudio = document.getElementById('glitchAudio');
Â  Â  const backgroundMusic = document.getElementById('backgroundMusic');
Â  Â  const explodeAudio = document.getElementById('explodeAudio');
Â  Â  const explosionImage = document.getElementById('explosionImage');

Â  Â  const TILE_SIZE = 40;
Â  Â  const MAP_WIDTH_TILES = Math.floor(1000 / TILE_SIZE);
Â  Â  const MAP_HEIGHT_TILES = Math.floor(750 / TILE_SIZE);

Â  Â  const Wall = 'ğŸª¨';
Â  Â  const Floor = ' ';
Â  Â  const Player = 'ğŸš¶';
Â  Â  const Enemy = 'ğŸ‰';
Â  Â  const GIANT_DRAGON_BOSS = 'ğŸ˜ˆ';
Â  Â  const DeadBoss = 'ğŸ’€';
Â  Â  const Key = 'ğŸ”‘';
Â  Â  const Exit = 'ğŸšª';
Â  Â  const Potion = 'â¤ï¸';
Â  Â  const FrozenEnemy = 'â„ï¸';
Â  Â  const PlayerWin = 'ğŸ¥³';

Â  Â  let gameState = {};
Â  Â  let animationFrameId;
Â  Â  let audioContextStarted = false;

Â  Â  let confetti = [];
Â  Â  const confettiCount = 300;
Â  Â  const confettiColors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4caf50', '#8bc34a', '#cddc39', '#ffeb3b', '#ffc107', '#ff9800', '#ff5722'];

Â  Â  class Confetti {
Â  Â  Â  Â  constructor(x, y, color) {
Â  Â  Â  Â  Â  Â  this.x = x;
Â  Â  Â  Â  Â  Â  this.y = y;
Â  Â  Â  Â  Â  Â  this.size = Math.random() * 10 + 5;
Â  Â  Â  Â  Â  Â  this.color = color;
Â  Â  Â  Â  Â  Â  this.tilt = Math.random() * 360;
Â  Â  Â  Â  Â  Â  this.tiltAngle = Math.random() * 0.1 + 0.05;
Â  Â  Â  Â  Â  Â  this.velocity = { x: Math.random() * 4 - 2, y: Math.random() * -10 - 5 };
Â  Â  Â  Â  Â  Â  this.gravity = 0.3;
Â  Â  Â  Â  }
Â  Â  Â  Â  update() {
Â  Â  Â  Â  Â  Â  this.velocity.y += this.gravity;
Â  Â  Â  Â  Â  Â  this.x += this.velocity.x;
Â  Â  Â  Â  Â  Â  this.y += this.velocity.y;
Â  Â  Â  Â  Â  Â  this.tilt += this.tiltAngle;
Â  Â  Â  Â  }
Â  Â  Â  Â  draw() {
Â  Â  Â  Â  Â  Â  confettiCtx.beginPath();
Â  Â  Â  Â  Â  Â  confettiCtx.lineWidth = this.size;
Â  Â  Â  Â  Â  Â  confettiCtx.strokeStyle = this.color;
Â  Â  Â  Â  Â  Â  confettiCtx.moveTo(this.x, this.y);
Â  Â  Â  Â  Â  Â  confettiCtx.lineTo(this.x + this.size, this.y + Math.sin(this.tilt));
Â  Â  Â  Â  Â  Â  confettiCtx.stroke();
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function startConfetti() {
Â  Â  Â  Â  console.log("Starting confetti");
Â  Â  Â  Â  confetti = [];
Â  Â  Â  Â  for (let i = 0; i < confettiCount; i++) {
Â  Â  Â  Â  Â  Â  const x = Math.random() * confettiCanvas.width;
Â  Â  Â  Â  Â  Â  const y = Math.random() * confettiCanvas.height / 2;
Â  Â  Â  Â  Â  Â  const color = confettiColors[Math.floor(Math.random() * confettiColors.length)];
Â  Â  Â  Â  Â  Â  confetti.push(new Confetti(x, y, color));
Â  Â  Â  Â  }
Â  Â  Â  Â  playVictoryMusic();
Â  Â  }

Â  Â  function updateConfetti() {
Â  Â  Â  Â  confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
Â  Â  Â  Â  confetti = confetti.filter(p => p.y < confettiCanvas.height);
Â  Â  Â  Â  confetti.forEach(p => { p.update(); p.draw(); });
Â  Â  }

Â  Â  class Explosion {
Â  Â  Â  Â  constructor(x, y) {
Â  Â  Â  Â  Â  Â  this.x = x;
Â  Â  Â  Â  Â  Â  this.y = y;
Â  Â  Â  Â  Â  Â  this.scale = 0.5;
Â  Â  Â  Â  Â  Â  this.alpha = 1;
Â  Â  Â  Â  Â  Â  this.startTime = performance.now();
Â  Â  Â  Â  Â  Â  this.imageLoaded = explosionImage.complete && explosionImage.naturalWidth !== 0;
Â  Â  Â  Â  Â  Â  if (!this.imageLoaded) {
Â  Â  Â  Â  Â  Â  Â  Â  console.warn("Explosion GIF not loaded, using fallback rectangle animation");
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  this.animationFrame = null;
Â  Â  Â  Â  }
Â  Â  Â  Â  update(currentTime) {
Â  Â  Â  Â  Â  Â  const elapsed = currentTime - this.startTime;
Â  Â  Â  Â  Â  Â  const duration = 1200; // Match GIF duration (~1.2s)
Â  Â  Â  Â  Â  Â  if (elapsed < duration) {
Â  Â  Â  Â  Â  Â  Â  Â  this.scale = 0.5 + (elapsed / duration);
Â  Â  Â  Â  Â  Â  Â  Â  this.alpha = 1 - (elapsed / duration);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  this.alpha = 0;
Â  Â  Â  Â  Â  Â  Â  Â  if (this.animationFrame) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cancelAnimationFrame(this.animationFrame);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  draw(ctx) {
Â  Â  Â  Â  Â  Â  if (this.alpha <= 0) return;
Â  Â  Â  Â  Â  Â  ctx.save();
Â  Â  Â  Â  Â  Â  ctx.globalAlpha = this.alpha;
Â  Â  Â  Â  Â  Â  const size = TILE_SIZE * 4 * this.scale; // 4x4 tile size for boss
Â  Â  Â  Â  Â  Â  const offsetX = this.x - size / 2;
Â  Â  Â  Â  Â  Â  const offsetY = this.y - size / 2;
Â  Â  Â  Â  Â  Â  if (this.imageLoaded) {
Â  Â  Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Attempt to remove black background (#000000)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalCompositeOperation = 'destination-out';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#000000';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(offsetX, offsetY, size, size);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalCompositeOperation = 'source-over';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(explosionImage, offsetX, offsetY, size, size);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("Drawing explosion GIF at:", this.x, this.y, "scale:", this.scale, "alpha:", this.alpha);
Â  Â  Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Error drawing explosion GIF:", e);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  this.drawFallback(ctx, offsetX, offsetY, size);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  this.drawFallback(ctx, offsetX, offsetY, size);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  ctx.restore();
Â  Â  Â  Â  }
Â  Â  Â  Â  drawFallback(ctx, offsetX, offsetY, size) {
Â  Â  Â  Â  Â  Â  ctx.fillStyle = `rgba(255, 165, 0, ${this.alpha})`;
Â  Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  Â  ctx.arc(offsetX + size / 2, offsetY + size / 2, size / 2, 0, 2 * Math.PI);
Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  Â  console.log("Drawing fallback explosion circle at:", offsetX, offsetY, "size:", size, "alpha:", this.alpha);
Â  Â  Â  Â  }
Â  Â  Â  Â  animate() {
Â  Â  Â  Â  Â  Â  if (this.alpha > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  this.draw(ctx);
Â  Â  Â  Â  Â  Â  Â  Â  this.animationFrame = requestAnimationFrame(() => this.animate());
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }

Â  Â  const bassSynth = new Tone.MonoSynth({
Â  Â  Â  Â  volume: -10,
Â  Â  Â  Â  oscillator: { type: "square" },
Â  Â  Â  Â  envelope: { attack: 0.1, decay: 0.2, sustain: 0.8, release: 0.5 },
Â  Â  Â  Â  filter: { Q: 2, type: "lowpass", rolloff: -24 },
Â  Â  Â  Â  filterEnvelope: { attack: 0.02, decay: 0.8, sustain: 0.5, release: 0.5, basePath: 200, octaves: 4 }
Â  Â  }).toDestination();
Â  Â  const melodySynth = new Tone.Synth({
Â  Â  Â  Â  volume: -15,
Â  Â  Â  Â  oscillator: { type: 'sawtooth' },
Â  Â  Â  Â  envelope: { attack: 0.05, decay: 0.3, sustain: 0.6, release: 0.8 }
Â  Â  }).toDestination();

Â  Â  const bossLoop = new Tone.Loop(time => {
Â  Â  Â  Â  bassSynth.triggerAttackRelease("A1", "8n", time);
Â  Â  Â  Â  bassSynth.triggerAttackRelease("A1", "8n", time + Tone.Time("4n"));
Â  Â  Â  Â  bassSynth.triggerAttackRelease("D2", "8n", time + Tone.Time("2n"));
Â  Â  Â  Â  bassSynth.triggerAttackRelease("D2", "8n", time + Tone.Time("2n") + Tone.Time("4n"));
Â  Â  Â  Â  melodySynth.triggerAttackRelease("C4", "16n", time + Tone.Time("8n"));
Â  Â  Â  Â  melodySynth.triggerAttackRelease("C4", "16n", time + Tone.Time("4n") + Tone.Time("8n"));
Â  Â  Â  Â  melodySynth.triggerAttackRelease("C#4", "16n", time + Tone.Time("2n") + Tone.Time("8n"));
Â  Â  Â  Â  melodySynth.triggerAttackRelease("C#4", "16n", time + Tone.Time("2n") + Tone.Time("4n") + Tone.Time("8n"));
Â  Â  }, "1n");

Â  Â  function playBossMusic() {
Â  Â  Â  Â  if (bossLoop.state !== "started") {
Â  Â  Â  Â  Â  Â  console.log("Starting boss music");
Â  Â  Â  Â  Â  Â  bossLoop.start();
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function stopBossMusic() {
Â  Â  Â  Â  if (bossLoop.state === "started") {
Â  Â  Â  Â  Â  Â  console.log("Stopping boss music");
Â  Â  Â  Â  Â  Â  bossLoop.stop();
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function playBackgroundMusic() {
Â  Â  Â  Â  if (gameState.currentLevel < 3 && backgroundMusic) {
Â  Â  Â  Â  Â  Â  console.log("Playing dungeon.mp3 for Level", gameState.currentLevel);
Â  Â  Â  Â  Â  Â  backgroundMusic.volume = 0.5;
Â  Â  Â  Â  Â  Â  backgroundMusic.play().catch(e => console.error("Error playing background music:", e));
Â  Â  Â  Â  } else if (gameState.currentLevel === 3) {
Â  Â  Â  Â  Â  Â  console.log("Switching to boss music for Level 3");
Â  Â  Â  Â  Â  Â  playBossMusic();
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function stopBackgroundMusic() {
Â  Â  Â  Â  if (backgroundMusic) {
Â  Â  Â  Â  Â  Â  console.log("Stopping dungeon.mp3");
Â  Â  Â  Â  Â  Â  backgroundMusic.pause();
Â  Â  Â  Â  Â  Â  backgroundMusic.currentTime = 0;
Â  Â  Â  Â  }
Â  Â  Â  Â  stopBossMusic();
Â  Â  }

Â  Â  const victorySynth = new Tone.PolySynth(Tone.Synth, {
Â  Â  Â  Â  volume: -8,
Â  Â  Â  Â  oscillator: { type: 'sine' },
Â  Â  Â  Â  envelope: { attack: 0.1, decay: 0.4, sustain: 0.7, release: 1.2 }
Â  Â  }).toDestination();

Â  Â  function playVictoryMusic() {
Â  Â  Â  Â  console.log("Playing victory music");
Â  Â  Â  Â  victorySynth.triggerAttackRelease(["C5", "E5", "G5"], "2n");
Â  Â  Â  Â  victorySynth.triggerAttackRelease(["A5", "C6", "E6"], "2n", Tone.Time("2n"));
Â  Â  Â  Â  victorySynth.triggerAttackRelease(["F5", "A5", "C6"], "1n", Tone.Time("1n"));
Â  Â  }

Â  Â  function playExplosionSound() {
Â  Â  Â  Â  console.log("Attempting to play explode.mp3");
Â  Â  Â  Â  if (explodeAudio) {
Â  Â  Â  Â  Â  Â  explodeAudio.currentTime = 0;
Â  Â  Â  Â  Â  Â  explodeAudio.play().catch(e => console.error("Error playing explosion sound:", e));
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  console.error("explodeAudio element not found");
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function initGame() {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  console.log("Initializing game");
Â  Â  Â  Â  Â  Â  if (animationFrameId) { cancelAnimationFrame(animationFrameId); }
Â  Â  Â  Â  Â  Â  gameState = {
Â  Â  Â  Â  Â  Â  Â  Â  map: [],
Â  Â  Â  Â  Â  Â  Â  Â  player: { x: 0, y: 0, hp: 100, maxHp: 100, bombs: 5, attackDamage: 15 },
Â  Â  Â  Â  Â  Â  Â  Â  enemies: [],
Â  Â  Â  Â  Â  Â  Â  Â  key: { x: 0, y: 0 },
Â  Â  Â  Â  Â  Â  Â  Â  exit: { x: 0, y: 0 },
Â  Â  Â  Â  Â  Â  Â  Â  potions: [],
Â  Â  Â  Â  Â  Â  Â  Â  hasKey: false,
Â  Â  Â  Â  Â  Â  Â  Â  gameOver: false,
Â  Â  Â  Â  Â  Â  Â  Â  gameWon: false,
Â  Â  Â  Â  Â  Â  Â  Â  gameOverReason: null,
Â  Â  Â  Â  Â  Â  Â  Â  turn: 0,
Â  Â  Â  Â  Â  Â  Â  Â  startTime: null,
Â  Â  Â  Â  Â  Â  Â  Â  initialTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  elapsedTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  completionTime: null,
Â  Â  Â  Â  Â  Â  Â  Â  isTypingTime: false,
Â  Â  Â  Â  Â  Â  Â  Â  typedCompletionTime: '',
Â  Â  Â  Â  Â  Â  Â  Â  typedTimeLeft: '',
Â  Â  Â  Â  Â  Â  Â  Â  currentLevel: 1,
Â  Â  Â  Â  Â  Â  Â  Â  boss: null,
Â  Â  Â  Â  Â  Â  Â  Â  bossDefeated: false,
Â  Â  Â  Â  Â  Â  Â  Â  showingLevelTransition: false,
Â  Â  Â  Â  Â  Â  Â  Â  levelTransitionMessage: '',
Â  Â  Â  Â  Â  Â  Â  Â  cinematicActive: false,
Â  Â  Â  Â  Â  Â  Â  Â  bossCinematicText: '',
Â  Â  Â  Â  Â  Â  Â  Â  bossCinematicAlpha: 0,
Â  Â  Â  Â  Â  Â  Â  Â  explosionActive: false,
Â  Â  Â  Â  Â  Â  Â  Â  explosion: null,
Â  Â  Â  Â  Â  Â  Â  Â  warning60sTriggered: false,
Â  Â  Â  Â  Â  Â  Â  Â  warning30sTriggered: false,
Â  Â  Â  Â  Â  Â  Â  Â  warning10sTriggered: false,
Â  Â  Â  Â  Â  Â  Â  Â  countdownActive: false,
Â  Â  Â  Â  Â  Â  Â  Â  glitchActive: false,
Â  Â  Â  Â  Â  Â  Â  Â  glitchStartTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  glitchDuration: 1500,
Â  Â  Â  Â  Â  Â  Â  Â  glitchSoundInterval: null,
Â  Â  Â  Â  Â  Â  Â  Â  glitchingTimer: false,
Â  Â  Â  Â  Â  Â  Â  Â  bossIntroCountdownActive: false,
Â  Â  Â  Â  Â  Â  Â  Â  bossIntroCountdownValue: 3,
Â  Â  Â  Â  Â  Â  Â  Â  bossIntroCountdownStartTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  bossIntroCountdownMessage: '',
Â  Â  Â  Â  Â  Â  Â  Â  dragonMasterIntroCinematicActive: false,
Â  Â  Â  Â  Â  Â  Â  Â  dragonMasterIntroCinematicText: '',
Â  Â  Â  Â  Â  Â  Â  Â  dragonMasterIntroCinematicAlpha: 0,
Â  Â  Â  Â  Â  Â  Â  Â  dragonMasterIntroCinematicStartTime: 0,
Â  Â  Â  Â  Â  Â  Â  Â  confettiActive: false
Â  Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  Â  stopBackgroundMusic();
Â  Â  Â  Â  Â  Â  setupLevel(gameState.currentLevel);
Â  Â  Â  Â  Â  Â  console.log("Game initialized, starting game loop");
Â  Â  Â  Â  Â  Â  gameLoop();
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  console.error("Error initializing game:", e);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function setupLevel(level) {
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  console.log("Setting up level", level);
Â  Â  Â  Â  Â  Â  gameState.player.x = 0;
Â  Â  Â  Â  Â  Â  gameState.player.y = 0;
Â  Â  Â  Â  Â  Â  gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 20);
Â  Â  Â  Â  Â  Â  gameState.player.bombs = level === 3 ? 10 : gameState.player.bombs + 2;
Â  Â  Â  Â  Â  Â  gameState.player.attackDamage = 15;
Â  Â  Â  Â  Â  Â  gameState.hasKey = false;
Â  Â  Â  Â  Â  Â  gameState.enemies = [];
Â  Â  Â  Â  Â  Â  gameState.potions = [];
Â  Â  Â  Â  Â  Â  gameState.boss = null;
Â  Â  Â  Â  Â  Â  gameState.bossDefeated = false;
Â  Â  Â  Â  Â  Â  gameState.warning60sTriggered = false;
Â  Â  Â  Â  Â  Â  gameState.warning30sTriggered = false;
Â  Â  Â  Â  Â  Â  gameState.warning10sTriggered = false;
Â  Â  Â  Â  Â  Â  gameState.countdownActive = false;
Â  Â  Â  Â  Â  Â  gameState.glitchActive = false;
Â  Â  Â  Â  Â  Â  gameState.bossIntroCountdownActive = false;
Â  Â  Â  Â  Â  Â  gameState.dragonMasterIntroCinematicActive = false;
Â  Â  Â  Â  Â  Â  gameState.glitchingTimer = false;
Â  Â  Â  Â  Â  Â  gameState.explosionActive = false;
Â  Â  Â  Â  Â  Â  gameState.explosion = null;
Â  Â  Â  Â  Â  Â  gameState.confettiActive = false;

Â  Â  Â  Â  Â  Â  switch(level) {
Â  Â  Â  Â  Â  Â  Â  Â  case 1: gameState.initialTime = 90 * 1000; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 2: gameState.initialTime = 120 * 1000; break;
Â  Â  Â  Â  Â  Â  Â  Â  case 3: gameState.initialTime = Infinity; gameState.glitchingTimer = true; break;
Â  Â  Â  Â  Â  Â  Â  Â  default: gameState.initialTime = 60 * 1000;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  let isMapValid = false;
Â  Â  Â  Â  Â  Â  let attempts = 0;
Â  Â  Â  Â  Â  Â  while (!isMapValid && attempts < 100) {
Â  Â  Â  Â  Â  Â  Â  Â  if (level === 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.map = generateBossMap();
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.map = generateMap();
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (placeEntitiesForLevel(level)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (checkConnectivity()) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isMapValid = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("Map not connected. Regenerating...");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.error("Failed to place entities for level:", level);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  attempts++;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (!isMapValid) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error("Failed to generate valid map after 100 attempts");
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (level !== 3) {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.startTime = performance.now();
Â  Â  Â  Â  Â  Â  Â  Â  playBackgroundMusic();
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.startTime = null;
Â  Â  Â  Â  Â  Â  Â  Â  stopBackgroundMusic();
Â  Â  Â  Â  Â  Â  Â  Â  playBossMusic();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateUI();
Â  Â  Â  Â  Â  Â  console.log("Level", level, "setup complete");
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  console.error("Error setting up level:", e);
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function checkConnectivity() {
Â  Â  Â  Â  const start = {x: gameState.player.x, y: gameState.player.y};
Â  Â  Â  Â  const key = {x: gameState.key.x, y: gameState.key.y};
Â  Â  Â  Â  const exit = {x: gameState.exit.x, y: gameState.exit.y};
Â  Â  Â  Â  return canReach(start, key) && canReach(start, exit);
Â  Â  }

Â  Â  function canReach(start, target) {
Â  Â  Â  Â  const queue = [start];
Â  Â  Â  Â  const visited = new Set();
Â  Â  Â  Â  const key = (x, y) => `${x},${y}`;
Â  Â  Â  Â  visited.add(key(start.x, start.y));

Â  Â  Â  Â  while (queue.length > 0) {
Â  Â  Â  Â  Â  Â  const {x, y} = queue.shift();
Â  Â  Â  Â  Â  Â  if (x === target.x && y === target.y) return true;
Â  Â  Â  Â  Â  Â  const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
Â  Â  Â  Â  Â  Â  for (const [dx, dy] of directions) {
Â  Â  Â  Â  Â  Â  Â  Â  const newX = x + dx;
Â  Â  Â  Â  Â  Â  Â  Â  const newY = y + dy;
Â  Â  Â  Â  Â  Â  Â  Â  if (
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newX >= 0 && newX < MAP_WIDTH_TILES &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newY >= 0 && newY < MAP_HEIGHT_TILES &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.map[newY][newX] === Floor &&
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  !visited.has(key(newX, newY))
Â  Â  Â  Â  Â  Â  Â  Â  ) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  visited.add(key(newX, newY));
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  queue.push({x: newX, y: newY});
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return false;
Â  Â  }

Â  Â  function generateMap() {
Â  Â  Â  Â  let map = Array.from({ length: MAP_HEIGHT_TILES }, () =>
Â  Â  Â  Â  Â  Â  Array.from({ length: MAP_WIDTH_TILES }, () => Math.random() < 0.45 ? Wall : Floor)
Â  Â  Â  Â  );
Â  Â  Â  Â  for (let i = 0; i < 4; i++) {
Â  Â  Â  Â  Â  Â  let newMap = JSON.parse(JSON.stringify(map));
Â  Â  Â  Â  Â  Â  for (let y = 1; y < MAP_HEIGHT_TILES - 1; y++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let x = 1; x < MAP_WIDTH_TILES - 1; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let wallCount = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let ny = y - 1; ny <= y + 1; ny++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let nx = x - 1; nx <= x + 1; nx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (ny >= 0 && ny < MAP_HEIGHT_TILES && nx >= 0 && nx < MAP_WIDTH_TILES && map[ny][nx] === Wall) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wallCount++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newMap[y][x] = wallCount > 4 ? Wall : Floor;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  map = newMap;
Â  Â  Â  Â  }
Â  Â  Â  Â  for(let y = 0; y < MAP_HEIGHT_TILES; y++) { map[y][0] = map[y][MAP_WIDTH_TILES-1] = Wall; }
Â  Â  Â  Â  for(let x = 0; x < MAP_WIDTH_TILES; x++) { map[0][x] = map[MAP_HEIGHT_TILES-1][x] = Wall; }
Â  Â  Â  Â  return map;
Â  Â  }

Â  Â  function generateBossMap() {
Â  Â  Â  Â  let map = Array.from({ length: MAP_HEIGHT_TILES }, () => Array.from({ length: MAP_WIDTH_TILES }, () => Floor));
Â  Â  Â  Â  for(let y = 0; y < MAP_HEIGHT_TILES; y++) { map[y][0] = map[y][MAP_WIDTH_TILES-1] = Wall; }
Â  Â  Â  Â  for(let x = 0; x < MAP_WIDTH_TILES; x++) { map[0][x] = map[MAP_HEIGHT_TILES-1][x] = Wall; }
Â  Â  Â  Â  return map;
Â  Â  }

Â  Â  function placeEntitiesForLevel(level) {
Â  Â  Â  Â  const floorTiles = [];
Â  Â  Â  Â  for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
Â  Â  Â  Â  Â  Â  for (let x = 0; x < MAP_WIDTH_TILES; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.map[y][x] === Floor) { floorTiles.push({ x, y }); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  const getRandomTile = () => {
Â  Â  Â  Â  Â  Â  if (floorTiles.length === 0) return null;
Â  Â  Â  Â  Â  Â  const index = Math.floor(Math.random() * floorTiles.length);
Â  Â  Â  Â  Â  Â  return floorTiles.splice(index, 1)[0];
Â  Â  Â  Â  };

Â  Â  Â  Â  const playerPos = getRandomTile();
Â  Â  Â  Â  if (!playerPos) return false;
Â  Â  Â  Â  Object.assign(gameState.player, playerPos);

Â  Â  Â  Â  if (level < 3) {
Â  Â  Â  Â  Â  Â  const keyPos = getRandomTile();
Â  Â  Â  Â  Â  Â  const exitPos = getRandomTile();
Â  Â  Â  Â  Â  Â  if (!keyPos || !exitPos) return false;
Â  Â  Â  Â  Â  Â  Object.assign(gameState.key, keyPos);
Â  Â  Â  Â  Â  Â  Object.assign(gameState.exit, exitPos);

Â  Â  Â  Â  Â  Â  const NUM_ENEMIES = level === 1 ? 5 : 8;
Â  Â  Â  Â  Â  Â  for (let i = 0; i < NUM_ENEMIES; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (floorTiles.length > 0) { const enemyPos = getRandomTile(); gameState.enemies.push({ x: enemyPos.x, y: enemyPos.y, frozenTurns: 0 }); }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const NUM_POTIONS = 3;
Â  Â  Â  Â  Â  Â  for (let i = 0; i < NUM_POTIONS; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  if(floorTiles.length > 0) gameState.potions.push(getRandomTile());
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  const bossSize = 3;
Â  Â  Â  Â  Â  Â  let bossCenter = getRandomTile();
Â  Â  Â  Â  Â  Â  while (!bossCenter || (Math.abs(bossCenter.x - gameState.player.x) < 5 && Math.abs(bossCenter.y - gameState.player.y) < 5)) {
Â  Â  Â  Â  Â  Â  Â  Â  bossCenter = getRandomTile();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (!bossCenter) return false;

Â  Â  Â  Â  Â  Â  let bossX = bossCenter.x - Math.floor(bossSize / 2);
Â  Â  Â  Â  Â  Â  let bossY = bossCenter.y - Math.floor(bossSize / 2);
Â  Â  Â  Â  Â  Â  for (let by = 0; by < bossSize; by++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let bx = 0; bx < bossSize; bx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const index = floorTiles.findIndex(t => t.x === bossX + bx && t.y === bossY + by);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (index !== -1) floorTiles.splice(index, 1);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.map[bossY + by][bossX + bx] = GIANT_DRAGON_BOSS;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  gameState.boss = { x: bossX, y: bossY, hp: 500, maxHp: 500, damage: 30, frozenTurns: 0, size: bossSize };
Â  Â  Â  Â  Â  Â  const exitPos = getRandomTile();
Â  Â  Â  Â  Â  Â  if (!exitPos) return false;
Â  Â  Â  Â  Â  Â  Object.assign(gameState.exit, exitPos);
Â  Â  Â  Â  Â  Â  gameState.hasKey = false;
Â  Â  Â  Â  Â  Â  gameState.key.x = bossCenter.x;
Â  Â  Â  Â  Â  Â  gameState.key.y = bossCenter.y;
Â  Â  Â  Â  }
Â  Â  Â  Â  return true;
Â  Â  }

Â  Â  function gameLoop(currentTime) {
Â  Â  Â  Â  const isGameActive = !gameState.showingLevelTransition && !gameState.cinematicActive && !gameState.glitchActive && !gameState.dragonMasterIntroCinematicActive && !gameState.bossIntroCountdownActive && !gameState.gameWon && !gameState.gameOver;

Â  Â  Â  Â  if (isGameActive) {
Â  Â  Â  Â  Â  Â  if (!gameState.glitchingTimer) {
Â  Â  Â  Â  Â  Â  Â  Â  if (!gameState.startTime) { gameState.startTime = currentTime; }
Â  Â  Â  Â  Â  Â  Â  Â  gameState.elapsedTime = currentTime - gameState.startTime;
Â  Â  Â  Â  Â  Â  Â  Â  gameState.remainingTime = gameState.initialTime - gameState.elapsedTime;
Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.remainingTime <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.remainingTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (!gameState.gameOver && !gameState.gameWon) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.gameOver = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.gameOverReason = 'time';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stopBackgroundMusic();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  const remainingSeconds = Math.floor(gameState.remainingTime / 1000);
Â  Â  Â  Â  Â  Â  Â  Â  if (remainingSeconds === 60 && !gameState.warning60sTriggered) { statusText.textContent = '1 minute remaining!'; statusText.style.color = 'orange'; gameState.warning60sTriggered = true; }
Â  Â  Â  Â  Â  Â  Â  Â  else if (remainingSeconds === 30 && !gameState.warning30sTriggered) { statusText.textContent = '30 seconds remaining!'; statusText.style.color = 'red'; gameState.warning30sTriggered = true; }
Â  Â  Â  Â  Â  Â  Â  Â  else if (remainingSeconds === 10 && !gameState.warning10sTriggered) { statusText.textContent = '10 seconds remaining!'; statusText.style.color = 'darkred'; gameState.warning10sTriggered = true; }
Â  Â  Â  Â  Â  Â  Â  Â  else if (remainingSeconds <= 5 && remainingSeconds > 0) { gameState.countdownActive = true; }
Â  Â  Â  Â  Â  Â  Â  Â  else if (remainingSeconds === 0 && gameState.countdownActive) { gameState.countdownActive = false; }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  draw(currentTime);
Â  Â  Â  Â  updateUI();
Â  Â  Â  Â  if (gameState.confettiActive) updateConfetti();
Â  Â  Â  Â  if (gameState.explosionActive && gameState.explosion) gameState.explosion.update(currentTime);

Â  Â  Â  Â  animationFrameId = requestAnimationFrame(gameLoop);
Â  Â  }

Â  Â  function moveGameEntities() {
Â  Â  Â  Â  if (gameState.currentLevel === 3 && gameState.boss && !gameState.bossDefeated) {
Â  Â  Â  Â  Â  Â  moveBoss(gameState.boss);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  moveEnemies();
Â  Â  Â  Â  }
Â  Â  }

Â  Â  function moveEnemies() {
Â  Â  Â  Â  gameState.enemies.forEach(enemy => {
Â  Â  Â  Â  Â  Â  if (enemy.frozenTurns > 0) { enemy.frozenTurns--; return; }
Â  Â  Â  Â  Â  Â  const huntPlayer = Math.random() > 0.5;
Â  Â  Â  Â  Â  Â  let dx = huntPlayer ? Math.sign(gameState.player.x - enemy.x) : Math.floor(Math.random() * 3) - 1;
Â  Â  Â  Â  Â  Â  let dy = huntPlayer ? Math.sign(gameState.player.y - enemy.y) : Math.floor(Math.random() * 3) - 1;
Â  Â  Â  Â  Â  Â  const nextX = enemy.x + dx;
Â  Â  Â  Â  Â  Â  const nextY = enemy.y + dy;
Â  Â  Â  Â  Â  Â  if (isWalkable(nextX, nextY)) {
Â  Â  Â  Â  Â  Â  Â  Â  enemy.x = nextX;
Â  Â  Â  Â  Â  Â  Â  Â  enemy.y = nextY;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
Â  Â  Â  Â  Â  Â  Â  Â  takeDamage(15);
Â  Â  Â  Â  Â  Â  Â  Â  enemy.frozenTurns = 2;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  }

Â  Â  function moveBoss(boss) {
Â  Â  Â  Â  if (boss.frozenTurns > 0) { boss.frozenTurns--; return; }
Â  Â  Â  Â  let dx = Math.sign(gameState.player.x - (boss.x + Math.floor(boss.size / 2)));
Â  Â  Â  Â  let dy = Math.sign(gameState.player.y - (boss.y + Math.floor(boss.size / 2)));
Â  Â  Â  Â  const originalBossX = boss.x;
Â  Â  Â  Â  const originalBossY = boss.y;
Â  Â  Â  Â  const potentialBossX = boss.x + dx;
Â  Â  Â  Â  const potentialBossY = boss.y + dy;
Â  Â  Â  Â  let canMove = false;
Â  Â  Â  Â  if (isBossPositionWalkable(potentialBossX, potentialBossY, boss.size)) {
Â  Â  Â  Â  Â  Â  canMove = true;
Â  Â  Â  Â  Â  Â  boss.x = potentialBossX;
Â  Â  Â  Â  Â  Â  boss.y = potentialBossY;
Â  Â  Â  Â  } else if (isBossPositionWalkable(potentialBossX, originalBossY, boss.size)) {
Â  Â  Â  Â  Â  Â  canMove = true;
Â  Â  Â  Â  Â  Â  boss.x = potentialBossX;
Â  Â  Â  Â  } else if (isBossPositionWalkable(originalBossX, potentialBossY, boss.size)) {
Â  Â  Â  Â  Â  Â  canMove = true;
Â  Â  Â  Â  Â  Â  boss.y = potentialBossY;
Â  Â  Â  Â  }
Â  Â  Â  Â  if (canMove) {
Â  Â  Â  Â  Â  Â  for (let by = 0; by < boss.size; by++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let bx = 0; bx < boss.size; bx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.map[originalBossY + by][originalBossX + bx] = Floor;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.map[boss.y + by][boss.x + bx] = GIANT_DRAGON_BOSS;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  const playerInBossRange = gameState.player.x >= boss.x && gameState.player.x < boss.x + boss.size && gameState.player.y >= boss.y && gameState.player.y < boss.y + boss.size;
Â  Â  Â  Â  if (playerInBossRange) {
Â  Â  Â  Â  Â  Â  takeDamage(boss.damage);
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function isBossPositionWalkable(x, y, size) {
Â  Â  Â  Â  if (x < 1 || y < 1 || x + size > MAP_WIDTH_TILES - 1 || y + size > MAP_HEIGHT_TILES - 1) return false;
Â  Â  Â  Â  for (let by = 0; by < size; by++) {
Â  Â  Â  Â  Â  Â  for (let bx = 0; bx < size; bx++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.map[y + by][x + bx] === Wall || (y + by === gameState.player.y && x + bx === gameState.player.x)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return true;
Â  Â  }
Â  Â  function takeDamage(damage) {
Â  Â  Â  Â  if (gameState.gameWon || gameState.gameOver) return;
Â  Â  Â  Â  gameState.player.hp -= damage;
Â  Â  Â  Â  if (gameState.player.hp <= 0) {
Â  Â  Â  Â  Â  Â  gameState.player.hp = 0;
Â  Â  Â  Â  Â  Â  gameState.gameOver = true;
Â  Â  Â  Â  Â  Â  gameState.gameOverReason = 'killed';
Â  Â  Â  Â  Â  Â  stopBackgroundMusic();
Â  Â  Â  Â  }
Â  Â  Â  Â  updateUI();
Â  Â  }
Â  Â  function isWalkable(x, y) {
Â  Â  Â  Â  if (x < 0 || x >= MAP_WIDTH_TILES || y < 0 || y >= MAP_HEIGHT_TILES) return false;
Â  Â  Â  Â  if (gameState.map[y][x] === Wall) return false;
Â  Â  Â  Â  if (gameState.currentLevel < 3) {
Â  Â  Â  Â  Â  Â  const isEnemy = gameState.enemies.some(e => e.x === x && e.y === y);
Â  Â  Â  Â  Â  Â  if (isEnemy) return false;
Â  Â  Â  Â  } else if (gameState.currentLevel === 3 && gameState.boss && !gameState.bossDefeated) {
Â  Â  Â  Â  Â  Â  if (x >= gameState.boss.x && x < gameState.boss.x + gameState.boss.size && y >= gameState.boss.y && y < gameState.boss.y + gameState.boss.size) {
Â  Â  Â  Â  Â  Â  Â  Â  return false;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return true;
Â  Â  }
Â  Â  function handleMovement(dx, dy) {
Â  Â  Â  Â  if (gameState.gameOver || gameState.gameWon || gameState.showingLevelTransition || gameState.cinematicActive || gameState.dragonMasterIntroCinematicActive || gameState.bossIntroCountdownActive) return;
Â  Â  Â  Â  const newX = gameState.player.x + dx;
Â  Â  Â  Â  const newY = gameState.player.y + dy;
Â  Â  Â  Â  if (isWalkable(newX, newY)) {
Â  Â  Â  Â  Â  Â  gameState.player.x = newX;
Â  Â  Â  Â  Â  Â  gameState.player.y = newY;
Â  Â  Â  Â  Â  Â  if (gameState.currentLevel < 3) {
Â  Â  Â  Â  Â  Â  Â  Â  checkCollisions();
Â  Â  Â  Â  Â  Â  Â  Â  moveEnemies();
Â  Â  Â  Â  Â  Â  } else if (gameState.currentLevel === 3) {
Â  Â  Â  Â  Â  Â  Â  Â  checkCollisions();
Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.boss && !gameState.bossDefeated) moveBoss(gameState.boss);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  gameState.turn++;
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function checkCollisions() {
Â  Â  Â  Â  const { x, y } = gameState.player;
Â  Â  Â  Â  if (gameState.currentLevel < 3) {
Â  Â  Â  Â  Â  Â  if (x === gameState.key.x && y === gameState.key.y) {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.hasKey = true;
Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = 'You have the key! Find the door! ğŸšª';
Â  Â  Â  Â  Â  Â  Â  Â  statusText.style.color = '#fff';
Â  Â  Â  Â  Â  Â  Â  Â  gameState.key.x = -1;
Â  Â  Â  Â  Â  Â  Â  Â  gameState.key.y = -1;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (x === gameState.exit.x && y === gameState.exit.y && gameState.hasKey) {
Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.currentLevel < 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stopBackgroundMusic();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.showingLevelTransition = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.levelTransitionMessage = `Level ${gameState.currentLevel} Complete!`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.showingLevelTransition = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.currentLevel++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.currentLevel === 3) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  runBossIntroCinematic();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setupLevel(gameState.currentLevel);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 2000);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  const potionIndex = gameState.potions.findIndex(p => p.x === x && p.y === y);
Â  Â  Â  Â  Â  Â  if (potionIndex !== -1) {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 25);
Â  Â  Â  Â  Â  Â  Â  Â  gameState.potions.splice(potionIndex, 1);
Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = 'You found a potion! HP restored!';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else if (gameState.currentLevel === 3) {
Â  Â  Â  Â  Â  Â  if (x === gameState.key.x && y === gameState.key.y && gameState.bossDefeated) {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.hasKey = true;
Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = 'You have the key! Find the door! ğŸšª';
Â  Â  Â  Â  Â  Â  Â  Â  statusText.style.color = '#fff';
Â  Â  Â  Â  Â  Â  Â  Â  gameState.key.x = -1;
Â  Â  Â  Â  Â  Â  Â  Â  gameState.key.y = -1;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if (x === gameState.exit.x && y === gameState.exit.y && gameState.hasKey) {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.gameWon = true;
Â  Â  Â  Â  Â  Â  Â  Â  gameState.completionTime = gameState.elapsedTime;
Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = 'You escaped the dungeon!';
Â  Â  Â  Â  Â  Â  Â  Â  statusText.style.color = 'gold';
Â  Â  Â  Â  Â  Â  Â  Â  gameState.player.x = x;
Â  Â  Â  Â  Â  Â  Â  Â  gameState.player.y = y;
Â  Â  Â  Â  Â  Â  Â  Â  gameState.confettiActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  startConfetti();
Â  Â  Â  Â  Â  Â  Â  Â  stopBackgroundMusic();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function dropBomb() {
Â  Â  Â  Â  if (gameState.gameOver || gameState.gameWon || gameState.showingLevelTransition || gameState.cinematicActive || gameState.dragonMasterIntroCinematicActive || gameState.bossIntroCountdownActive) return;
Â  Â  Â  Â  if (gameState.player.bombs > 0) {
Â  Â  Â  Â  Â  Â  gameState.player.bombs--;
Â  Â  Â  Â  Â  Â  const { x, y } = gameState.player;
Â  Â  Â  Â  Â  Â  const enemiesToFreeze = gameState.enemies.filter(e => Math.abs(e.x - x) <= 2 && Math.abs(e.y - y) <= 2);
Â  Â  Â  Â  Â  Â  enemiesToFreeze.forEach(enemy => enemy.frozenTurns = 5);
Â  Â  Â  Â  Â  Â  if (gameState.currentLevel === 3 && gameState.boss && !gameState.bossDefeated) {
Â  Â  Â  Â  Â  Â  Â  Â  const boss = gameState.boss;
Â  Â  Â  Â  Â  Â  Â  Â  if (x >= boss.x - 2 && x <= boss.x + boss.size + 1 && y >= boss.y - 2 && y <= boss.y + boss.size + 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  boss.hp -= 50;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  statusText.textContent = `BOMBS AWAY! Boss HP: ${boss.hp}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  boss.frozenTurns = 3;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (boss.hp <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossDefeated = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.boss = null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.map[gameState.key.y][gameState.key.x] = Key;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  stopBossMusic();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playExplosionSound();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.explosionActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.explosion = new Explosion(x * TILE_SIZE + TILE_SIZE/2, y * TILE_SIZE + TILE_SIZE/2);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let by = boss.y; by < boss.y + boss.size; by++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let bx = boss.x; bx < boss.x + boss.size; bx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.map[by][bx] === GIANT_DRAGON_BOSS) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.map[by][bx] = Floor;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  updateUI();
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  statusText.textContent = 'No bombs left!';
Â  Â  Â  Â  }
Â  Â  Â  Â  moveGameEntities();
Â  Â  Â  Â  gameState.turn++;
Â  Â  }
Â  Â  function runBossIntroCinematic() {
Â  Â  Â  Â  gameState.dragonMasterIntroCinematicActive = true;
Â  Â  Â  Â  gameState.dragonMasterIntroCinematicText = 'A powerful presence fills the room...';
Â  Â  Â  Â  gameState.dragonMasterIntroCinematicAlpha = 0;
Â  Â  Â  Â  gameState.dragonMasterIntroCinematicStartTime = performance.now();
Â  Â  Â  Â  backgroundMusic.volume = 0.1;
Â  Â  Â  Â  playBossMusic();
Â  Â  Â  Â  const cinematicInterval = setInterval(() => {
Â  Â  Â  Â  Â  Â  gameState.dragonMasterIntroCinematicAlpha += 0.02;
Â  Â  Â  Â  Â  Â  if (gameState.dragonMasterIntroCinematicAlpha >= 1) {
Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(cinematicInterval);
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.dragonMasterIntroCinematicText = "YOU DARE CHALLENGE THE DRAGON MASTER'S SANCTUM!?";
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.dragonMasterIntroCinematicAlpha = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const secondCinematicInterval = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.dragonMasterIntroCinematicAlpha += 0.02;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.dragonMasterIntroCinematicAlpha >= 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(secondCinematicInterval);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.dragonMasterIntroCinematicActive = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossIntroCountdownActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossIntroCountdownStartTime = performance.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossIntroCountdownMessage = '3';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playBossCountdown();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 2000);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 50);
Â  Â  Â  Â  Â  Â  Â  Â  }, 2000);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, 50);
Â  Â  }
Â  Â  function playBossCountdown() {
Â  Â  Â  Â  const countdownStartTime = performance.now();
Â  Â  Â  Â  const countdownInterval = setInterval(() => {
Â  Â  Â  Â  Â  Â  const elapsed = performance.now() - countdownStartTime;
Â  Â  Â  Â  Â  Â  const remaining = 3 - Math.floor(elapsed / 1000);
Â  Â  Â  Â  Â  Â  if (remaining > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossIntroCountdownMessage = remaining.toString();
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(countdownInterval);
Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossIntroCountdownActive = false;
Â  Â  Â  Â  Â  Â  Â  Â  gameState.cinematicActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  runFinalCinematic();
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, 100);
Â  Â  }
Â  Â  function runFinalCinematic() {
Â  Â  Â  Â  gameState.bossCinematicText = 'The Dragon Master is here!';
Â  Â  Â  Â  gameState.bossCinematicAlpha = 0;
Â  Â  Â  Â  const fadeInInterval = setInterval(() => {
Â  Â  Â  Â  Â  Â  gameState.bossCinematicAlpha += 0.01;
Â  Â  Â  Â  Â  Â  if (gameState.bossCinematicAlpha >= 1) {
Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(fadeInInterval);
Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossCinematicText = 'BATTLE!!!';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossCinematicAlpha = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const finalFadeIn = setInterval(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.bossCinematicAlpha += 0.01;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.bossCinematicAlpha >= 1) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  clearInterval(finalFadeIn);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.cinematicActive = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.startTime = performance.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  playBossMusic();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  console.log("Cinematic finished, game is now active.");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 1500);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, 50);
Â  Â  Â  Â  Â  Â  Â  Â  }, 2000);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, 50);
Â  Â  }
Â  Â  function updateUI() {
Â  Â  Â  Â  hpText.textContent = `HP: ${gameState.player.hp}`;
Â  Â  Â  Â  bombText.textContent = `Bombs: ${gameState.player.bombs} ğŸ’£`;
Â  Â  Â  Â  if (gameState.gameWon) {
Â  Â  Â  Â  Â  Â  const seconds = Math.floor(gameState.completionTime / 1000);
Â  Â  Â  Â  Â  Â  const milliseconds = Math.floor((gameState.completionTime % 1000) / 10);
Â  Â  Â  Â  Â  Â  timerText.textContent = `Time: ${seconds}:${milliseconds.toString().padStart(2, '0')}`;
Â  Â  Â  Â  } else if (gameState.glitchingTimer) {
Â  Â  Â  Â  Â  Â  if (!gameState.glitchActive) {
Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.turn % 10 === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.glitchActive = true;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.glitchStartTime = performance.now();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  glitchAudio.play();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.glitchSoundInterval = setTimeout(() => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  glitchAudio.pause();
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  glitchAudio.currentTime = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  gameState.glitchActive = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }, gameState.glitchDuration);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  timerText.textContent = `Time: âˆ`;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  const seconds = Math.floor(gameState.remainingTime / 1000);
Â  Â  Â  Â  Â  Â  const milliseconds = Math.floor((gameState.remainingTime % 1000) / 10);
Â  Â  Â  Â  Â  Â  timerText.textContent = `Time: ${seconds}:${milliseconds.toString().padStart(2, '0')}`;
Â  Â  Â  Â  Â  Â  if (seconds <= 10) {
Â  Â  Â  Â  Â  Â  Â  Â  timerText.style.color = 'red';
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  timerText.style.color = 'white';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function draw(currentTime) {
Â  Â  Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
Â  Â  Â  Â  Â  Â  for (let x = 0; x < MAP_WIDTH_TILES; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  let tile = gameState.map[y][x];
Â  Â  Â  Â  Â  Â  Â  Â  if (tile === GIANT_DRAGON_BOSS && gameState.bossDefeated) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillStyle = '#111';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  drawTile(x, y, tile);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  if (!gameState.hasKey && gameState.currentLevel < 3) drawTile(gameState.key.x, gameState.key.y, Key);
Â  Â  Â  Â  gameState.potions.forEach(p => drawTile(p.x, p.y, Potion));
Â  Â  Â  Â  if (gameState.currentLevel < 3 || gameState.hasKey) drawTile(gameState.exit.x, gameState.exit.y, Exit);
Â  Â  Â  Â  if (gameState.currentLevel < 3) {
Â  Â  Â  Â  Â  Â  gameState.enemies.forEach(enemy => {
Â  Â  Â  Â  Â  Â  Â  Â  drawTile(enemy.x, enemy.y, enemy.frozenTurns > 0 ? FrozenEnemy : Enemy);
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  } else if (gameState.currentLevel === 3 && gameState.boss && !gameState.bossDefeated) {
Â  Â  Â  Â  Â  Â  drawBoss(gameState.boss, currentTime);
Â  Â  Â  Â  } else if (gameState.currentLevel === 3 && gameState.bossDefeated) {
Â  Â  Â  Â  Â  Â  drawTile(gameState.key.x, gameState.key.y, Key);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameState.explosionActive && gameState.explosion) {
Â  Â  Â  Â  Â  Â  gameState.explosion.draw(ctx);
Â  Â  Â  Â  Â  Â  if (gameState.explosion.alpha <= 0) {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.explosionActive = false;
Â  Â  Â  Â  Â  Â  Â  Â  gameState.explosion = null;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameState.gameWon) {
Â  Â  Â  Â  Â  Â  drawTile(gameState.player.x, gameState.player.y, PlayerWin);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  drawTile(gameState.player.x, gameState.player.y, Player);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameState.showingLevelTransition) {
Â  Â  Â  Â  Â  Â  drawCenterText(gameState.levelTransitionMessage, '80px Arial', 'white');
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameState.cinematicActive) {
Â  Â  Â  Â  Â  Â  drawCenterText(gameState.bossCinematicText, '50px Arial', `rgba(255, 0, 0, ${gameState.bossCinematicAlpha})`);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameState.dragonMasterIntroCinematicActive) {
Â  Â  Â  Â  Â  Â  drawCenterText(gameState.dragonMasterIntroCinematicText, '40px Arial', `rgba(255, 255, 255, ${gameState.dragonMasterIntroCinematicAlpha})`);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameState.bossIntroCountdownActive) {
Â  Â  Â  Â  Â  Â  drawCenterText(gameState.bossIntroCountdownMessage, '150px Arial', 'red');
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameState.glitchActive) {
Â  Â  Â  Â  Â  Â  const elapsed = currentTime - gameState.glitchStartTime;
Â  Â  Â  Â  Â  Â  if (elapsed < gameState.glitchDuration) {
Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = Math.random();
Â  Â  Â  Â  Â  Â  Â  Â  ctx.drawImage(canvas, 0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  Â  Â  Â  Â  ctx.globalAlpha = 1.0;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  if (gameState.gameOver) {
Â  Â  Â  Â  Â  Â  let message;
Â  Â  Â  Â  Â  Â  if (gameState.gameOverReason === 'time') {
Â  Â  Â  Â  Â  Â  Â  Â  message = 'Time Ran Out!';
Â  Â  Â  Â  Â  Â  } else if (gameState.gameOverReason === 'killed') {
Â  Â  Â  Â  Â  Â  Â  Â  message = 'You Died!';
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  message = 'Game Over';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  drawCenterText(message, '100px Arial', 'red');
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function drawTile(x, y, tile) {
Â  Â  Â  Â  ctx.font = `${TILE_SIZE - 4}px Arial`;
Â  Â  Â  Â  ctx.textAlign = 'center';
Â  Â  Â  Â  ctx.textBaseline = 'middle';
Â  Â  Â  Â  ctx.fillText(tile, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
Â  Â  }
Â  Â  function drawBoss(boss, currentTime) {
Â  Â  Â  Â  if (!boss) return;
Â  Â  Â  Â  const bossChar = boss.frozenTurns > 0 ? FrozenEnemy : GIANT_DRAGON_BOSS;
Â  Â  Â  Â  const size = boss.size;
Â  Â  Â  Â  ctx.font = `${TILE_SIZE * size / 1.5}px Arial`;
Â  Â  Â  Â  ctx.textAlign = 'center';
Â  Â  Â  Â  ctx.textBaseline = 'middle';
Â  Â  Â  Â  let wiggleX = 0;
Â  Â  Â  Â  let wiggleY = 0;
Â  Â  Â  Â  if (boss.frozenTurns <= 0) {
Â  Â  Â  Â  Â  Â  wiggleX = Math.sin(currentTime / 100) * 2;
Â  Â  Â  Â  Â  Â  wiggleY = Math.cos(currentTime / 100) * 2;
Â  Â  Â  Â  }
Â  Â  Â  Â  ctx.fillText(bossChar, boss.x * TILE_SIZE + (size * TILE_SIZE) / 2 + wiggleX, boss.y * TILE_SIZE + (size * TILE_SIZE) / 2 + wiggleY);
Â  Â  Â  Â  const healthBarWidth = (boss.hp / boss.maxHp) * (size * TILE_SIZE - 10);
Â  Â  Â  Â  ctx.fillStyle = 'red';
Â  Â  Â  Â  ctx.fillRect(boss.x * TILE_SIZE + 5, boss.y * TILE_SIZE + size * TILE_SIZE - 15, healthBarWidth, 10);
Â  Â  }
Â  Â  function drawCenterText(text, font, color) {
Â  Â  Â  Â  ctx.fillStyle = color;
Â  Â  Â  Â  ctx.font = font;
Â  Â  Â  Â  ctx.textAlign = 'center';
Â  Â  Â  Â  ctx.textBaseline = 'middle';
Â  Â  Â  Â  ctx.fillText(text, canvas.width / 2, canvas.height / 2);
Â  Â  }
Â  Â  function showWarningModal() {
Â  Â  Â  Â  const modal = document.getElementById('warningModal');
Â  Â  Â  Â  if (modal) {
Â  Â  Â  Â  Â  Â  modal.classList.add('show');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  console.error("Warning modal not found!");
Â  Â  Â  Â  }
Â  Â  }
Â  Â  function closeModal() {
Â  Â  Â  Â  const modal = document.getElementById('warningModal');
Â  Â  Â  Â  if (modal) {
Â  Â  Â  Â  Â  Â  modal.classList.remove('show');
Â  Â  Â  Â  Â  Â  initGame();
Â  Â  Â  Â  }
Â  Â  }
Â  Â  window.addEventListener('load', () => {
Â  Â  Â  Â  showWarningModal();
Â  Â  });
Â  Â  document.addEventListener('keydown', (e) => {
Â  Â  Â  Â  if (!audioContextStarted) {
Â  Â  Â  Â  Â  Â  Tone.start();
Â  Â  Â  Â  Â  Â  audioContextStarted = true;
Â  Â  Â  Â  Â  Â  console.log("Tone.js audio context started.");
Â  Â  Â  Â  }
Â  Â  Â  Â  if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') { handleMovement(0, -1); }
Â  Â  Â  Â  else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') { handleMovement(0, 1); }
Â  Â  Â  Â  else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') { handleMovement(-1, 0); }
Â  Â  Â  Â  else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') { handleMovement(1, 0); }
Â  Â  Â  Â  else if (e.key === ' ') { dropBomb(); }
Â  Â  Â  Â  else if (e.key === 'r' || e.key === 'R') { initGame(); }
Â  Â  });
Â  Â  resetButton.addEventListener('click', () => {
Â  Â  Â  Â  initGame();
Â  Â  });
Â  Â  upButton.addEventListener('click', () => { handleMovement(0, -1); });
Â  Â  downButton.addEventListener('click', () => { handleMovement(0, 1); });
Â  Â  leftButton.addEventListener('click', () => { handleMovement(-1, 0); });
Â  Â  rightButton.addEventListener('click', () => { handleMovement(1, 0); });
Â  Â  bombButton.addEventListener('click', () => { dropBomb(); });
</script>
</body>
</html>
