<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Escape</title>
<style>
/* Provided Navbar CSS */
ul {
Â  Â  list-style-type: none;
Â  Â  margin: 0px;
Â  Â  padding: 0px;
Â  Â  overflow: hidden;
Â  Â  background-color: #fa07e2;
Â  Â  width: 800px;
Â  Â  border-radius: 8px;
Â  Â  margin-bottom: 10px;
}
li {
Â  Â  float: left; /* Make list items go side-by-side */
}
li a {
Â  Â  display: block;
Â  Â  color: white;
Â  Â  text-align: center;
Â  Â  padding: 14px 16px;
Â  Â  text-decoration: none; /* No underline for links */
}
li a:hover {
Â  Â  background-color: #60fa07;
Â  Â  color: #000000
}
/* Game & Page Styling */
body {
Â  Â  font-family: 'Courier New', Courier, monospace;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  align-items: center;
Â  Â  background-color: #2fff00;
Â  Â  color: white;
Â  Â  margin-top: 20px;
}
#game-container {
Â  Â  border: 4px solid #ff0000;
Â  Â  border-radius: 8px;
Â  Â  padding: 10px;
Â  Â  background-color: #000;
Â  Â  box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
}
canvas {
Â  Â  background-color: #111;
Â  Â  display: block;
}
#game-ui {
Â  Â  width: 800px;
Â  Â  display: flex;
Â  Â  justify-content: space-between;
Â  Â  align-items: center;
Â  Â  margin-top: 10px;
Â  Â  padding: 0 5px;
}
#status-text {
Â  Â  font-size: 1.2em;
Â  Â  font-weight: bold;
Â  Â  color: #000000
}
#hp-text {
Â  Â  font-size: 1.2em;
Â  Â  font-weight: bold;
Â  Â  color: #28a745; /* Green for health */
}
button#resetButton {
Â  Â  background-color: #ff0000;
Â  Â  color: white;
Â  Â  border: none;
Â  Â  padding: 10px 20px;
Â  Â  border-radius: 5px;
Â  Â  cursor: pointer;
Â  Â  font-family: inherit;
Â  Â  font-size: 1em;
Â  Â  font-weight: bold;
Â  Â  transition: background-color 0.3s;
}
button#resetButton:hover {
Â  Â  background-color: #32a852;
Â  Â  color: black
}

/* Mobile Controls (Arrow Buttons) Styling */
#mobile-controls {
Â  Â  margin-top: 20px;
Â  Â  display: flex;
Â  Â  flex-direction: column;
Â  Â  align-items: center;
Â  Â  gap: 5px; /* Space between rows */
}

.d-pad-row {
Â  Â  display: flex;
Â  Â  gap: 5px; /* Space between buttons in a row */
}

.arrow-button {
Â  Â  background-color: #4CAF50; /* Green */
Â  Â  color: white;
Â  Â  border: none;
Â  Â  padding: 15px 20px;
Â  Â  border-radius: 10px;
Â  Â  cursor: pointer;
Â  Â  font-size: 1.5em;
Â  Â  font-weight: bold;
Â  Â  transition: background-color 0.3s, transform 0.1s;
Â  Â  min-width: 60px; /* Ensure good touch target */
Â  Â  min-height: 60px;
Â  Â  display: flex;
Â  Â  justify-content: center;
Â  Â  align-items: center;
Â  Â  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.arrow-button:hover {
Â  Â  background-color: #45a049;
Â  Â  transform: translateY(-2px);
}

.arrow-button:active {
Â  Â  transform: translateY(0);
Â  Â  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* Modal Styles */
.modal {
Â  Â  display: none; /* Hidden by default */
Â  Â  position: fixed; /* Stay in place */
Â  Â  z-index: 1000; /* Sit on top */
Â  Â  left: 0;
Â  Â  top: 0;
Â  Â  width: 100%; /* Full width */
Â  Â  height: 100%; /* Full height */
Â  Â  overflow: auto; /* Enable scroll if needed */
Â  Â  background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
Â  Â  justify-content: center;
Â  Â  align-items: center;
}

.modal-content {
Â  Â  background-color: #fefefe;
Â  Â  margin: auto;
Â  Â  padding: 20px;
Â  Â  border: 1px solid #888;
Â  Â  width: 80%; /* Could be responsive */
Â  Â  max-width: 500px;
Â  Â  border-radius: 10px;
Â  Â  text-align: center;
Â  Â  position: relative;
Â  Â  color: black; /* Ensure text is visible */
Â  Â  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.modal-content h2 {
Â  Â  color: #ff0000;
Â  Â  margin-top: 0;
}

.modal-content button {
Â  Â  background-color: #4CAF50;
Â  Â  color: white;
Â  Â  border: none;
Â  Â  padding: 10px 20px;
Â  Â  border-radius: 5px;
Â  Â  cursor: pointer;
Â  Â  font-size: 1em;
Â  Â  margin-top: 15px;
}

.modal-content button:hover {
Â  Â  background-color: #45a049;
}

.close-button {
Â  Â  color: #aaa;
Â  Â  position: absolute;
Â  Â  top: 10px;
Â  Â  right: 15px;
Â  Â  font-size: 28px;
Â  Â  font-weight: bold;
Â  Â  cursor: pointer;
}

.close-button:hover,
.close-button:focus {
Â  Â  color: black;
Â  Â  text-decoration: none;
Â  Â  cursor: pointer;
}
</style>
</head>
<body>
<ul>
Â  Â  <li><a href="turtle.html">â¬… Back to game selection</a></li>
</ul>
<h1 style="color:black;">Controls</h1>
<p1 style="color:black;">Use arrow keys, WASD, or the on-screen buttons</p1>
<p1 style="color:black;">Press 'R' or click "New Game" to reset</p1>
<p1 style="color:black;">If you want to heal, get the heart (Potion) Max: 100 (Health in bottom-right corner)</p1> <div id="game-container">
Â  Â  <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>
<div id="game-ui">
Â  Â  <span id="status-text" style="color:black;">Find the key ğŸ”‘ and escape through the doorğŸšª!</span>
Â  Â  <button id="resetButton">New Game</button>
Â  Â  <span id="hp-text">HP: 100</span>
</div>

<div id="mobile-controls">
Â  Â  <div class="d-pad-row">
Â  Â  Â  Â  <button id="upButton" class="arrow-button">â¬†ï¸</button>
Â  Â  </div>
Â  Â  <div class="d-pad-row">
Â  Â  Â  Â  <button id="leftButton" class="arrow-button">â¬…ï¸</button>
Â  Â  Â  Â  <button id="centerButton" class="arrow-button" style="visibility: hidden;">.</button> <button id="rightButton" class="arrow-button">â¡ï¸</button>
Â  Â  </div>
Â  Â  <div class="d-pad-row">
Â  Â  Â  Â  <button id="downButton" class="arrow-button">â¬‡ï¸</button>
Â  Â  </div>
</div>

<div id="warningModal" class="modal">
Â  Â  <div class="modal-content">
Â  Â  Â  Â  <span class="close-button" onclick="closeModal()">&times;</span>
Â  Â  Â  Â  <h2>WARNING!</h2>
Â  Â  Â  Â  <p>This game is SO hard that the creator himself could only beat it ONCE!! If you beat it, tell me in the comments of ANY of my videos and I will give you a shoutout!! Good luck and have fun!!</p>
Â  Â  Â  Â  <button onclick="closeModal()">Got It!</button>
Â  Â  </div>
</div>

<script>
Â  Â  // --- Game Setup ---
Â  Â  const canvas = document.getElementById('gameCanvas');
Â  Â  const ctx = canvas.getContext('2d');
Â  Â  const resetButton = document.getElementById('resetButton');
Â  Â  const statusText = document.getElementById('status-text');
Â  Â  const hpText = document.getElementById('hp-text');

Â  Â  const TILE_SIZE = 40;
Â  Â  const MAP_WIDTH_TILES = canvas.width / TILE_SIZE;
Â  Â  const MAP_HEIGHT_TILES = canvas.height / TILE_SIZE;

Â  Â  const Wall = 'ğŸª¨'; // Original wall emoji
Â  Â  const Floor = ' ';
Â  Â  const Player = 'ğŸ™';
Â  Â  const Enemy = 'ğŸ‰';
Â  Â  const Key = 'ğŸ”‘';
Â  Â  const Exit = 'ğŸšª';
Â  Â  const Potion = 'â¤ï¸';
Â  Â  const PlayerWin = 'ğŸ¥³';
    const FrozenEnemy = 'â„ï¸'; // New emoji for frozen enemy

Â  Â  let gameState = {};

Â  Â  // --- Game Logic ---
Â  Â  /**
Â  Â  Â * Initializes or resets the game state.
Â  Â  Â */
Â  Â  function initGame() {
Â  Â  Â  Â  gameState = {
Â  Â  Â  Â  Â  Â  map: generateMap(),
Â  Â  Â  Â  Â  Â  player: { x: 0, y: 0, hp: 100, maxHp: 100 },
Â  Â  Â  Â  Â  Â  enemies: [], // Enemies will be initialized with frozenTurns later
Â  Â  Â  Â  Â  Â  key: { x: 0, y: 0 },
Â  Â  Â  Â  Â  Â  exit: { x: 0, y: 0 },
Â  Â  Â  Â  Â  Â  potions: [],
Â  Â  Â  Â  Â  Â  hasKey: false,
Â  Â  Â  Â  Â  Â  gameOver: false,
Â  Â  Â  Â  Â  Â  gameWon: false,
Â  Â  Â  Â  Â  Â  turn: 0 // Turn counter for enemy movement
Â  Â  Â  Â  };
Â  Â  Â  Â  placeEntities();
Â  Â  Â  Â  updateUI();
Â  Â  Â  Â  // Ensure the main game loop isn't running from a previous game
Â  Â  Â  Â  if(gameState.animationFrameId) {
Â  Â  Â  Â  Â  Â  cancelAnimationFrame(gameState.animationFrameId);
Â  Â  Â  Â  }
Â  Â  Â  Â  gameLoop();
Â  Â  }

Â  Â  /**
Â  Â  Â * Procedurally generates a cave-like map using Cellular Automata.
Â  Â  Â */
Â  Â  function generateMap() {
Â  Â  Â  Â  let map = Array.from({ length: MAP_HEIGHT_TILES }, () =>
Â  Â  Â  Â  Â  Â  Array.from({ length: MAP_WIDTH_TILES }, () => Math.random() < 0.45 ? Wall : Floor)
Â  Â  Â  Â  );

Â  Â  Â  Â  // Automata simulation to smooth out the map into caves
Â  Â  Â  Â  for (let i = 0; i < 4; i++) {
Â  Â  Â  Â  Â  Â  let newMap = JSON.parse(JSON.stringify(map));
Â  Â  Â  Â  Â  Â  for (let y = 1; y < MAP_HEIGHT_TILES - 1; y++) {
Â  Â  Â  Â  Â  Â  Â  Â  for (let x = 1; x < MAP_WIDTH_TILES - 1; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  let wallCount = 0;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let ny = y - 1; ny <= y + 1; ny++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  for (let nx = x - 1; nx <= x + 1; nx++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (map[ny][nx] === Wall) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  wallCount++;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  newMap[y][x] = wallCount > 4 ? Wall : Floor;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  map = newMap;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Add a border of walls
Â  Â  Â  Â  for(let y = 0; y < MAP_HEIGHT_TILES; y++) {
Â  Â  Â  Â  Â  Â  map[y][0] = Wall;
Â  Â  Â  Â  Â  Â  map[y][MAP_WIDTH_TILES-1] = Wall;
Â  Â  Â  Â  }
Â  Â  Â  Â  for(let x = 0; x < MAP_WIDTH_TILES; x++) {
Â  Â  Â  Â  Â  Â  map[0][x] = Wall;
Â  Â  Â  Â  Â  Â  map[MAP_HEIGHT_TILES-1][x] = Wall;
Â  Â  Â  Â  }
Â  Â  Â  Â  return map;
Â  Â  }

Â  Â  /**
Â  Â  Â * Places the player, enemies, key, exit, and potions on valid floor tiles.
Â  Â  Â */
Â  Â  function placeEntities() {
Â  Â  Â  Â  const floorTiles = [];
Â  Â  Â  Â  for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
Â  Â  Â  Â  Â  Â  for (let x = 0; x < MAP_WIDTH_TILES; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.map[y][x] === Floor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  floorTiles.push({ x, y });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  const getRandomTile = () => {
Â  Â  Â  Â  Â  Â  const index = Math.floor(Math.random() * floorTiles.length);
Â  Â  Â  Â  Â  Â  return floorTiles.splice(index, 1)[0];
Â  Â  Â  Â  };

Â  Â  Â  Â  // Place Player, Key, Exit
Â  Â  Â  Â  Object.assign(gameState.player, getRandomTile());
Â  Â  Â  Â  Object.assign(gameState.key, getRandomTile());
Â  Â  Â  Â  Object.assign(gameState.exit, getRandomTile());

Â  Â  Â  Â  // Place Enemies
Â  Â  Â  Â  const NUM_ENEMIES = 5;
Â  Â  Â  Â  for (let i = 0; i < NUM_ENEMIES; i++) {
Â  Â  Â  Â  Â  Â  if (floorTiles.length > 0) {
                // MODIFICATION START: Initialize enemies with frozenTurns
                const enemyPos = getRandomTile();
                gameState.enemies.push({ x: enemyPos.x, y: enemyPos.y, frozenTurns: 0 });
                // MODIFICATION END
            }
Â  Â  Â  Â  }

Â  Â  Â  Â  // Place Potions
Â  Â  Â  Â  const NUM_POTIONS = 3;
Â  Â  Â  Â  for (let i = 0; i < NUM_POTIONS; i++) {
Â  Â  Â  Â  Â  Â  if(floorTiles.length > 0) gameState.potions.push(getRandomTile());
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * The main game loop, responsible for updating and drawing.
Â  Â  Â */
Â  Â  function gameLoop() {
Â  Â  Â  Â  if (gameState.gameOver || gameState.gameWon) {
Â  Â  Â  Â  Â  Â  draw(); // Final draw to show win/loss message
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â  update();
Â  Â  Â  Â  draw();
Â  Â  Â  Â  gameState.animationFrameId = requestAnimationFrame(gameLoop);
Â  Â  }

Â  Â  /**
Â  Â  Â * Updates the game state (e.g., enemy movement).
Â  Â  Â */
Â  Â  function update() {
Â  Â  Â  Â  // This function is intentionally simple for this turn-based structure.
Â  Â  Â  Â  // Complex updates happen in response to player input.
Â  Â  }

Â  Â  /**
Â  Â  Â * Moves all enemies based on simple AI.
Â  Â  Â */
Â  Â  function moveEnemies() {
Â  Â  Â  Â  gameState.enemies.forEach(enemy => {
            // MODIFICATION START: Check if enemy is frozen
            if (enemy.frozenTurns > 0) {
                enemy.frozenTurns--; // Decrement frozen turns
                return; // Skip movement for this enemy
            }
            // MODIFICATION END

Â  Â  Â  Â  Â  Â  // 50% chance to hunt the player, 50% chance to move randomly
Â  Â  Â  Â  Â  Â  const huntPlayer = Math.random() > 0.5;
Â  Â  Â  Â  Â  Â  let dx = 0, dy = 0;

Â  Â  Â  Â  Â  Â  if (huntPlayer) {
Â  Â  Â  Â  Â  Â  Â  Â  dx = Math.sign(gameState.player.x - enemy.x);
Â  Â  Â  Â  Â  Â  Â  Â  dy = Math.sign(gameState.player.y - enemy.y);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  dx = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
Â  Â  Â  Â  Â  Â  Â  Â  dy = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Attempt to move
Â  Â  Â  Â  Â  Â  const nextX = enemy.x + dx;
Â  Â  Â  Â  Â  Â  const nextY = enemy.y + dy;

Â  Â  Â  Â  Â  Â  if (isWalkable(nextX, nextY)) {
Â  Â  Â  Â  Â  Â  Â  Â  enemy.x = nextX;
Â  Â  Â  Â  Â  Â  Â  Â  enemy.y = nextY;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  // Check for collision with player after moving
Â  Â  Â  Â  Â  Â  if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
Â  Â  Â  Â  Â  Â  Â  Â  takeDamage(15);
                // MODIFICATION START: Freeze enemy on collision
                enemy.frozenTurns = 2; // Freeze for 2 turns
                // MODIFICATION END
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Renders the entire game state to the canvas.
Â  Â  Â */
Â  Â  function draw() {
Â  Â  Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  ctx.font = `${TILE_SIZE * 0.8}px monospace`;

Â  Â  Â  Â  // Draw map
Â  Â  Â  Â  for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
Â  Â  Â  Â  Â  Â  for (let x = 0; x < MAP_WIDTH_TILES; x++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (gameState.map[y][x] === Wall) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  ctx.fillText(Wall, x * TILE_SIZE, y * TILE_SIZE + TILE_SIZE);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // Draw entities
Â  Â  Â  Â  const drawEntity = (entity, symbol) => ctx.fillText(symbol, entity.x * TILE_SIZE, entity.y * TILE_SIZE + TILE_SIZE);

Â  Â  Â  Â  if(!gameState.hasKey) drawEntity(gameState.key, Key);
Â  Â  Â  Â  drawEntity(gameState.exit, Exit);
Â  Â  Â  Â  gameState.potions.forEach(potion => drawEntity(potion, Potion));

Â  Â  Â  Â  // Conditionally draw enemies as skulls if game is won, or frozen if frozen, else normal
Â  Â  Â  Â  gameState.enemies.forEach(enemy => {
            let enemySymbol = Enemy;
            if (gameState.gameWon) {
                enemySymbol = 'ğŸ’€'; // Skull for game won
            } else if (enemy.frozenTurns > 0) {
                enemySymbol = FrozenEnemy; // Frozen emoji
            }
            drawEntity(enemy, enemySymbol);
        });

Â  Â  Â  Â  // Conditionally draw player as skull if game is over, or partying face if game is won
Â  Â  Â  Â  let currentPlayerSymbol = Player;
Â  Â  Â  Â  if (gameState.gameOver) {
Â  Â  Â  Â  Â  Â  currentPlayerSymbol = 'ğŸ’€'; // Skull for game over
Â  Â  Â  Â  } else if (gameState.gameWon) {
Â  Â  Â  Â  Â  Â  currentPlayerSymbol = PlayerWin; // Party face for win
Â  Â  Â  Â  }
Â  Â  Â  Â  drawEntity(gameState.player, currentPlayerSymbol);

Â  Â  Â  Â  // Draw Game Over or Win message
Â  Â  Â  Â  if (gameState.gameOver || gameState.gameWon) {
Â  Â  Â  Â  Â  Â  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
Â  Â  Â  Â  Â  Â  ctx.fillRect(0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  Â  Â  ctx.fillStyle = gameState.gameWon ? '#28a745' : '#dc3545';
Â  Â  Â  Â  Â  Â  ctx.font = 'bold 60px Courier New';
Â  Â  Â  Â  Â  Â  ctx.textAlign = 'center';
Â  Â  Â  Â  Â  Â  const message = gameState.gameWon ? 'YOU ESCAPED! ğŸ‰' : 'GAME OVER! ğŸ’€'; // Changed win/lose emoji for clarity
Â  Â  Â  Â  Â  Â  ctx.fillText(message, canvas.width / 2, canvas.height / 2);
Â  Â  Â  Â  Â  Â  ctx.textAlign = 'left'; // Reset alignment
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Updates the UI elements (status and HP text).
Â  Â  Â */
Â  Â  function updateUI() {
Â  Â  Â  Â  if (gameState.gameOver) {
Â  Â  Â  Â  Â  Â  statusText.textContent = "You were defeated! ğŸ’€";
Â  Â  Â  Â  Â  Â  hpText.style.color = "#dc3545";
Â  Â  Â  Â  } else if (gameState.gameWon) {
Â  Â  Â  Â  Â  Â  statusText.textContent = "Congratulations! You escaped! ğŸ‰";
Â  Â  Â  Â  Â  Â  hpText.style.color = "#28a745";
Â  Â  Â  Â  } else if (gameState.hasKey) {
Â  Â  Â  Â  Â  Â  statusText.textContent = "You have the key! Go to the door! ğŸšª";
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  statusText.textContent = "Find the key ğŸ”‘ and escape!";
Â  Â  Â  Â  }
Â  Â  Â  Â  hpText.textContent = `HP: ${gameState.player.hp}`;
Â  Â  Â  Â  if(gameState.player.hp < 30) {
Â  Â  Â  Â  Â  Â  hpText.style.color = "#ffc107"; // Warning yellow
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  hpText.style.color = "#28a745"; // Healthy green
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Reduces player HP and checks for game over.
Â  Â  Â */
Â  Â  function takeDamage(amount) {
Â  Â  Â  Â  gameState.player.hp = Math.max(0, gameState.player.hp - amount);
Â  Â  Â  Â  if (gameState.player.hp <= 0) {
Â  Â  Â  Â  Â  Â  gameState.gameOver = true;
Â  Â  Â  Â  }
Â  Â  Â  Â  updateUI();
Â  Â  }

Â  Â  /**
Â  Â  Â * New function to handle player movement logic
Â  Â  Â */
Â  Â  function movePlayer(dx, dy) {
Â  Â  Â  Â  if (gameState.gameOver || gameState.gameWon) return;

Â  Â  Â  Â  const nextX = gameState.player.x + dx;
Â  Â  Â  Â  const nextY = gameState.player.y + dy;

Â  Â  Â  Â  if (isWalkable(nextX, nextY)) {
Â  Â  Â  Â  Â  Â  gameState.player.x = nextX;
Â  Â  Â  Â  Â  Â  gameState.player.y = nextY;

Â  Â  Â  Â  Â  Â  // After player moves, enemies get a turn.
Â  Â  Â  Â  Â  Â  moveEnemies(); // This is where enemies check their frozenTurns and move
Â  Â  Â  Â  Â  Â  checkInteractions(); // Check for new interactions after all movements
Â  Â  Â  Â  Â  Â  updateUI();
Â  Â  Â  Â  }
Â  Â  }

Â  Â  /**
Â  Â  Â * Handles player movement and interactions from keyboard.
Â  Â  Â */
Â  Â  function handleInput(event) {
Â  Â  Â  Â  let dx = 0, dy = 0;
Â  Â  Â  Â  switch (event.key) {
Â  Â  Â  Â  Â  Â  case 'ArrowUp':
Â  Â  Â  Â  Â  Â  case 'w':
Â  Â  Â  Â  Â  Â  case 'W':
Â  Â  Â  Â  Â  Â  Â  Â  dy = -1;
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  case 'ArrowDown':
Â  Â  Â  Â  Â  Â  case 's':
Â  Â  Â  Â  Â  Â  case 'S':
Â  Â  Â  Â  Â  Â  Â  Â  dy = 1;
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  case 'ArrowLeft':
Â  Â  Â  Â  Â  Â  case 'a':
Â  Â  Â  Â  Â  Â  case 'A':
Â  Â  Â  Â  Â  Â  Â  Â  dx = -1;
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  case 'ArrowRight':
Â  Â  Â  Â  Â  Â  case 'd':
Â  Â  Â  Â  Â  Â  case 'D':
Â  Â  Â  Â  Â  Â  Â  Â  dx = 1;
Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  case 'r': // Added 'r' for reset
Â  Â  Â  Â  Â  Â  case 'R':
Â  Â  Â  Â  Â  Â  Â  Â  initGame();
Â  Â  Â  Â  Â  Â  Â  Â  return; // Don't process movement after reset
Â  Â  Â  Â  Â  Â  default:
Â  Â  Â  Â  Â  Â  Â  Â  return; // Ignore other keys
Â  Â  Â  Â  }
Â  Â  Â  Â  movePlayer(dx, dy); // Call the new movement function
Â  Â  }

Â  Â  /**
Â  Â  Â * Checks for player interactions with items, enemies, and the exit.
Â  Â  Â */
Â  Â  function checkInteractions() {
Â  Â  Â  Â  // Check key
Â  Â  Â  Â  if (!gameState.hasKey && gameState.player.x === gameState.key.x && gameState.player.y === gameState.key.y) {
Â  Â  Â  Â  Â  Â  gameState.hasKey = true;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Check exit
Â  Â  Â  Â  if (gameState.hasKey && gameState.player.x === gameState.exit.x && gameState.player.y === gameState.exit.y) {
Â  Â  Â  Â  Â  Â  gameState.gameWon = true;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Check potions
Â  Â  Â  Â  gameState.potions = gameState.potions.filter(potion => {
Â  Â  Â  Â  Â  Â  if (potion.x === gameState.player.x && potion.y === gameState.player.y) {
Â  Â  Â  Â  Â  Â  Â  Â  gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 50);
Â  Â  Â  Â  Â  Â  Â  Â  return false; // Remove potion from array
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  return true;
Â  Â  Â  Â  });

Â  Â  Â  Â  // Check enemies (collision after enemy move)
        // NOTE: This interaction check is primarily for player *landing on* an enemy after player's own move,
        // or if an enemy moved onto the player. The freeze logic is now handled more directly in moveEnemies
        // when an enemy successfully moves onto a player. This ensures damage and freeze happen consistently.
        // It's still good to have this here for completeness or if game logic changes, but the main freeze trigger is in moveEnemies.
Â  Â  Â  Â  gameState.enemies.forEach(enemy => {
Â  Â  Â  Â  Â  Â  if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
                // Damage and freeze logic moved to moveEnemies for consistency
                // to ensure the enemy that *just* moved onto the player is the one frozen.
                // This block can remain for other types of interactions if needed.
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  }

Â  Â  /**
Â  Â  Â * Checks if a tile at given coordinates is walkable (not a wall).
Â  Â  Â */
Â  Â  function isWalkable(x, y) {
Â  Â  Â  Â  return x >= 0 && x < MAP_WIDTH_TILES && y >= 0 && y < MAP_HEIGHT_TILES && gameState.map[y][x] === Floor;
Â  Â  }

Â  Â  // --- Event Listeners ---
Â  Â  window.addEventListener('keydown', handleInput);
Â  Â  resetButton.addEventListener('click', initGame);

Â  Â  // Event listeners for arrow buttons
Â  Â  document.getElementById('upButton').addEventListener('click', () => movePlayer(0, -1));
Â  Â  document.getElementById('downButton').addEventListener('click', () => movePlayer(0, 1));
Â  Â  document.getElementById('leftButton').addEventListener('click', () => movePlayer(-1, 0));
Â  Â  document.getElementById('rightButton').addEventListener('click', () => movePlayer(1, 0));


Â  Â  // --- Initial Start ---
Â  Â  // Show modal on window load, then initialize game
Â  Â  window.onload = function() {
Â  Â  Â  Â  showModal();
Â  Â  Â  Â  initGame(); // Initialize game after modal is shown
Â  Â  };

Â  Â  // Modal functions
Â  Â  function showModal() {
Â  Â  Â  Â  // Ensure the modal is a flex container when displayed to center its content
Â  Â  Â  Â  document.getElementById('warningModal').style.display = 'flex';
Â  Â  }

Â  Â  function closeModal() {
Â  Â  Â  Â  document.getElementById('warningModal').style.display = 'none';
Â  Â  }
</script>
</body>
</html>
