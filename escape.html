<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Escape</title>
<style>
/* Provided Navbar CSS */
ul {
    list-style-type: none;
    margin: 0px;
    padding: 0px;
    overflow: hidden;
    background-color: #fa07e2;
    width: 800px;
    border-radius: 8px;
    margin-bottom: 10px;
}
li {
    float: left; /* Make list items go side-by-side */
}
li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none; /* No underline for links */
}
li a:hover {
    background-color: #60fa07;
    color: #000000
}
/* Game & Page Styling */
body {
    font-family: 'Courier New', Courier, monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-image: url('images/rickroll.gif'); /* UPDATED PATH */
    background-size: cover; /* Ensures the image covers the entire background */
    background-position: center center; /* Centers the image */
    background-repeat: no-repeat; /* Prevents the image from repeating */
    background-attachment: fixed; /* Keeps the background image fixed when scrolling */
    color: white;
    margin-top: 20px;
}
#game-container {
    border: 4px solid #ff0000;
    border-radius: 8px;
    padding: 10px; /* Adjust if button is absolutely positioned within padding */
    background-color: #000;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
    position: relative; /* Crucial for absolute positioning of pause button */
}
canvas {
    background-color: #111;
    display: block;
}
#game-ui {
    width: 800px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 10px;
    padding: 0 5px;
    flex-wrap: wrap; /* Allow items to wrap on smaller screens */
    gap: 5px; /* Spacing between UI elements */
}
#status-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #000000;
    flex-basis: 100%; /* Take full width on a new line */
    text-align: center;
    margin-bottom: 10px;
}
#hp-text, #bomb-text, #timer-text, #level-text, #score-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #FFFFFF; /* Default white for all these */
    margin: 0 5px;
}
#hp-text { color: #28a745; } /* Green for health */
#bomb-text { color: #FFA500; } /* Orange for bombs */
#timer-text { color: #FFFFFF; } /* Default white for timer */


button#resetButton { /* Removed #pauseButton from here */
    background-color: #ff0000;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    font-weight: bold;
    transition: background-color 0.3s;
    margin: 0 5px;
}
button#resetButton:hover {
    background-color: #32a852;
    color: black
}

/* Specific styling for the new pause button */
button#pauseButton {
    position: absolute; /* Position relative to game-container */
    top: 15px; /* Adjust as needed */
    left: 15px; /* Adjust as needed */
    z-index: 10; /* Ensure it's above the canvas */
    
    /* Styling for the button itself */
    background-color: rgba(255, 0, 0, 0.7); /* Semi-transparent red */
    border: 2px solid #ff0000;
    padding: 5px; /* Smaller padding for an icon button */
    border-radius: 8px; /* Slightly more rounded */
    cursor: pointer;
    transition: background-color 0.3s, border-color 0.3s, transform 0.1s;
    width: 50px; /* Fixed width for icon button */
    height: 50px; /* Fixed height for icon button */
    display: flex; /* To center the image */
    justify-content: center;
    align-items: center;
}

button#pauseButton:hover {
    background-color: #ff0000; /* Solid red on hover */
    border-color: #32a852;
}
button#pauseButton:active {
    transform: translateY(1px); /* Little press effect */
}

button#pauseButton img {
    width: 30px; /* Size of the pause icon */
    height: 30px; /* Size of the pause icon */
    display: block; /* Remove extra space below image */
    /* Optional: filter to make the icon white if it's black */
    /* filter: invert(1); */ 
}


/* Mobile Controls (Arrow Buttons) Styling */
#mobile-controls {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px; /* Space between rows */
}

.d-pad-row {
    display: flex;
    gap: 5px; /* Space between buttons in a row */
}

.arrow-button {
    background-color: #4CAF50; /* Green */
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 1.5em;
    font-weight: bold;
    transition: background-color 0.3s, transform 0.1s;
    min-width: 60px; /* Ensure good touch target */
    min-height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.arrow-button:hover {
    background-color: #45a049;
    transform: translateY(-2px);
}

.arrow-button:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* Specific style for the bomb button to distinguish it */
#bombButton {
    background-color: #FF4500; /* OrangeRed */
    border: 2px solid #CD3333; /* Darker red */
}
#bombButton:hover {
    background-color: #E04000;
}


/* Modal Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1000; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%; /* Could be responsive */
    max-width: 500px;
    border-radius: 10px;
    text-align: center;
    position: relative;
    color: black; /* Ensure text is visible */
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.modal-content h2 {
    color: #ff0000;
    margin-top: 0;
}

/* Style for buttons inside modals (general) */
.modal-content button {
    background-color: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    margin: 5px; /* Spacing between buttons in modal */
    
    /* Flexbox for image + text buttons */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-width: 120px; /* Ensure buttons are wide enough for content */
    min-height: 120px; /* Ensure buttons are tall enough for content */
}

.modal-content button img {
    width: 50px; /* Adjust size of the icon */
    height: 50px; /* Adjust size of the icon */
    margin-bottom: 8px; /* Space between icon and text */
    /* Optional: filter to make icons white if they are black on a dark background */
    /* filter: invert(1); */
}

.modal-content button span {
    font-size: 1.2em; /* Make the text bigger */
    font-weight: bold;
}


.modal-content button:hover {
    background-color: #45a049;
}

.close-button {
    color: #aaa;
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close-button:hover,
.close-button:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}

/* Pause Menu Specifics */
#pauseMenuModal .modal-content {
    display: flex; /* Use flexbox for modal content to layout buttons horizontally */
    flex-direction: column; /* Stack title and buttons vertically */
    align-items: center; /* Center items horizontally */
}

#pauseMenuModal .modal-content h2 {
    font-size: 3em; /* Make "Paused!" larger */
    margin-bottom: 20px;
}

#pauseMenuModal .button-container {
    display: flex; /* Container for the buttons to make them row-wise */
    gap: 20px; /* Space between buttons */
    justify-content: center;
    width: 100%;
    flex-wrap: wrap; /* Allow buttons to wrap if screen is too small */
}

/* Specific colors for pause menu buttons if desired */
#pauseMenuModal #pauseMenuPlayButton {
    background-color: #007bff; /* Blue for play */
}
#pauseMenuModal #pauseMenuPlayButton:hover {
    background-color: #0056b3;
}
#pauseMenuModal #pauseMenuRestartButton {
    background-color: #dc3545; /* Red for restart */
}
#pauseMenuModal #pauseMenuRestartButton:hover {
    background-color: #c82333;
}
#pauseMenuModal #pauseMenuQuitButton {
    background-color: #6c757d; /* Grey for quit */
}
#pauseMenuModal #pauseMenuQuitButton:hover {
    background-color: #5a6268;
}

</style>
</head>
<body>
<ul>
    <li><a href="turtle.html">‚¨Ö Back to game selection</a></li>
</ul>
<h1 style="color:black;">Controls</h1>
<p style="color:black;">Use arrow keys, WASD, or the on-screen buttons</p>
<p style="color:black;">Press 'R' or click "New Game" to reset</p>
<p style="color:black;">If you want to heal, get the heart (Potion) Max: 100 (Health in bottom-right corner)</p>
<p style="color:black;">Press 'X' or the bomb button to use a bomb (stuns nearby enemies, or damages you if no enemies are in range!)</p>
<p style="color:black;">Press 'P' or the 'Pause' button to pause the game.</p>


<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <button id="pauseButton"><img src="pause.png" alt="Pause"></button> 
</div>
<div id="game-ui">
    <span id="status-text" style="color:black;">Find the key üîë and escape through the doorüö™!</span>
    <span id="level-text">Level: 1</span>
    <span id="score-text">Score: 0 üèÜ</span>
    <span id="bomb-text">Bombs: 3 üí£</span>
    <button id="resetButton">New Game</button>
    <span id="hp-text">HP: 100</span>
    <span id="timer-text">Time: 01:00</span>
</div>

<div id="mobile-controls">
    <div class="d-pad-row">
        <button id="upButton" class="arrow-button">‚¨ÜÔ∏è</button>
    </div>
    <div class="d-pad-row">
        <button id="leftButton" class="arrow-button">‚¨ÖÔ∏è</button>
        <button id="bombButton" class="arrow-button">üí£</button>
        <button id="rightButton" class="arrow-button">‚û°Ô∏è</button>
    </div>
    <div class="d-pad-row">
        <button id="downButton" class="arrow-button">‚¨áÔ∏è</button>
    </div>
</div>

<div id="warningModal" class="modal">
    <div class="modal-content">
        <span class="close-button" onclick="closeModal()">&times;</span>
        <h2>WARNING!</h2>
        <p>This game is SO hard that the creator himself could only beat it ONCE!! If you beat it, tell me in the comments of ANY of my videos and I will give you a shoutout!! Good luck and have fun!!</p>
        <button onclick="closeModal()">Got It!</button>
    </div>
</div>

<div id="pauseMenuModal" class="modal">
    <div class="modal-content">
        <h2>Paused!</h2>
        <div class="button-container">
            <button id="pauseMenuPlayButton">
                <img src="play.png" alt="Play"> <span>Play</span>
            </button>
            <button id="pauseMenuRestartButton">
                <img src="restart.png" alt="Restart"> <span>Restart</span>
            </button>
            <button id="pauseMenuQuitButton">
                <img src="quit.png" alt="Quit"> <span>Quit</span>
            </button>
        </div>
    </div>
</div>

<script>
// --- Game Configuration ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const TILE_SIZE = 40; // Size of each tile in pixels
const MAP_WIDTH_TILES = Math.floor(canvas.width / TILE_SIZE);
const MAP_HEIGHT_TILES = Math.floor(canvas.height / TILE_SIZE);

// --- UI Elements ---
const statusText = document.getElementById('status-text');
const hpText = document.getElementById('hp-text');
const bombText = document.getElementById('bomb-text');
const resetButton = document.getElementById('resetButton');
const timerText = document.getElementById('timer-text');
const levelText = document.getElementById('level-text');
const scoreText = document.getElementById('score-text');

// Mobile Controls
const upButton = document.getElementById('upButton');
const downButton = document.getElementById('downButton');
const leftButton = document.getElementById('leftButton');
const rightButton = document.getElementById('rightButton');
const bombButton = document.getElementById('bombButton');

// Pause Menu Elements
const pauseButton = document.getElementById('pauseButton');
const pauseMenuModal = document.getElementById('pauseMenuModal');
const pauseMenuPlayButton = document.getElementById('pauseMenuPlayButton');
const pauseMenuRestartButton = document.getElementById('pauseMenuRestartButton');
const pauseMenuQuitButton = document.getElementById('pauseMenuQuitButton');

// --- Game Assets/Symbols ---
const Player = 'üö∂‚Äç‚ôÄÔ∏è'; // Changed to woman walking emoji
const Wall = 'ü™®';
const Floor = ' '; // Empty space
const Enemy = 'üêâ'; // Dragon
const FrozenEnemy = '‚ùÑÔ∏è'; // Changed to snowflake emoji
const Key = 'üîë';
const Exit = 'üö™';
const Potion = '‚ù§Ô∏è';
const PlayerWin = 'üèÜ'; // Player symbol on win

// --- Game State ---
let gameState = {};
let animationFrameId = null; // For managing the game loop

// --- Game Initialization ---
function initGame() {
    if(animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
    }

    gameState = {
        map: [],
        player: { x: 0, y: 0, hp: 100, maxHp: 100, bombs: 3 },
        enemies: [],
        key: { x: 0, y: 0 },
        exit: { x: 0, y: 0 },
        potions: [],
        hasKey: false,
        gameOver: false,
        gameWon: false, // Overall game won (e.g., after final level)
        levelComplete: false, // For regular level progression
        gameOverReason: null,
        turn: 0,
        startTime: null,
        initialTime: 60 * 1000,
        remainingTime: 60 * 1000,
        score: 0,
        currentLevel: 0, // Starts at 0, startGame() increments to 1 for first level
        isPaused: false, // Pause state
        messageOnCanvas: null, // New: For displaying messages on canvas
        messageDisplayDuration: 0 // New: How long the message should display
    };
    
    // Call startGame to properly initialize the first level
    startGame();
    // Ensure the pause menu is hidden when a new game starts
    pauseMenuModal.style.display = 'none';
}

// --- Level Management ---
function startGame() {
    // Reset flags for new level load
    gameState.gameOver = false;
    gameState.levelComplete = false; // Reset level complete flag
    gameState.gameOverReason = null;
    gameState.messageOnCanvas = null; // Clear any lingering canvas messages
    gameState.isPaused = false; // Ensure game is unpaused when starting new level

    // If currentLevel is 0 (initial load or full reset), set to 1.
    // Otherwise, assume currentLevel has already been set/incremented by handleGameEndOrLevelComplete
    if (gameState.currentLevel === 0) {
        gameState.currentLevel = 1;
    }

    // Define level parameters for 3 levels
    const levelParams = {
        1: { name: "Beginner's Dungeon", enemyCount: 2, potionCount: 2, timer: 75 * 1000, wallDensity: 0.25 },
        2: { name: "Cavern of Trials", enemyCount: 4, potionCount: 1, timer: 60 * 1000, wallDensity: 0.35 },
        3: { name: "Labyrinth of Despair", enemyCount: 6, potionCount: 1, timer: 45 * 1000, wallDensity: 0.45 }
    };

    // Check if player completed final level (Level 3)
    if (gameState.currentLevel > Object.keys(levelParams).length) { // Greater than 3
        gameState.gameWon = true;
        endGame("You escaped the dungeon and defeated all levels!"); // Declare overall game win
        return; // Stop game setup
    }

    const params = levelParams[gameState.currentLevel];
    
    // Reset player health, bombs, and key status for new level
    gameState.player.maxHp = 100; // Reset player max HP for regular levels
    gameState.player.hp = gameState.player.maxHp; // Heal fully
    gameState.player.bombs = 3; // Reset bombs for each level
    gameState.hasKey = false;
    gameState.turn = 0;

    // Generate map and place entities using the simpler logic
    gameState.map = generateMap(MAP_WIDTH_TILES, MAP_HEIGHT_TILES, params.wallDensity);
    gameState.enemies = []; // Clear enemies from previous level
    gameState.potions = []; // Clear potions from previous level
    
    placeEntities(params.enemyCount, params.potionCount, MAP_WIDTH_TILES, MAP_HEIGHT_TILES);

    gameState.initialTime = params.timer;
    statusText.textContent = `Level ${gameState.currentLevel}: ${params.name}!`;

    gameState.remainingTime = gameState.initialTime; // Reset timer for new level
    gameState.startTime = performance.now(); // Reset start time for countdown
    gameLoop(); // Start the game loop for the new level
    updateUI();
}

// --- Map Generation (Reverted to simpler version) ---
function generateMap(width = MAP_WIDTH_TILES, height = MAP_HEIGHT_TILES, wallDensity = 0.3) {
    let map = Array.from({ length: height }, () =>
        Array.from({ length: width }, () => Math.random() < wallDensity ? Wall : Floor)
    );

    // Add a solid border of walls to ensure map is always enclosed
    for(let y = 0; y < height; y++) {
        map[y][0] = Wall;
        map[y][width-1] = Wall;
    }
    for(let x = 0; x < width; x++) {
        map[0][x] = Wall;
        map[height-1][x] = Wall;
    }
    return map;
}

// --- Entity Placement (Reverted to simpler version) ---
function placeEntities(numEnemies, numPotions, mapWidth, mapHeight) {
    // Helper to get a random empty tile. Does not guarantee connectivity.
    const getRandomEmptyTile = () => {
        let x, y;
        let attempts = 0;
        // Set a max attempts to prevent infinite loops on extremely dense maps
        const maxAttempts = (mapWidth * mapHeight) * 2; 
        do {
            x = Math.floor(Math.random() * mapWidth);
            y = Math.floor(Math.random() * mapHeight);
            attempts++;
            if (attempts > maxAttempts) {
                console.warn("Could not find an empty tile after many attempts. Placing on potentially occupied tile.");
                break; // Break if too many attempts, to prevent hang
            }
        } while (gameState.map[y][x] !== Floor); // Loop until a floor tile is found
        return { x, y };
    };

    // Place Player, Key, Exit
    Object.assign(gameState.player, getRandomEmptyTile());
    Object.assign(gameState.key, getRandomEmptyTile());
    Object.assign(gameState.exit, getRandomEmptyTile());

    // Place Enemies
    gameState.enemies = []; // Clear previous enemies
    for (let i = 0; i < numEnemies; i++) {
        const enemyPos = getRandomEmptyTile();
        // Enemies no longer have 'isBoss' property in this version
        gameState.enemies.push({ x: enemyPos.x, y: enemyPos.y, frozenTurns: 0 }); 
    }

    // Place Potions
    gameState.potions = []; // Clear previous potions
    for (let i = 0; i < numPotions; i++) {
        gameState.potions.push(getRandomEmptyTile());
    }
}

// --- Game Loop and Drawing ---
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

    // Draw map
    for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
        for (let x = 0; x < MAP_WIDTH_TILES; x++) {
            const tileType = gameState.map[y][x];
            ctx.fillStyle = tileType === Wall ? '#333' : '#666'; // Dark grey for walls, lighter for floor
            ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            if (tileType === Wall) {
                ctx.strokeStyle = '#555'; // Border for walls
                ctx.lineWidth = 1;
                ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // Draw Exit (Door)
    drawEntity(gameState.exit.x, gameState.exit.y, Exit);

    // Draw Key
    if (!gameState.hasKey) {
        drawEntity(gameState.key.x, gameState.key.y, Key);
    }

    // Draw Potions
    gameState.potions.forEach(p => {
        drawEntity(p.x, p.y, Potion);
    });

    // Draw Enemies
    gameState.enemies.forEach(enemy => {
        // No 'enemy.symbol' for regular enemies, and no boss HP bar
        const symbol = enemy.frozenTurns > 0 ? FrozenEnemy : Enemy; 
        drawEntity(enemy.x, enemy.y, symbol);
    });

    // Draw Player
    drawEntity(gameState.player.x, gameState.player.y, Player);

    // Draw Game Over/Win message on canvas
    if (gameState.gameOver) {
        drawMessageOnCanvas(gameState.gameOverReason, 'red');
    } else if (gameState.gameWon) {
        drawMessageOnCanvas('YOU WIN! Thanks for playing!', 'green');
    } else if (gameState.messageOnCanvas) {
        // Display transient messages (e.g., "Key Collected!")
        drawMessageOnCanvas(gameState.messageOnCanvas, 'yellow');
    }
}

function drawEntity(x, y, symbol) {
    ctx.font = `${TILE_SIZE - 5}px sans-serif`; // Slightly smaller to fit in tile
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(symbol, x * TILE_SIZE + TILE_SIZE / 2, y * TILE_SIZE + TILE_SIZE / 2);
}

function drawMessageOnCanvas(message, color) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; // Semi-transparent black background
    ctx.fillRect(0, canvas.height / 2 - 50, canvas.width, 100);

    ctx.fillStyle = color;
    ctx.font = 'bold 36px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(message, canvas.width / 2, canvas.height / 2);
}

function updateUI() {
    hpText.textContent = `HP: ${gameState.player.hp}`;
    hpText.style.color = gameState.player.hp < (gameState.player.maxHp / 4) ? 'red' : '#28a745';
    bombText.textContent = `Bombs: ${gameState.player.bombs} üí£`;
    levelText.textContent = `Level: ${gameState.currentLevel}`;
    scoreText.textContent = `Score: ${gameState.score} üèÜ`;

    const minutes = Math.floor(gameState.remainingTime / 60000);
    const seconds = Math.floor((gameState.remainingTime % 60000) / 1000);
    timerText.textContent = `Time: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    timerText.style.color = gameState.remainingTime < 10000 ? 'red' : 'white';

    // Update status text based on game state
    if (gameState.gameOver) {
        statusText.textContent = `Game Over! ${gameState.gameOverReason}`;
    } else if (gameState.gameWon) {
        statusText.textContent = "Congratulations! You won the game!";
    } else if (gameState.levelComplete) {
        statusText.textContent = `Level ${gameState.currentLevel} Complete! Press 'R' for next level!`;
    } else { // No boss level specific message
        statusText.textContent = "Find the key üîë and escape through the doorüö™!";
    }
}

function updateGameLogic() {
    if (gameState.gameOver || gameState.gameWon || gameState.isPaused || gameState.levelComplete) return; // Stop logic updates

    // Handle transient messages on canvas
    if (gameState.messageOnCanvas && gameState.messageDisplayDuration > 0) {
        gameState.messageDisplayDuration--;
        if (gameState.messageDisplayDuration <= 0) {
            gameState.messageOnCanvas = null; // Clear message after duration
        }
    }

    // Timer logic
    const elapsed = performance.now() - gameState.startTime;
    gameState.remainingTime = gameState.initialTime - elapsed;

    if (gameState.remainingTime <= 0) {
        endGame("Time's up!");
        return;
    }

    // Enemy movement (only every other turn)
    if (gameState.turn % 2 === 0) { // Enemies move every 2 player turns
        moveEnemies();
    }
    
    // No boss ability cooldown decrement in this version

    updateUI();
}

// --- Movement and Interaction ---
function isValidMove(x, y) {
    // Check map boundaries
    if (x < 0 || x >= MAP_WIDTH_TILES || y < 0 || y >= MAP_HEIGHT_TILES) {
        return false;
    }
    // Check for walls
    return gameState.map[y][x] !== Wall;
}

function movePlayer(dx, dy) {
    if (gameState.gameOver || gameState.gameWon || gameState.isPaused || gameState.levelComplete) return;

    const newX = gameState.player.x + dx;
    const newY = gameState.player.y + dy;

    if (isValidMove(newX, newY)) {
        gameState.player.x = newX;
        gameState.player.y = newY;
        handlePlayerInteractions();
        gameState.turn++; // Increment turn after player moves
        updateGameLogic(); // Update game logic after player turn
    }
}

function handlePlayerInteractions() {
    // Check for key
    if (!gameState.hasKey && gameState.player.x === gameState.key.x && gameState.player.y === gameState.key.y) {
        gameState.hasKey = true;
        gameState.messageOnCanvas = "You got the key! üîë";
        gameState.messageDisplayDuration = 30; // Display for 30 frames/updates
    }

    // Check for exit (door)
    if (gameState.hasKey && gameState.player.x === gameState.exit.x && gameState.player.y === gameState.exit.y) {
        levelComplete();
    }

    // Check for potions
    gameState.potions = gameState.potions.filter(p => {
        if (gameState.player.x === p.x && gameState.player.y === p.y) {
            gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 20); // Heal 20 HP
            gameState.messageOnCanvas = "Healed 20 HP! ‚ù§Ô∏è";
            gameState.messageDisplayDuration = 30;
            return false; // Remove potion
        }
        return true;
    });

    // Check for enemy collision AFTER player moves
    checkEnemyCollision();
}

function moveEnemies() {
    gameState.enemies.forEach(enemy => {
        if (enemy.frozenTurns > 0) {
            enemy.frozenTurns--; // Decrement frozen turns
            return; // Skip movement if frozen
        }

        const playerX = gameState.player.x;
        const playerY = gameState.player.y;

        let dx = 0;
        let dy = 0;

        // Simple A.I. to move towards player
        if (playerX > enemy.x) dx = 1;
        else if (playerX < enemy.x) dx = -1;
        
        if (playerY > enemy.y) dy = 1;
        else if (playerY < enemy.y) dy = -1;

        let newEnemyX = enemy.x;
        let newEnemyY = enemy.y;

        // Try moving horizontally first, then vertically if horizontal is blocked
        if (isValidMove(enemy.x + dx, enemy.y)) {
            newEnemyX = enemy.x + dx;
        } else if (isValidMove(enemy.x, enemy.y + dy)) {
            newEnemyY = enemy.y + dy;
        } else if (isValidMove(enemy.x - dx, enemy.y)) { // Try inverse horizontal
            newEnemyX = enemy.x - dx;
        } else if (isValidMove(enemy.x, enemy.y - dy)) { // Try inverse vertical
            newEnemyY = enemy.y - dy;
        }

        // Check if new position is occupied by another enemy
        const collisionWithOtherEnemy = gameState.enemies.some(
            otherEnemy => otherEnemy !== enemy && otherEnemy.x === newEnemyX && otherEnemy.y === newEnemyY
        );

        if (!collisionWithOtherEnemy) {
            enemy.x = newEnemyX;
            enemy.y = newEnemyY;
        }
        // No boss ability logic in this version
    });
    checkEnemyCollision(); // Check collision after all enemies move
}

function checkEnemyCollision() {
    gameState.enemies.forEach(enemy => {
        if (gameState.player.x === enemy.x && gameState.player.y === enemy.y) {
            takeDamage(10); // Standard enemy damage
        }
    });
}

function takeDamage(amount) {
    gameState.player.hp -= amount;
    if (gameState.player.hp <= 0) {
        gameState.player.hp = 0;
        endGame("You ran out of HP!");
    }
}

function useBomb() {
    if (gameState.gameOver || gameState.gameWon || gameState.isPaused || gameState.levelComplete) return;
    if (gameState.player.bombs <= 0) {
        gameState.messageOnCanvas = "No bombs left!";
        gameState.messageDisplayDuration = 30;
        return;
    }

    gameState.player.bombs--;
    gameState.messageOnCanvas = "Booooom! üí•";
    gameState.messageDisplayDuration = 30;

    const blastRadius = 2; // Tiles around the player
    let enemiesStunnedOrHit = 0;

    gameState.enemies.forEach(enemy => {
        const dx = Math.abs(gameState.player.x - enemy.x);
        const dy = Math.abs(gameState.player.y - enemy.y);

        if (dx <= blastRadius && dy <= blastRadius) {
            enemy.frozenTurns = 3; // Freeze for 3 turns
            enemiesStunnedOrHit++;
        }
    });

    if (enemiesStunnedOrHit === 0) {
        takeDamage(10); // Player takes damage if no enemies are in range
        gameState.messageOnCanvas = "Bomb self-damage! ü§ï";
        gameState.messageDisplayDuration = 30;
    }
    updateUI();
}

// No bossAbility function in this version

// --- Game State Transitions ---
function endGame(reason) {
    gameState.gameOver = true;
    gameState.gameOverReason = reason;
    cancelAnimationFrame(animationFrameId); // Stop game loop
    draw(); // Draw final state
    updateUI(); // Update UI for game over
}

function levelComplete() {
    gameState.levelComplete = true;
    gameState.score += gameState.remainingTime / 1000 * 10; // Bonus for remaining time
    gameState.score += gameState.player.hp * 5; // Bonus for remaining HP
    cancelAnimationFrame(animationFrameId); // Stop game loop
    updateUI();
}

function handleGameEndOrLevelComplete() {
    if (gameState.gameOver) {
        // Player lost overall game, restart completely
        initGame();
    } else if (gameState.gameWon) {
        // Player won the entire game (completed final level)
        initGame(); // Or show a special "You Won!" screen
    } else if (gameState.levelComplete) {
        // Player completed a regular level, proceed to next
        gameState.currentLevel++;
        startGame(); // Attempt to start next level (will handle win if > 3)
    } else {
        // This case shouldn't be reached if called correctly, but as a safeguard, restart game.
        initGame();
    }
}

// --- Game Loop ---
function gameLoop() {
    if (gameState.gameOver || gameState.gameWon || gameState.isPaused || gameState.levelComplete) {
        cancelAnimationFrame(animationFrameId);
        return;
    }

    updateGameLogic();
    draw();
    animationFrameId = requestAnimationFrame(gameLoop);
}

// --- Event Listeners ---
// Keyboard Controls
document.addEventListener('keydown', (e) => {
    switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            movePlayer(0, -1);
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            movePlayer(0, 1);
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            movePlayer(-1, 0);
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            movePlayer(1, 0);
            break;
        case 'r':
        case 'R':
            // If level complete, go to next level. Else, restart current level.
            if (gameState.levelComplete) {
                handleGameEndOrLevelComplete();
            } else {
                initGame(); // Full game restart
            }
            break;
        case 'x':
        case 'X':
            useBomb();
            break;
        case 'p':
        case 'P':
            togglePause();
            break;
    }
});

// Mobile Controls
upButton.addEventListener('click', () => movePlayer(0, -1));
downButton.addEventListener('click', () => movePlayer(0, 1));
leftButton.addEventListener('click', () => movePlayer(-1, 0));
rightButton.addEventListener('click', () => movePlayer(1, 0));
bombButton.addEventListener('click', useBomb);

// UI Button Listeners
resetButton.addEventListener('click', () => {
    // If level complete, go to next level. Else, restart current level.
    if (gameState.levelComplete) {
        handleGameEndOrLevelComplete();
    } else {
        initGame(); // Full game restart
    }
});

// Pause Button & Menu Listeners
pauseButton.addEventListener('click', togglePause);
pauseMenuPlayButton.addEventListener('click', togglePause);
pauseMenuRestartButton.addEventListener('click', () => {
    initGame(); // Restart game from Level 1
    togglePause(); // Close pause menu
});
pauseMenuQuitButton.addEventListener('click', () => {
    // Implement quit logic here, e.g., redirect to main menu or show a message
    alert("You quit the game. Thanks for playing!");
    // For a simple quit, you might just stop the game loop and show game over
    endGame("Player quit the game.");
    togglePause(); // Close pause menu
});


// --- Modals ---
const warningModal = document.getElementById('warningModal');

function showModal(modalElement) {
    modalElement.style.display = 'flex'; // Use flex to center
}

function closeModal() {
    warningModal.style.display = 'none';
}

function togglePause() {
    gameState.isPaused = !gameState.isPaused;
    if (gameState.isPaused) {
        cancelAnimationFrame(animationFrameId); // Stop the game loop
        showModal(pauseMenuModal);
    } else {
        pauseMenuModal.style.display = 'none'; // Hide the modal
        gameLoop(); // Resume the game loop
    }
    updateUI(); // Update UI to reflect pause state
}


// --- Initial Setup ---
// Show warning modal on initial load
window.onload = () => {
    showModal(warningModal);
    initGame(); // Initialize game state, but it will be paused by the modal
};

// Removed generateBossMap and placeBossAndPlayer as they are not used in this 3-level version
</script>
<audio autoplay loop>
    <source src="images/back.mp3" type="audio/mpeg"> Your browser does not support the audio element.
</audio>
</body>
</html>
