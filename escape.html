<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Dungeon Escape</title>
<style>
/* Provided Navbar CSS */
ul {
    list-style-type: none;
    margin: 0px;
    padding: 0px;
    overflow: hidden;
    background-color: #fa07e2;
    width: 800px;
    border-radius: 8px;
    margin-bottom: 10px;
}
li {
    float: left; /* Make list items go side-by-side */
}
li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none; /* No underline for links */
}
li a:hover {
    background-color: #60fa07;
    color: #000000
}
/* Game & Page Styling */
body {
    font-family: 'Courier New', Courier, monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-image: url('rickroll.gif'); /* REPLACE WITH YOUR IMAGE PATH/URL */
    background-size: cover; /* Ensures the image covers the entire background */
    background-position: center center; /* Centers the image */
    background-repeat: no-repeat; /* Prevents the image from repeating */
    background-attachment: fixed; /* Keeps the background image fixed when scrolling */
    color: white;
    margin-top: 20px;
}
#game-container {
    border: 4px solid #ff0000;
    border-radius: 8px;
    padding: 10px;
    background-color: #000;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
}
canvas {
    background-color: #111;
    display: block;
}
#game-ui {
    width: 800px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 10px;
    padding: 0 5px;
}
#status-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #000000
}
#hp-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #28a745; /* Green for health */
}
/* Style for Bomb Count and Timer */
#bomb-text, #timer-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #FFA500; /* Orange for bombs */
    margin: 0 10px; /* Spacing */
}
#timer-text {
    color: #FFFFFF; /* White for timer */
}


button#resetButton {
    background-color: #ff0000;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    font-weight: bold;
    transition: background-color 0.3s;
}
button#resetButton:hover {
    background-color: #32a852;
    color: black
}

/* Mobile Controls (Arrow Buttons) Styling */
#mobile-controls {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px; /* Space between rows */
}

.d-pad-row {
    display: flex;
    gap: 5px; /* Space between buttons in a row */
}

.arrow-button {
    background-color: #4CAF50; /* Green */
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 10px;
    cursor: pointer;
    font-size: 1.5em;
    font-weight: bold;
    transition: background-color 0.3s, transform 0.1s;
    min-width: 60px; /* Ensure good touch target */
    min-height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

.arrow-button:hover {
    background-color: #45a049;
    transform: translateY(-2px);
}

.arrow-button:active {
    transform: translateY(0);
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* Specific style for the bomb button to distinguish it */
#bombButton {
    background-color: #FF4500; /* OrangeRed */
    border: 2px solid #CD3333; /* Darker red */
}
#bombButton:hover {
    background-color: #E04000;
}


/* Modal Styles */
.modal {
    display: none; /* Hidden by default */
    position: fixed; /* Stay in place */
    z-index: 1000; /* Sit on top */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    overflow: auto; /* Enable scroll if needed */
    background-color: rgba(0,0,0,0.7); /* Black w/ opacity */
    justify-content: center;
    align-items: center;
}

.modal-content {
    background-color: #fefefe;
    margin: auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%; /* Could be responsive */
    max-width: 500px;
    border-radius: 10px;
    text-align: center;
    position: relative;
    color: black; /* Ensure text is visible */
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}

.modal-content h2 {
    color: #ff0000;
    margin-top: 0;
}

.modal-content button {
    background-color: #4CAF50;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    margin-top: 15px;
}

.modal-content button:hover {
    background-color: #45a049;
}

.close-button {
    color: #aaa;
    position: absolute;
    top: 10px;
    right: 15px;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
}

.close-button:hover,
.close-button:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}
</style>
</head>
<body>
<ul>
    <li><a href="turtle.html">‚¨Ö Back to game selection</a></li>
</ul>
<h1 style="color:black;">Controls</h1>
<p style="color:black;">Use arrow keys, WASD, or the on-screen buttons</p>
<p style="color:black;">Press 'R' or click "New Game" to reset</p>
<p style="color:black;">If you want to heal, get the heart (Potion) Max: 100 (Health in bottom-right corner)</p>
<p style="color:black;">Press 'X' or the bomb button to use a bomb (stuns nearby enemies, or damages you if no enemies are in range!)</p>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>
<div id="game-ui">
    <span id="status-text" style="color:black;">Find the key üîë and escape through the doorüö™!</span>
    <span id="bomb-text">Bombs: 3 üí£</span>
    <button id="resetButton">New Game</button>
    <span id="hp-text">HP: 100</span>
    <span id="timer-text">Time: 01:00</span>
</div>

<div id="mobile-controls">
    <div class="d-pad-row">
        <button id="upButton" class="arrow-button">‚¨ÜÔ∏è</button>
    </div>
    <div class="d-pad-row">
        <button id="leftButton" class="arrow-button">‚¨ÖÔ∏è</button>
        <button id="bombButton" class="arrow-button">üí£</button>
        <button id="rightButton" class="arrow-button">‚û°Ô∏è</button>
    </div>
    <div class="d-pad-row">
        <button id="downButton" class="arrow-button">‚¨áÔ∏è</button>
    </div>
</div>

<div id="warningModal" class="modal">
    <div class="modal-content">
        <span class="close-button" onclick="closeModal()">&times;</span>
        <h2>WARNING!</h2>
        <p>This game is SO hard that the creator himself could only beat it ONCE!! If you beat it, tell me in the comments of ANY of my videos and I will give you a shoutout!! Good luck and have fun!!</p>
        <button onclick="closeModal()">Got It!</button>
    </div>
</div>

<script>
    // --- Game Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const resetButton = document.getElementById('resetButton');
    const statusText = document.getElementById('status-text');
    const hpText = document.getElementById('hp-text');
    const bombText = document.getElementById('bomb-text');
    const timerText = document.getElementById('timer-text');
    const bombButton = document.getElementById('bombButton');

    const TILE_SIZE = 40;
    const MAP_WIDTH_TILES = canvas.width / TILE_SIZE;
    const MAP_HEIGHT_TILES = canvas.height / TILE_SIZE;

    const Wall = 'ü™®';
    const Floor = ' ';
    const Player = 'üôç';
    const Enemy = 'üêâ'; // Standard enemy dragon
    const GIANT_DRAGON_BOSS = 'üê≤'; // Different dragon emoji for the boss
    const Key = 'üîë';
    const Exit = 'üö™';
    const Potion = '‚ù§Ô∏è';
    const Weapon = '‚öîÔ∏è'; // NEW: Weapon emoji
    const PlayerWin = 'ü•≥';
    const FrozenEnemy = '‚ùÑÔ∏è';

    let gameState = {};
    let animationFrameId; // To store the animation frame ID for timer

    // --- Game Logic ---
    /**
     * Initializes or resets the game state.
     */
    function initGame() {
        if(animationFrameId) { // Stop any existing animation frame (like the timer)
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null; // Clear the ID
        }

        gameState = {
            map: [],
            player: { x: 0, y: 0, hp: 100, maxHp: 100, bombs: 5, attackDamage: 15 }, // NEW: bombs 5, attackDamage 15
            enemies: [],
            key: { x: 0, y: 0 },
            exit: { x: 0, y: 0 },
            potions: [],
            weapon: null, // NEW: weapon object, null until picked up
            hasKey: false,
            gameOver: false,
            gameWon: false,
            gameOverReason: null, // Stores 'time' or 'hp' if game over
            turn: 0, // Turn counter for enemy movement
            startTime: null, // For tracking when the timer started
            initialTime: 0, // Will be set by setupLevel
            elapsedTime: 0, // Track elapsed time for display on win
            completionTime: null, // Stores time taken to win
            isTypingTime: false, // Control typing animation
            typedCompletionTime: '', // Store typed completion time
            typedTimeLeft: '', // Store typed time left
            currentLevel: 1, // NEW: Start at level 1
            boss: null, // NEW: Boss object, null until level 3
            bossDefeated: false // NEW: Track boss status
        };
        setupLevel(gameState.currentLevel); // Start the first level
        gameState.startTime = performance.now(); // Record start time for countdown
        gameLoop();
    }

    /**
     * Sets up the game for a specific level.
     */
    function setupLevel(level) {
        // Reset player's dynamic stats for the new level but keep overall HP
        gameState.player.x = 0;
        gameState.player.y = 0;
        gameState.player.bombs = 5; // Give new bombs each level, now 5
        gameState.player.attackDamage = 15; // Reset attack damage for new level

        gameState.hasKey = false;
        gameState.enemies = [];
        gameState.potions = [];
        gameState.weapon = null; // Reset weapon for new level
        gameState.boss = null;
        gameState.bossDefeated = false;

        // Set initial time based on level
        switch(level) {
            case 1:
                gameState.initialTime = 90 * 1000; // 1 minute 30 seconds
                break;
            case 2:
                gameState.initialTime = 120 * 1000; // 2 minutes
                break;
            case 3:
                gameState.initialTime = 300 * 1000; // 5 minutes (Final Boss)
                break;
            default:
                gameState.initialTime = 60 * 1000; // Default to 1 minute
        }
        gameState.startTime = performance.now(); // Reset timer for new level


        if (level === 3) {
            gameState.map = generateBossMap();
        } else {
            gameState.map = generateMap(); // Use cellular automata for levels 1 & 2
        }

        placeEntitiesForLevel(level);
        updateUI(); // Update UI to reflect new level status
    }

    /**
     * Procedurally generates a cave-like map using Cellular Automata.
     */
    function generateMap() {
        let map = Array.from({ length: MAP_HEIGHT_TILES }, () =>
            Array.from({ length: MAP_WIDTH_TILES }, () => Math.random() < 0.45 ? Wall : Floor)
        );

        // Automata simulation to smooth out the map into caves
        for (let i = 0; i < 4; i++) {
            let newMap = JSON.parse(JSON.stringify(map));
            for (let y = 1; y < MAP_HEIGHT_TILES - 1; y++) {
                for (let x = 1; x < MAP_WIDTH_TILES - 1; x++) {
                    let wallCount = 0;
                    for (let ny = y - 1; ny <= y + 1; ny++) {
                        for (let nx = x - 1; nx <= x + 1; nx++) {
                            if (map[ny][nx] === Wall) {
                                wallCount++;
                            }
                        }
                    }
                    newMap[y][x] = wallCount > 4 ? Wall : Floor;
                }
            }
            map = newMap;
        }

        // Add a border of walls
        for(let y = 0; y < MAP_HEIGHT_TILES; y++) {
            map[y][0] = Wall;
            map[y][MAP_WIDTH_TILES-1] = Wall;
        }
        for(let x = 0; x < MAP_WIDTH_TILES; x++) {
            map[0][x] = Wall;
            map[MAP_HEIGHT_TILES-1][x] = Wall;
        }
        return map;
    }

    /**
     * Generates a simpler, more open map for the boss fight.
     */
    function generateBossMap() {
        let map = Array.from({ length: MAP_HEIGHT_TILES }, () =>
            Array.from({ length: MAP_WIDTH_TILES }, () => Floor)
        );
        // Create a border of walls
        for(let y = 0; y < MAP_HEIGHT_TILES; y++) {
            map[y][0] = Wall;
            map[y][MAP_WIDTH_TILES-1] = Wall;
        }
        for(let x = 0; x < MAP_WIDTH_TILES; x++) {
            map[0][x] = Wall;
            map[MAP_HEIGHT_TILES-1][x] = Wall;
        }
        return map;
    }


    /**
     * Places entities based on the current level.
     */
    function placeEntitiesForLevel(level) {
        const floorTiles = [];
        for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
            for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                if (gameState.map[y][x] === Floor) {
                    floorTiles.push({ x, y });
                }
            }
        }

        const getRandomTile = () => {
            const index = Math.floor(Math.random() * floorTiles.length);
            return floorTiles.splice(index, 1)[0];
        };

        // Place Player
        Object.assign(gameState.player, getRandomTile());

        if (level < 3) {
            // Place Key, Exit for normal levels
            Object.assign(gameState.key, getRandomTile());
            Object.assign(gameState.exit, getRandomTile());

            // Place Enemies
            const NUM_ENEMIES = level === 1 ? 5 : 8; // More enemies on Level 2
            for (let i = 0; i < NUM_ENEMIES; i++) {
                if (floorTiles.length > 0) {
                    const enemyPos = getRandomTile();
                    gameState.enemies.push({ x: enemyPos.x, y: enemyPos.y, frozenTurns: 0 });
                }
            }

            // Place Potions
            const NUM_POTIONS = 3;
            for (let i = 0; i < NUM_POTIONS; i++) {
                if(floorTiles.length > 0) gameState.potions.push(getRandomTile());
            }
        } else { // Level 3: Boss Level
            // Place the boss
            const bossSize = 3; // Boss occupies a 3x3 area
            let bossPlaced = false;
            while (!bossPlaced) {
                const centerTile = getRandomTile();
                const bossX = centerTile.x - Math.floor(bossSize / 2);
                const bossY = centerTile.y - Math.floor(bossSize / 2);

                let validPlacement = true;
                for (let by = 0; by < bossSize; by++) {
                    for (let bx = 0; bx < bossSize; bx++) {
                        if (!isWalkable(bossX + bx, bossY + by))
