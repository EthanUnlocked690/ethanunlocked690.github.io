<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ATLAS Console</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            background-color: #000;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'VT323', monospace;
            color: #0f0;
        }

        #console {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #0f0;
            font-size: 1.2rem;
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto;
            font-family: 'VT323', monospace;
        }

        #prompt {
            display: flex;
            align-items: center;
        }

        #prompt-caret {
            color: #ff4500;
            margin-right: 5px;
        }

        #prompt-input {
            background: transparent;
            border: none;
            color: #0f0;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            outline: none;
            flex-grow: 1;
        }

        .output-line {
            margin: 5px 0;
        }

        #login-modal, #chat-window, #call-window, #call-participants {
            display: none;
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0f0;
            color: #0f0;
            font-family: 'VT323', monospace;
            padding: 20px;
            border-radius: 5px;
        }

        #login-modal {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            z-index: 1000; /* Ensure modal is on top */
        }

        #chat-window {
            bottom: 10px;
            right: 10px;
            width: 300px;
            height: 400px;
            display: flex;
            flex-direction: column;
        }

        #chat-messages {
            flex-grow: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            border: 1px solid #0f0;
            padding: 10px;
        }

        #chat-input {
            background: transparent;
            border: 1px solid #0f0;
            color: #0f0;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            padding: 5px;
        }

        #chat-button, #call-controls button, #start-call-button {
            background-color: #0f0;
            color: #000;
            border: 1px solid #0f0;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            border-radius: 4px;
        }

        #chat-button {
            position: fixed;
            bottom: 10px;
            right: 10px;
        }

        #chat-button.unread {
            background-color: #ff4500;
            color: #fff;
        }

        #call-window {
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #call-videos {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        #local-video, #remote-video {
            width: 48%;
            height: 300px;
            background: #111;
            border: 1px solid #0f0;
        }

        #call-controls {
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        #call-participants {
            top: 10px;
            right: 10px;
            width: 200px;
        }

        #toggle-camera, #toggle-microphone, #toggle-screen, #show-participants {
            background-color: #0f0;
            color: #000;
            border: 1px solid #0f0;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1rem;
            border-radius: 4px;
        }

        #toggle-camera:hover, #toggle-microphone:hover, #toggle-screen:hover, #show-participants:hover {
            background-color: #0088cc;
        }

        .notification-message {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .accept-button, .decline-button {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .message-timestamp {
            color: #ff4500;
            margin-right: 5px;
        }

        .message-content {
            flex-grow: 1;
        }

        .typing-dots::after {
            content: '...';
            animation: dots 1s steps(3, end) infinite;
        }

        @keyframes dots {
            0% { content: '.'; }
            33% { content: '..'; }
            66% { content: '...'; }
        }
    </style>
</head>
<body>
    <div id="console"></div>
    <div id="prompt">
        <span id="prompt-caret">></span>
        <input type="text" id="prompt-input" autocomplete="off">
    </div>
    <div id="login-modal">
        <h2>ATLAS CONSOLE LOGIN</h2>
        <p>Username: <input type="text" id="login-username"></p>
        <p>Password: <input type="password" id="login-password"></p>
        <p>Passkey: <input type="password" id="login-passkey"></p>
        <button onclick="attemptLogin()">Login</button>
    </div>
    <div id="chat-window">
        <div id="chat-messages"></div>
        <button id="start-call-button">Start Call</button>
        <input type="text" id="chat-input" placeholder="Type message...">
    </div>
    <button id="chat-button">Chat</button>
    <div id="call-window">
        <div id="call-videos">
            <video id="local-video" autoplay muted></video>
            <video id="remote-video" autoplay></video>
        </div>
        <div id="call-controls">
            <button id="toggle-camera">Camera: Off</button>
            <button id="toggle-microphone">Microphone: On</button>
            <button id="toggle-screen">Share Screen: Off</button>
            <button id="show-participants">Participants</button>
        </div>
    </div>
    <div id="call-participants"></div>
    <script>
        const consoleDiv = document.getElementById('console');
        const promptInput = document.getElementById('prompt-input');
        const loginModal = document.getElementById('login-modal');
        const loginUsername = document.getElementById('login-username');
        const loginPassword = document.getElementById('login-password');
        const loginPasskey = document.getElementById('login-passkey');
        const chatWindow = document.getElementById('chat-window');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');
        const chatButton = document.getElementById('chat-button');
        const callWindow = document.getElementById('call-window');
        const localVideo = document.getElementById('local-video');
        const remoteVideo = document.getElementById('remote-video');
        const toggleCameraButton = document.getElementById('toggle-camera');
        const toggleMicrophoneButton = document.getElementById('toggle-microphone');
        const toggleScreenButton = document.getElementById('toggle-screen');
        const showParticipantsButton = document.getElementById('show-participants');
        const startCallButton = document.getElementById('start-call-button');
        const callParticipantsList = document.getElementById('call-participants');
        const USERS = {
            'ETHANUNLOCKED': { role: 'ADMIN', password: 'h4cker', passkey: '1957' },
            'BEEF WELLINGTON': { role: 'USER', password: 'password123', passkey: '2468' }
        };
        const USER_STATUSES = {
            'ETHANUNLOCKED': 'ONLINE',
            'BEEF WELLINGTON': 'ONLINE'
        };
        const SOUND_COMMAND_NAMES = [
            'SIREN', 'CONFIRM', 'ALARM', 'GET OUT', 'VINE BOOM', 'RIZZ', 'YOUR IDOL',
            'FART', '6 7', 'GOLDEN', 'SODA POP', 'BRUH', 'SUI', 'JOHN CENA', 'PUMPKIN',
            'CENSOR', 'B+F', 'BURP'
        ];
        const AUDIO_BUFFER = {};
        const VERBOSE = false; // Control debug logging
        let ringingPlayer = null;
        let lastStatusUpdate = Date.now();
        let authUsername = null;
        let userType = null;
        let isLoggedIn = false;
        let isChatOpen = false;
        let isCallActive = false;
        let isCameraOn = false;
        let isMicrophoneOn = true;
        let isScreenSharing = false;
        let isUserTyping = false;
        let isOtherTyping = false;
        let localStream = null;
        let peerConnection = null;
        let callParticipants = [];
        let pendingInvitations = [];
        let unreadMessages = 0;
        let commandHistory = [];
        let historyIndex = -1;

        const SOUND_EFFECTS = {
            'SIREN': 'siren.mp3',
            'CONFIRM': 'confirm.mp3',
            'ALARM': 'alert.mp3',
            'GET OUT': 'get-out-meme.mp3',
            'VINE BOOM': 'vine-boom.mp3',
            'RIZZ': 'rizz.mp3',
            'YOUR IDOL': 'idol.mp3',
            'FART': 'fart.mp3',
            '6 7': '67.mp3',
            'GOLDEN': 'gold.mp3',
            'SODA POP': 'soda.mp3',
            'BRUH': 'bro.mp3',
            'SUI': 'sui.mp3',
            'JOHN CENA': 'cena.mp3',
            'PUMPKIN': 'kin.mp3',
            'CENSOR': '__SYNTH_CENSOR__',
            'B+F': 'b.mp3',
            'BURP': 'burp.mp3',
            'RINGING': '__SYNTH_RINGING__'
        };

        function getSoundPath(name) {
            return SOUND_EFFECTS[name] || 'siren.mp3';
        }

        function createCensorBeepBuffer() {
            const context = Tone.context;
            const duration = 0.5;
            const sampleRate = context.sampleRate;
            const numSamples = Math.floor(sampleRate * duration);
            const audioBuffer = context.createBuffer(1, numSamples, sampleRate);
            const channel = audioBuffer.getChannelData(0);
            const freq = 1000;
            for (let i = 0; i < numSamples; i++) {
                const time = i / sampleRate;
                channel[i] = Math.sin(2 * Math.PI * freq * time) * 0.5;
            }
            return new Tone.ToneAudioBuffer(audioBuffer);
        }

        function createRingingBuffer() {
            const context = Tone.context;
            const duration = 2;
            const sampleRate = context.sampleRate;
            const numSamples = Math.floor(sampleRate * duration);
            const audioBuffer = context.createBuffer(1, numSamples, sampleRate);
            const channel = audioBuffer.getChannelData(0);
            const freq1 = 440;
            const freq2 = 480;
            for (let i = 0; i < numSamples; i++) {
                const time = i / sampleRate;
                if (time < 1) {
                    channel[i] = (Math.sin(2 * Math.PI * freq1 * time) + Math.sin(2 * Math.PI * freq2 * time)) * 0.25;
                } else {
                    channel[i] = 0;
                }
            }
            return new Tone.ToneAudioBuffer(audioBuffer);
        }

        async function loadSound(name) {
            const path = getSoundPath(name);
            if (AUDIO_BUFFER[path]) {
                return AUDIO_BUFFER[path];
            }
            if (path === '__SYNTH_CENSOR__') {
                try {
                    const buffer = createCensorBeepBuffer();
                    AUDIO_BUFFER[path] = buffer;
                    return buffer;
                } catch (e) {
                    if (VERBOSE) writeOutput(`[LOAD ERROR] Failed to synthesize CENSOR: ${e.message}`, 'var(--error-color)');
                    return null;
                }
            }
            if (path === '__SYNTH_RINGING__') {
                try {
                    const buffer = createRingingBuffer();
                    AUDIO_BUFFER[path] = buffer;
                    return buffer;
                } catch (e) {
                    if (VERBOSE) writeOutput(`[LOAD ERROR] Failed to synthesize RINGING: ${e.message}`, 'var(--error-color)');
                    return null;
                }
            }
            if (VERBOSE) writeOutput(`[LOAD] Requesting asset: ${name}...`, 'var(--prompt-caret)');
            try {
                const buffer = new Tone.ToneAudioBuffer(path);
                await buffer.loaded;
                AUDIO_BUFFER[path] = buffer;
                if (VERBOSE) writeOutput(`[LOAD SUCCESS] Asset ${name} loaded. Duration: ${buffer.duration.toFixed(2)}s.`, 'var(--terminal-color)');
                return buffer;
            } catch (e) {
                if (VERBOSE) writeOutput(`[LOAD ERROR] Failed to load external asset: ${path}`, 'var(--error-color)');
                return null;
            }
        }

        function stopRinging() {
            if (ringingPlayer) {
                ringingPlayer.stop();
                ringingPlayer.dispose();
                ringingPlayer = null;
                writeOutput(`SYSTEM: Call ringing terminated.`, 'var(--prompt-caret)');
            }
        }

        function writeOutput(text, color = 'var(--terminal-color)') {
            const line = document.createElement('div');
            line.className = 'output-line';
            line.style.color = color;
            line.innerHTML = text.replace(/\n/g, '<br>');
            consoleDiv.appendChild(line);
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }

        function showLoginModal() {
            loginModal.style.display = 'block';
            loginUsername.focus();
            chatWindow.style.display = 'none';
            callWindow.style.display = 'none';
            callParticipantsList.style.display = 'none';
        }

        function attemptLogin() {
            const username = loginUsername.value.trim().toUpperCase();
            const password = loginPassword.value;
            const passkey = loginPasskey.value;
            if (USERS[username] && USERS[username].password === password && USERS[username].passkey === passkey) {
                authUsername = username;
                userType = USERS[username].role;
                isLoggedIn = true;
                loginModal.style.display = 'none';
                writeOutput(`\nWELCOME TO ATLAS CONSOLE\nAUTHENTICATED USER: ${authUsername} (${userType})\n`, 'var(--highlight-color)');
                promptInput.focus();
            } else {
                writeOutput('AUTHENTICATION FAILED: Invalid credentials.', 'var(--error-color)');
                loginUsername.value = '';
                loginPassword.value = '';
                loginPasskey.value = '';
                loginUsername.focus();
            }
        }

        function getMessageTimestamp() {
            return new Date().toLocaleTimeString('en-US');
        }

        function updateUserList() {
            const userList = document.getElementById('chat-messages');
            userList.innerHTML = 'Users in Chat:<br>';
            const currentStatus = isUserTyping ? 'Typing' : USER_STATUSES[authUsername] || 'ONLINE';
            const currentColor = isUserTyping ? 'var(--prompt-caret)' : USER_STATUSES[authUsername] === 'CRITICAL (BREACH)' ? 'var(--error-color)' : USER_STATUSES[authUsername] === 'OFFLINE (IDLE)' ? 'var(--prompt-caret)' : 'var(--terminal-color)';
            const currentSpan = document.createElement('span');
            currentSpan.style.color = currentColor;
            currentSpan.className = isUserTyping ? 'typing-dots' : '';
            currentSpan.innerHTML = `- ${authUsername} (${userType}): ${currentStatus}<br>`;
            userList.appendChild(currentSpan);
            const otherUsers = Object.keys(USERS).filter(u => u !== authUsername);
            otherUsers.forEach(user => {
                const otherType = USERS[user].role;
                const otherStatus = isOtherTyping && user === (Object.keys(USERS).find(u => u !== authUsername) || 'BEEF WELLINGTON') ? 'Typing' : USER_STATUSES[user] || 'ONLINE';
                const otherColor = otherStatus === 'Typing' ? 'var(--prompt-caret)' : otherStatus === 'CRITICAL (BREACH)' ? 'var(--error-color)' : otherStatus === 'OFFLINE (IDLE)' ? 'var(--prompt-caret)' : 'var(--terminal-color)';
                const otherSpan = document.createElement('span');
                otherSpan.style.color = otherColor;
                otherSpan.className = otherStatus === 'Typing' ? 'typing-dots' : '';
                otherSpan.innerHTML = `- ${user} (${otherType}): ${otherStatus}<br>`;
                userList.appendChild(otherSpan);
            });
        }

        function simulateStatusUpdates() {
            const now = Date.now();
            if (now - lastStatusUpdate >= 30000) {
                const otherUsers = Object.keys(USERS).filter(u => u !== authUsername);
                otherUsers.forEach(user => {
                    const rand = Math.random();
                    if (rand < 0.05) {
                        USER_STATUSES[user] = 'CRITICAL (BREACH)';
                    } else if (rand < 0.35) {
                        USER_STATUSES[user] = 'OFFLINE (IDLE)';
                    } else if (rand < 0.65) {
                        USER_STATUSES[user] = 'ONLINE';
                    } else {
                        USER_STATUSES[user] = 'BUSY';
                    }
                });
                lastStatusUpdate = now;
                if (isChatOpen) {
                    updateUserList();
                }
            }
        }

        function simulateOtherTyping() {
            if (!isChatOpen || !isLoggedIn) return;
            const rand = Math.random();
            if (rand < 0.2) {
                isOtherTyping = !isOtherTyping;
                updateUserList();
            }
            simulateStatusUpdates();
        }

        async function toggleCamera() {
            if (!isCallActive) return;
            isCameraOn = !isCameraOn;
            if (localStream) {
                localStream.getVideoTracks().forEach(track => {
                    track.enabled = isCameraOn;
                });
                toggleCameraButton.textContent = isCameraOn ? 'Camera: On' : 'Camera: Off';
                writeOutput(`SYSTEM: Camera turned ${isCameraOn ? 'on' : 'off'}.`, 'var(--highlight-color)');
            }
        }

        async function toggleMicrophone() {
            if (!isCallActive) return;
            isMicrophoneOn = !isMicrophoneOn;
            if (localStream) {
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = isMicrophoneOn;
                });
                toggleMicrophoneButton.textContent = isMicrophoneOn ? 'Microphone: On' : 'Microphone: Off';
                writeOutput(`SYSTEM: Microphone turned ${isMicrophoneOn ? 'on' : 'off'}.`, 'var(--highlight-color)');
            }
        }

        async function toggleScreenShare() {
            if (!isCallActive) return;
            if (!isScreenSharing) {
                try {
                    const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
                    const screenTrack = screenStream.getVideoTracks()[0];
                    localVideo.srcObject = screenStream;
                    isScreenSharing = true;
                    toggleScreenButton.textContent = 'Share Screen: On';
                    writeOutput('SYSTEM: Screen sharing enabled.', 'var(--highlight-color)');
                    screenTrack.onended = () => {
                        isScreenSharing = false;
                        toggleScreenButton.textContent = 'Share Screen: Off';
                        if (localStream) {
                            localVideo.srcObject = localStream;
                        }
                        writeOutput('SYSTEM: Screen sharing stopped.', 'var(--highlight-color)');
                    };
                } catch (err) {
                    writeOutput(`ERROR: Failed to share screen: ${err.message}`, 'var(--error-color)');
                }
            } else {
                if (localStream) {
                    localVideo.srcObject = localStream;
                }
                isScreenSharing = false;
                toggleScreenButton.textContent = 'Share Screen: Off';
                writeOutput('SYSTEM: Screen sharing stopped.', 'var(--highlight-color)');
            }
        }

        async function startCall() {
            if (isCallActive) return;
            isCallActive = true;
            callParticipants = [authUsername];
            callWindow.style.display = 'flex';
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const hasCamera = devices.some(device => device.kind === 'videoinput');
                const hasMicrophone = devices.some(device => device.kind === 'audioinput');
                if (!hasCamera) {
                    writeOutput('WARNING: No camera detected. Video feed disabled.', 'var(--prompt-caret)');
                }
                if (!hasMicrophone) {
                    writeOutput('WARNING: No microphone detected. Audio disabled.', 'var(--prompt-caret)');
                }
                localStream = await navigator.mediaDevices.getUserMedia({ video: isCameraOn, audio: hasMicrophone });
                localVideo.srcObject = localStream;
                toggleCameraButton.textContent = isCameraOn ? 'Camera: On' : 'Camera: Off';
                toggleCameraButton.disabled = !hasCamera;
                toggleMicrophoneButton.textContent = isMicrophoneOn ? 'Microphone: On' : 'Microphone: Off';
                toggleMicrophoneButton.disabled = !hasMicrophone;
                peerConnection = { simulated: true };
                remoteVideo.srcObject = null;
                updateParticipantsList();
                notifyOtherUsers();
            } catch (err) {
                writeOutput(`ERROR: Failed to start call: ${err.message}`, 'var(--error-color)');
                endCall();
            }
        }

        async function notifyOtherUsers() {
            const otherUsers = Object.keys(USERS).filter(u => u !== authUsername && USER_STATUSES[u] !== 'BUSY' && USER_STATUSES[u] !== 'OFFLINE (IDLE)' && USER_STATUSES[u] !== 'CRITICAL (BREACH)');
            if (otherUsers.length === 0) {
                writeOutput('SYSTEM: No eligible users available to invite.', 'var(--prompt-caret)');
                stopRinging();
                return;
            }
            if (!ringingPlayer && Tone.context.state === 'running' && pendingInvitations.length === 0) {
                const buffer = await loadSound('RINGING');
                if (buffer) {
                    ringingPlayer = new Tone.Player({
                        url: buffer,
                        loop: true,
                        volume: -10
                    }).toDestination();
                    ringingPlayer.start();
                    writeOutput(`SYSTEM: Initiating call to eligible users: ${otherUsers.join(', ')}.`, 'var(--highlight-color)');
                }
            }
            otherUsers.forEach(otherUser => {
                if (callParticipants.includes(otherUser) || pendingInvitations.includes(otherUser)) return;
                pendingInvitations.push(otherUser);
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('ATLAS Call Invitation', {
                        body: `${authUsername} has started a call. Join now?`
                    });
                }
                if (isChatOpen) {
                    const notificationId = Date.now().toString();
                    const msgDiv = document.createElement('div');
                    msgDiv.className = 'notification-message';
                    msgDiv.dataset.notificationId = notificationId;
                    const timestampSpan = document.createElement('span');
                    timestampSpan.className = 'message-timestamp';
                    timestampSpan.textContent = getMessageTimestamp();
                    const contentSpan = document.createElement('span');
                    contentSpan.className = 'message-content';
                    contentSpan.textContent = `SYSTEM: ${authUsername} has started a call. Join now?`;
                    const acceptButton = document.createElement('img');
                    acceptButton.src = 'call.png';
                    acceptButton.className = 'accept-button';
                    acceptButton.alt = 'Accept';
                    acceptButton.addEventListener('click', () => {
                        chatMessages.removeChild(msgDiv);
                        pendingInvitations = pendingInvitations.filter(u => u !== otherUser);
                        joinCall(otherUser);
                        if (pendingInvitations.length === 0) {
                            stopRinging();
                        }
                        writeOutput(`SYSTEM: ${otherUser} accepted the call.`, 'var(--highlight-color)');
                        if (isChatOpen) {
                            const acceptMsg = document.createElement('div');
                            const acceptTimestamp = document.createElement('span');
                            acceptTimestamp.className = 'message-timestamp';
                            acceptTimestamp.textContent = getMessageTimestamp();
                            const acceptContent = document.createElement('span');
                            acceptContent.className = 'message-content';
                            acceptContent.textContent = `SYSTEM: ${otherUser} accepted the call.`;
                            acceptMsg.appendChild(acceptTimestamp);
                            acceptMsg.appendChild(acceptContent);
                            chatMessages.appendChild(acceptMsg);
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    });
                    const declineButton = document.createElement('img');
                    declineButton.src = 'no.png';
                    declineButton.className = 'decline-button';
                    declineButton.alt = 'Decline';
                    declineButton.addEventListener('click', () => {
                        chatMessages.removeChild(msgDiv);
                        pendingInvitations = pendingInvitations.filter(u => u !== otherUser);
                        if (pendingInvitations.length === 0) {
                            stopRinging();
                        }
                        writeOutput(`SYSTEM: ${otherUser} declined the call.`, 'var(--prompt-caret)');
                        if (isChatOpen) {
                            const declineMsg = document.createElement('div');
                            const declineTimestamp = document.createElement('span');
                            declineTimestamp.className = 'message-timestamp';
                            declineTimestamp.textContent = getMessageTimestamp();
                            const declineContent = document.createElement('span');
                            declineContent.className = 'message-content';
                            declineContent.textContent = `SYSTEM: ${otherUser} declined the call.`;
                            declineMsg.appendChild(declineTimestamp);
                            declineMsg.appendChild(declineContent);
                            chatMessages.appendChild(declineMsg);
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                        }
                    });
                    msgDiv.appendChild(timestampSpan);
                    msgDiv.appendChild(contentSpan);
                    msgDiv.appendChild(acceptButton);
                    msgDiv.appendChild(declineButton);
                    chatMessages.appendChild(msgDiv);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                } else if (USER_STATUSES[authUsername] !== 'BUSY') {
                    unreadMessages++;
                    updateUnreadCount();
                }
            });
        }

        async function joinCall(username) {
            if (!isCallActive) return;
            callParticipants.push(username);
            updateParticipantsList();
            remoteVideo.srcObject = null;
            pendingInvitations = pendingInvitations.filter(u => u !== username);
            if (pendingInvitations.length === 0) {
                stopRinging();
            }
            writeOutput(`SYSTEM: ${username} has joined the call.`, 'var(--highlight-color)');
        }

        function updateParticipantsList() {
            callParticipantsList.innerHTML = 'Participants:<br>' + callParticipants.map(p => `- ${p}`).join('<br>');
        }

        function endCall() {
            if (!isCallActive) return;
            isCallActive = false;
            callWindow.style.display = 'none';
            callParticipantsList.style.display = 'none';
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            if (peerConnection && peerConnection.simulated) {
                peerConnection = null;
            }
            isCameraOn = false;
            isMicrophoneOn = true;
            isScreenSharing = false;
            toggleCameraButton.textContent = 'Camera: Off';
            toggleMicrophoneButton.textContent = 'Microphone: On';
            toggleScreenButton.textContent = 'Share Screen: Off';
            pendingInvitations = [];
            callParticipants = [];
            stopRinging();
            writeOutput('SYSTEM: Call has been terminated.', 'var(--highlight-color)');
        }

        function leaveCall() {
            if (!isCallActive) return;
            callParticipants = callParticipants.filter(u => u !== authUsername);
            callWindow.style.display = 'none';
            callParticipantsList.style.display = 'none';
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            localVideo.srcObject = null;
            isCameraOn = false;
            isMicrophoneOn = true;
            isScreenSharing = false;
            toggleCameraButton.textContent = 'Camera: Off';
            toggleMicrophoneButton.textContent = 'Microphone: On';
            toggleScreenButton.textContent = 'Share Screen: Off';
            updateParticipantsList();
            stopRinging();
            writeOutput(`SYSTEM: ${authUsername} has left the call.`, 'var(--highlight-color)');
            if (isChatOpen) {
                const msgDiv = document.createElement('div');
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'message-timestamp';
                timestampSpan.textContent = getMessageTimestamp();
                const contentSpan = document.createElement('span');
                contentSpan.className = 'message-content';
                contentSpan.textContent = `SYSTEM: ${authUsername} has left the call.`;
                msgDiv.appendChild(timestampSpan);
                msgDiv.appendChild(contentSpan);
                chatMessages.appendChild(msgDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        function updateUnreadCount() {
            chatButton.textContent = `Chat${unreadMessages > 0 ? ` (${unreadMessages})` : ''}`;
            chatButton.className = unreadMessages > 0 ? 'unread' : '';
        }

        async function processCommand(command) {
            command = command.trim().toUpperCase();
            if (!command) return;
            writeOutput(`> ${command}`);
            commandHistory.push(command);
            historyIndex = commandHistory.length;
            const parts = command.split(/\s+/);
            const cmd = parts[0];
            const args = parts.slice(1);
            switch (cmd) {
                case 'HELP':
                    writeOutput(`
Available Commands:
HELP - Display this help message
CLEAR - Clear the console
INIT AUDIO - Initialize audio context
ACTIVE - List active users (MANAGER/ADMIN only)
[Sound Commands]: ${SOUND_COMMAND_NAMES.join(', ')}
`, 'var(--highlight-color)');
                    break;
                case 'CLEAR':
                    consoleDiv.innerHTML = '';
                    break;
                case 'INIT':
                    if (args[0] === 'AUDIO') {
                        if (Tone.context.state !== 'running') {
                            await Tone.context.resume();
                            writeOutput('SYSTEM: Audio context initialized.', 'var(--highlight-color)');
                        } else {
                            writeOutput('SYSTEM: Audio context already running.', 'var(--prompt-caret)');
                        }
                    } else {
                        writeOutput('ERROR: Unknown INIT subcommand.', 'var(--error-color)');
                    }
                    break;
                case 'ACTIVE':
                    if (userType !== 'MANAGER' && userType !== 'ADMIN') {
                        writeOutput(`\nACCESS DENIED: Command ACTIVE requires MANAGER or ADMIN privileges. Current User: ${authUsername}.`, 'var(--error-color)');
                        break;
                    }
                    lastStatusUpdate = 0;
                    simulateStatusUpdates();
                    writeOutput(`\n--- ACTIVE ATLAS USERS (${new Date().toLocaleTimeString('en-US')}) ---`, 'var(--highlight-color)');
                    Object.keys(USERS).forEach(user => {
                        let statusColor;
                        switch (USER_STATUSES[user]) {
                            case 'CRITICAL (BREACH)':
                                statusColor = 'var(--error-color)';
                                break;
                            case 'OFFLINE (IDLE)':
                                statusColor = 'var(--prompt-caret)';
                                break;
                            default:
                                statusColor = 'var(--terminal-color)';
                        }
                        writeOutput(`USER ID: ${user} | STATUS: ${USER_STATUSES[user]} (${USERS[user].role})`, statusColor);
                    });
                    writeOutput(`--------------------------\n`, 'var(--highlight-color)');
                    break;
                default:
                    if (SOUND_COMMAND_NAMES.includes(cmd)) {
                        if (Tone.context.state !== 'running') {
                            writeOutput('ERROR: Audio context not initialized. Run INIT AUDIO first.', 'var(--error-color)');
                            break;
                        }
                        const buffer = await loadSound(cmd);
                        if (buffer) {
                            const player = new Tone.Player(buffer).toDestination();
                            player.start();
                            writeOutput(`SYSTEM: Playing ${cmd}.`, 'var(--highlight-color)');
                        }
                    } else {
                        writeOutput(`ERROR: Unknown command: ${cmd}`, 'var(--error-color)');
                    }
                    break;
            }
            promptInput.value = '';
        }

        promptInput.addEventListener('keydown', (e) => {
            if (!isLoggedIn) return;
            if (e.key === 'Enter') {
                processCommand(promptInput.value);
            } else if (e.key === 'ArrowUp') {
                if (historyIndex > 0) {
                    historyIndex--;
                    promptInput.value = commandHistory[historyIndex] || '';
                }
                e.preventDefault();
            } else if (e.key === 'ArrowDown') {
                if (historyIndex < commandHistory.length - 1) {
                    historyIndex++;
                    promptInput.value = commandHistory[historyIndex];
                } else {
                    historyIndex = commandHistory.length;
                    promptInput.value = '';
                }
                e.preventDefault();
            }
        });

        loginUsername.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                loginPassword.focus();
            }
        });

        loginPassword.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                loginPasskey.focus();
            }
        });

        loginPasskey.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                attemptLogin();
            }
        });

        chatButton.addEventListener('click', () => {
            if (!isLoggedIn) {
                writeOutput('ERROR: Must be logged in to open chat.', 'var(--error-color)');
                return;
            }
            isChatOpen = !isChatOpen;
            chatWindow.style.display = isChatOpen ? 'block' : 'none';
            if (isChatOpen) {
                unreadMessages = 0;
                updateUnreadCount();
                updateUserList();
                chatInput.focus();
            }
        });

        chatInput.addEventListener('keydown', (e) => {
            if (!isChatOpen || !isLoggedIn) return;
            if (e.key === 'Enter' && chatInput.value.trim()) {
                const message = chatInput.value.trim();
                const msgDiv = document.createElement('div');
                const timestampSpan = document.createElement('span');
                timestampSpan.className = 'message-timestamp';
                timestampSpan.textContent = getMessageTimestamp();
                const contentSpan = document.createElement('span');
                contentSpan.className = 'message-content';
                contentSpan.textContent = `${authUsername}: ${message}`;
                msgDiv.appendChild(timestampSpan);
                msgDiv.appendChild(contentSpan);
                chatMessages.appendChild(msgDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
                chatInput.value = '';
                isUserTyping = false;
                updateUserList();
                setTimeout(() => {
                    const otherUser = Object.keys(USERS).find(u => u !== authUsername) || 'BEEF WELLINGTON';
                    const replyMsg = document.createElement('div');
                    const replyTimestamp = document.createElement('span');
                    replyTimestamp.className = 'message-timestamp';
                    replyTimestamp.textContent = getMessageTimestamp();
                    const replyContent = document.createElement('span');
                    replyContent.className = 'message-content';
                    replyContent.textContent = `${otherUser}: Received your message: "${message}"`;
                    replyMsg.appendChild(replyTimestamp);
                    replyMsg.appendChild(replyContent);
                    chatMessages.appendChild(replyMsg);
                    chatMessages.scrollTop = chatMessages.scrollHeight;
                    if (!isChatOpen && USER_STATUSES[authUsername] !== 'BUSY') {
                        unreadMessages++;
                        updateUnreadCount();
                    }
                }, 1000);
            } else if (e.key !== 'Enter') {
                isUserTyping = chatInput.value.trim() !== '';
                updateUserList();
            }
        });

        startCallButton.addEventListener('click', startCall);
        toggleCameraButton.addEventListener('click', toggleCamera);
        toggleMicrophoneButton.addEventListener('click', toggleMicrophone);
        toggleScreenButton.addEventListener('click', toggleScreenShare);
        showParticipantsButton.addEventListener('click', () => {
            callParticipantsList.style.display = callParticipantsList.style.display === 'block' ? 'none' : 'block';
        });

        setInterval(simulateOtherTyping, 5000);
        setInterval(simulateStatusUpdates, 10000);

        window.onload = function() {
            // Ensure windows are hidden
            chatWindow.style.display = 'none';
            callWindow.style.display = 'none';
            callParticipantsList.style.display = 'none';
            // Initialize sounds silently
            SOUND_COMMAND_NAMES.concat(['RINGING']).forEach(key => loadSound(key));
            document.body.addEventListener('click', () => { Tone.context.resume(); }, { once: true });
            document.body.addEventListener('keydown', () => { Tone.context.resume(); }, { once: true });
            Object.keys(USERS).forEach(user => {
                if (!USER_STATUSES[user]) {
                    USER_STATUSES[user] = 'ONLINE';
                }
            });
            showLoginModal();
        };

        if ('Notification' in window && Notification.permission !== 'granted') {
            Notification.requestPermission();
        }
    </script>
</body>
</html>
