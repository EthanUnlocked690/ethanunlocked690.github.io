<!DOCTYPE html>
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATLAS: DATA FLOW CONSOLE v8.3 (Security &amp; Gaming)</title>
    <link href="./ATLAS_ DATA FLOW CONSOLE v8.3 (Security &amp; Gaming)_files/css2" rel="stylesheet">
    <script src="./ATLAS_ DATA FLOW CONSOLE v8.3 (Security &amp; Gaming)_files/Tone.min.js.download"></script>

    <style>
        :root {
            --terminal-color: #00ff41;
            --terminal-background-color: #000;
            --border-color: #00ff41;
            --prompt-caret: #ffaa00;
            --error-color: #ff0000;
            --highlight-color: #00aaff;
            --game-color: #ffffff;
            --reaction-smile: #ffff00;
            --reaction-thumbsup: #00ff41;
            --reaction-heart: #ff0000;
            --reaction-surprised: #00aaff;
            --reaction-sad: #00ffff;
            --accept-button: #00ff41;
            --decline-button: #ff0000;
            --leave-button: #ffaa00;
        }

        body {
            background-color: var(--terminal-background-color);
            font-family: 'VT323', monospace;
            color: var(--terminal-color);
            font-size: 1.1rem;
            line-height: 1.4;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #terminal-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(0deg, var(--terminal-color)33, var(--terminal-color)33 1px, #000 1px, #000 3px);
            pointer-events: none;
            z-index: 0;
            opacity: 0.15;
            animation: flicker 10s infinite alternate;
        }

        @keyframes flicker {
            0% { opacity: 0.15; }
            50% { opacity: 0.1; }
            100% { opacity: 0.2; }
        }

        #console-container {
            width: 90%;
            max-width: 1200px;
            height: 90vh;
            background-color: #111;
            border: 2px solid var(--border-color);
            box-shadow: 0 0 20px var(--terminal-color);
            padding: 20px;
            overflow: hidden;
            z-index: 1;
            display: flex;
            flex-direction: column;
            border-radius: 8px;
            display: none;
        }

        #console-header {
            flex-shrink: 0;
            padding-bottom: 10px;
            margin-bottom: 10px;
            border-bottom: 1px dashed var(--highlight-color);
            font-size: 1.2rem;
            color: var(--highlight-color);
            white-space: pre;
        }

        #terminal-output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            padding-bottom: 10px;
            scrollbar-width: none;
        }

        #terminal-output::-webkit-scrollbar {
            display: none;
        }

        #command-line {
            display: flex;
            align-items: center;
            flex-shrink: 0;
            margin-top: 10px;
        }

        #prompt {
            color: var(--prompt-caret);
            margin-right: 5px;
            white-space: nowrap;
        }

        #command-input {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: var(--terminal-color);
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            outline: none;
            caret-color: var(--terminal-color);
            padding: 0;
        }

        #login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #login-card {
            border: 3px solid var(--error-color);
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.8);
            padding: 30px;
            background-color: #111;
            text-align: center;
            max-width: 400px;
            width: 90%;
            border-radius: 5px;
        }

        .login-field {
            margin-bottom: 20px;
            text-align: left;
        }

        .login-field label {
            display: block;
            margin-bottom: 5px;
            color: var(--prompt-caret);
        }

        .login-field input {
            width: 100%;
            padding: 10px;
            background-color: #000;
            border: 1px solid var(--error-color);
            color: var(--prompt-caret);
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            box-sizing: border-box;
            outline: none;
        }

        #passkey {
            max-width: 50%;
        }

        #login-button {
            background-color: var(--error-color);
            color: #fff;
            border: 2px solid var(--error-color);
            padding: 10px 20px;
            cursor: pointer;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            transition: background-color 0.2s, box-shadow 0.2s;
            width: 100%;
            border-radius: 4px;
        }

        #login-button:hover {
            background-color: #cc0000;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
        }

        #login-status {
            color: var(--prompt-caret);
            margin-top: 15px;
            min-height: 1.5rem;
        }

        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.98);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 200;
            color: var(--terminal-color);
        }

        #loading-logo {
            font-size: 5rem;
            color: var(--highlight-color);
            animation: glitch 1.5s infinite alternate;
            margin-bottom: 20px;
        }

        @keyframes glitch {
            0% { text-shadow: 0 0 1px var(--error-color), 0 0 5px var(--highlight-color); transform: skew(0.5deg); }
            50% { text-shadow: 0 0 1px var(--terminal-color), 0 0 5px var(--prompt-caret); transform: skew(-0.5deg); }
            100% { text-shadow: 0 0 1px var(--highlight-color), 0 0 5px var(--error-color); transform: skew(0deg); }
        }

        /* Game overlay + canvas styling */
        #game-overlay {
            position: fixed;
            z-index: 300;
            inset: 0;
            display: none;
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.85);
            flex-direction: column;
            padding: 20px;
        }
        #game-container {
            border: 2px solid var(--highlight-color);
            padding: 12px;
            background: #000;
            box-shadow: 0 0 20px var(--terminal-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 95%;
            max-height: 90%;
        }
        #game-canvas {
            background: linear-gradient(180deg,#050505, #111 60%);
            border: 1px solid var(--border-color);
            display: block;
        }
        #game-controls {
            margin-top: 8px;
            color: var(--prompt-caret);
            font-family: 'VT323', monospace;
        }
        .game-btn {
            background: var(--highlight-color);
            color: #000;
            border: none;
            padding: 6px 10px;
            margin-left: 8px;
            cursor: pointer;
            border-radius: 4px;
            font-family: 'VT323', monospace;
        }
        .game-btn:hover { filter: brightness(1.1); }

    </style>
</head>
<body>
    <div id="terminal-background"></div>

    <div id="login-overlay" style="display: flex;">
        <div id="login-card">
            <h2 style="color: var(--error-color); margin-top: 0; margin-bottom: 20px;">ATLAS ACCESS PROTOCOL</h2>
            <p style="color: var(--prompt-caret); font-size: 1rem;">STATUS: Three-Factor Authentication Required.</p>
            <form id="login-form">
                <div class="login-field">
                    <label for="username">USERNAME:</label>
                    <input type="text" id="username" required="">
                </div>
                <div class="login-field">
                    <label for="password">PASSWORD:</label>
                    <input type="password" id="password" required="">
                </div>
                <div class="login-field">
                    <label for="passkey">PASSKEY (4 DIGITS):</label>
                    <input type="text" id="passkey" required="" maxlength="4">
                </div>
                <button type="button" id="login-button">INITIATE ACCESS SEQUENCE</button>
            </form>
            <div id="login-status">Awaiting Authentication...</div>
        </div>
    </div>

    <div id="loading-screen">
        <div id="loading-logo">ATLAS_INIT</div>
        <div id="loading-text" style="color:var(--highlight-color);">Processing Authentication Handshake...</div>
    </div>

    <div id="console-container" style="display: none;">
        <div id="console-header">ATLAS_SYSTEM_OFFLINE</div>
        <div id="terminal-output"></div>
        <div id="command-line">
            <span id="prompt">LOGIN&gt; </span>
            <input type="text" id="command-input" autocomplete="off" spellcheck="false" placeholder="Enter command...">
        </div>
    </div>

    <!-- Game Overlay (hidden until a game is started) -->
    <div id="game-overlay" aria-hidden="true">
        <div id="game-container">
            <canvas id="game-canvas" width="640" height="360"></canvas>
            <div id="game-controls">
                <span id="game-title" style="color:var(--highlight-color);">GAME</span>
                <button id="game-exit" class="game-btn">EXIT</button>
                <button id="game-pause" class="game-btn">PAUSE</button>
            </div>
        </div>
    </div>

<script>
// ---------- GLOBAL STATE ----------
let authUsername = '';
let userType = '';
let isLoggedIn = false;
let failedAttempts = 0;
let isLockedDown = false;
let audioPlayers = {}; // wrapper objects: { type: 'tone'|'html', instance, loop, state }
let timeUpdateInterval = null;

// Minimal stub still used by lockdown/logout
function stopIncomingInterval() { /* no-op */ }

// DOM references
const loginModal = document.getElementById('login-overlay');
const passwordInput = document.getElementById('password');
const keyInput = document.getElementById('passkey');
const loginError = document.getElementById('login-status');
const consoleContainer = document.getElementById('console-container');
const consoleOutput = document.getElementById('terminal-output');
const consoleInput = document.getElementById('command-input');
const timeDisplay = document.getElementById('console-header');
const commandPrompt = document.getElementById('prompt');
const loginButton = document.getElementById('login-button');

// Game overlay refs
const gameOverlay = document.getElementById('game-overlay');
const gameCanvas = document.getElementById('game-canvas');
const gameTitle = document.getElementById('game-title');
const gameExitBtn = document.getElementById('game-exit');
const gamePauseBtn = document.getElementById('game-pause');

let currentGame = null; // 'PONG' | 'SNAKE' | null
let gameLoopHandle = null;
let gamePaused = false;

// ---------- STATIC DATA ----------
const USERS = {
    'ETHANUNLOCKED': { password: 'h4cker', passkey: '1957', role: 'MANAGER', chatStatus: 'ONLINE' },
    'BEEF WELLINGTON': { password: 'Eat_me', passkey: '2251', role: 'ADMIN', chatStatus: 'ONLINE' },
    'GYATTMODEPLAYS': { password: 'justmyusername', passkey: '0000', role: 'ADMIN', chatStatus: 'ONLINE' },
    'USERNAME': { password: 'username', passkey: '2026', role: 'ADMIN', chatStatus: 'ONLINE' }
};

const SOUND_EFFECTS = {
    'SIREN': 'siren.mp3',
    'CONFIRM': 'confirm.mp3',
    'ALARM': 'alert.mp3',
    'GET OUT': 'GET.mp3',
    'VINE BOOM': 'vine-boom.mp3',
    'RIZZ': 'rizz.mp3',
    'YOUR IDOL': 'idol.mp3',
    'FART': 'fart.mp3',
    '6 7': '67.mp3',
    'GOLDEN': 'gold.mp3',
    'SODA POP': 'soda.mp3',
    'BRUH': 'bro.mp3',
    'SUI': 'sui.mp3',
    'JOHN CENA': 'cena.mp3',
    'PUMPKIN': 'pumpkin.mp3',
    'B+F': 'b.mp3',
    'BURP': 'burp.mp3',
    'FAH': 'fah.mp3',
    'FIRE IN THE HOLE': 'hole.mp3',
    'LAVA CHICKEN': 'lava.mp3',
    'I AM STEVE': 'steve.mp3',
    'RICKROLL': 'never.mp3',
    'GD - DASH': 'dash-full.mp3',
    'TUNG TUNG TUNG SAHUR': 'tung.mp3',
    'CLASH ROYALE': 'clash-royale.mp3',
    'UwU': 'uwu.mp3',
    'YES': 'yes.mp3',
    'NO': 'nope.mp3',
    'GEOMETRY DASH!': 'geometry-dash.mp3',
    'BRAWL STARS': 'brawl-stars.mp3',
    'LEON': 'leon.mp3'
};

// ---------- UTILITIES ----------
function writeOutput(text, color = 'var(--terminal-color)', isCommand = false) {
    const line = document.createElement('div');
    line.style.color = color;
    line.style.fontFamily = 'monospace';
    line.style.whiteSpace = 'pre-wrap';
    line.textContent = isCommand ? `${commandPrompt.textContent}${text}` : text;
    consoleOutput.appendChild(line);
    consoleOutput.scrollTop = consoleOutput.scrollHeight;
}

function clearOutput() {
    consoleOutput.innerHTML = '';
}

function showLoginModal() {
    loginModal.style.display = 'flex';
    consoleContainer.style.display = 'none';
    commandPrompt.textContent = 'LOGIN> ';
}

function hideLoginModal() {
    loginModal.style.display = 'none';
    loginError.textContent = '';
    const u = document.getElementById('username');
    if (u) u.value = '';
    passwordInput.value = '';
    keyInput.value = '';
}

// Format time display in header
const LOCATION = 'KOLLARNEY BAY SECURE NODE';
function getCurrentFormattedTime() {
    const now = new Date();
    const dayNames = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
    const monthNames = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];
    const day = dayNames[now.getDay()];
    const date = now.getDate().toString().padStart(2, '0');
    const month = monthNames[now.getMonth()];
    const year = now.getFullYear();
    let hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const seconds = now.getSeconds().toString().padStart(2, '0');
    const ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours.toString().padStart(2, '0') : '12';
    return `${day}, ${date}-${month}-${year} | ${hours}:${minutes}:${seconds} ${ampm} | LOCATION: ${LOCATION}`;
}

function updateHeaderDisplay() {
    timeDisplay.textContent = `[ ${getCurrentFormattedTime()} | USER: ${authUsername} ]`;
}

function stopTimeInterval() {
    if (timeUpdateInterval) {
        clearInterval(timeUpdateInterval);
        timeUpdateInterval = null;
        timeDisplay.textContent = 'ATLAS_SYSTEM_OFFLINE';
    }
}

function startTimeInterval() {
    stopTimeInterval();
    updateHeaderDisplay();
    timeUpdateInterval = setInterval(updateHeaderDisplay, 1000);
}

// ---------- AUDIO: normalization & map ----------
function normalizeSoundKey(s) {
    if (s === null || s === undefined) return '';
    return s.toString().trim().replace(/\s+/g, ' ').toUpperCase();
}

const SOUND_COMMAND_NAMES = Object.keys(SOUND_EFFECTS);
const SOUND_COMMAND_MAP = {};
SOUND_COMMAND_NAMES.forEach(name => {
    SOUND_COMMAND_MAP[normalizeSoundKey(name)] = name; // normalized -> canonical key
});

// Attempt to unlock/create an AudioContext and resume it. Aggressive fallback to HTMLAudio if necessary.
async function unlockAudio() {
    try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) {
            writeOutput('AudioContext API not available; using HTMLAudio fallback.', 'var(--prompt-caret)');
            return false;
        }

        // If Tone exists and has context, try to resume it
        if (window.Tone && Tone.context) {
            try {
                if (Tone.context.state === 'running') return true;
                if (Tone.context.state === 'suspended') {
                    await Tone.context.resume();
                    writeOutput('WEB AUDIO CONTEXT RESUMED (Tone).', 'var(--highlight-color)');
                    return true;
                }
            } catch (e) {
                // continue to create/assign a new context
            }
        }

        // Create a brand new context (or reuse existing) and try to resume it
        let ctx;
        try {
            ctx = new AC();
        } catch (e) {
            // couldn't create a new one; try to use existing Tone.context
            ctx = (window.Tone && Tone.context) || null;
        }

        if (!ctx) {
            writeOutput('Could not obtain AudioContext instance; will fallback to HTMLAudio.', 'var(--prompt-caret)');
            return false;
        }

        // Create a very short silent buffer and play it to "unlock" on some platforms
        try {
            const buffer = ctx.createBuffer(1, 1, ctx.sampleRate || 22050);
            const src = ctx.createBufferSource();
            src.buffer = buffer;
            src.connect(ctx.destination);
            if (typeof src.start === 'function') {
                try { src.start(0); } catch (e) { /* ignore */ }
            }
        } catch (e) {
            /* ignore */
        }

        if (ctx.state === 'suspended' && typeof ctx.resume === 'function') {
            try { await ctx.resume(); } catch (e) { /* ignore */ }
        }

        // If Tone exists, try to set its context (best-effort)
        if (window.Tone) {
            try { Tone.context = ctx; } catch (e) { /* ignore */ }
        }

        writeOutput('AudioContext: unlock attempted.', 'var(--highlight-color)');
        return ctx.state === 'running' || ctx.state === 'suspended';
    } catch (err) {
        writeOutput(`Audio unlock error: ${(err && err.message) ? err.message : err}`, 'var(--error-color)');
        return false;
    }
}

// Ensure AudioContext running (best-effort). Always returns true to allow fallback to HTMLAudio.
async function ensureAudioContextRunning() {
    // Try to resume existing Tone context if possible
    if (window.Tone && Tone.context) {
        try {
            if (Tone.context.state === 'running') return true;
            if (Tone.context.state === 'suspended' && typeof Tone.context.resume === 'function') {
                await Tone.context.resume();
                writeOutput('WEB AUDIO CONTEXT RESUMED (Tone).', 'var(--highlight-color)');
                return true;
            }
        } catch (e) {
            // fallthrough to unlock attempt
        }
    }

    // Attempt to unlock/create an AudioContext
    await unlockAudio();

    // Always return true to allow HTMLAudio fallback paths to run
    return true;
}

// Load sound (returns wrapper object). Wrapper API: { play(loop), stop(), loop }
async function loadSound(originalName) {
    const filePath = SOUND_EFFECTS[originalName];
    if (!filePath) {
        writeOutput(`ERROR: No sound file configured for "${originalName}".`, 'var(--error-color)');
        throw new Error('No file');
    }

    // Return existing wrapper if already created
    if (audioPlayers[originalName]) return audioPlayers[originalName];

    // Prefer Tone.Player if Tone is available and workable
    if (window.Tone) {
        try {
            const player = new Tone.Player({url: filePath, autostart: false}).toDestination();
            player.loop = false;
            // Attempt to load (some Tone builds auto-load)
            try { await player.load(); } catch (e) { /* ignore load errors; file may stream */ }
            const wrapper = {
                type: 'tone',
                instance: player,
                loop: false,
                async play(loop = false) {
                    this.loop = !!loop;
                    try {
                        player.loop = !!loop;
                        // restart if already playing
                        if (player.state === 'started') {
                            player.stop();
                        }
                        player.start();
                        this.state = 'started';
                    } catch (err) {
                        this.state = 'stopped';
                        throw err;
                    }
                },
                stop() {
                    try { player.stop(); } catch (e) {}
                    this.state = 'stopped';
                },
                state: 'stopped'
            };
            audioPlayers[originalName] = wrapper;
            return wrapper;
        } catch (err) {
            // Tone failed; fallback to HTMLAudio below
        }
    }

    // HTMLAudio fallback
    try {
        const audio = new Audio(filePath);
        audio.preload = 'auto';
        audio.loop = false;
        // For iOS Safari it's helpful to set playsInline
        audio.playsInline = true;
        const wrapper = {
            type: 'html',
            instance: audio,
            loop: false,
            async play(loop = false) {
                this.loop = !!loop;
                audio.loop = !!loop;
                try {
                    audio.currentTime = 0;
                } catch (e) { /* ignore */ }
                const p = audio.play();
                if (p && p.then) {
                    await p;
                }
                this.state = 'started';
            },
            stop() {
                try { audio.pause(); audio.currentTime = 0; } catch (e) {}
                this.state = 'stopped';
            },
            state: 'stopped'
        };
        audioPlayers[originalName] = wrapper;
        return wrapper;
    } catch (err) {
        writeOutput(`ERROR: Could not create audio element for ${originalName}: ${(err && err.message) ? err.message : err}`, 'var(--error-color)');
        throw err;
    }
}

// Play sound by name or user-typed input (handles multi-word and lowercase)
async function playSound(nameOrInput, loop = false) {
    const normalized = normalizeSoundKey(nameOrInput);
    const originalName = SOUND_COMMAND_MAP[normalized] || (typeof nameOrInput === 'string' ? nameOrInput.toUpperCase() : '');

    if (!SOUND_EFFECTS[originalName]) {
        writeOutput(`ERROR: Unknown sound "${nameOrInput}". Type SOUNDS for a list.`, 'var(--error-color)');
        return;
    }

    // Try to ensure audio subsystem is available (best-effort)
    await ensureAudioContextRunning();

    try {
        const wrapper = await loadSound(originalName);
        try {
            await wrapper.play(loop);
            writeOutput(`SOUND TRIGGERED: ${originalName}`, 'var(--highlight-color)');
        } catch (playErr) {
            // If play failed for Tone, try HTMLAudio fallback
            writeOutput(`Warning: primary player failed for ${originalName}: ${(playErr && playErr.message) ? playErr.message : playErr}`, 'var(--prompt-caret)');
            // Attempt HTMLAudio fallback
            try {
                const audio = new Audio(SOUND_EFFECTS[originalName]);
                audio.preload = 'auto';
                audio.loop = !!loop;
                audio.playsInline = true;
                const p = audio.play();
                if (p && p.then) await p;
                writeOutput(`SOUND TRIGGERED (fallback): ${originalName}`, 'var(--highlight-color)');
            } catch (fallbackErr) {
                writeOutput(`ERROR: Could not play sound ${originalName}: ${(fallbackErr && fallbackErr.message) ? fallbackErr.message : fallbackErr}`, 'var(--error-color)');
            }
        }
    } catch (err) {
        writeOutput(`ERROR: Could not load sound ${originalName}: ${(err && err.message) ? err.message : err}`, 'var(--error-color)');
    }
}

function stopSound(name) {
    const normalized = normalizeSoundKey(name);
    const originalName = SOUND_COMMAND_MAP[normalized] || (typeof name === 'string' ? name.toUpperCase() : name);
    const wrapper = audioPlayers[originalName];
    if (wrapper && typeof wrapper.stop === 'function') {
        wrapper.stop();
        writeOutput(`SOUND STOPPED: ${originalName}`, 'var(--prompt-caret)');
    } else {
        writeOutput(`No active sound named "${name}" found.`, 'var(--prompt-caret)');
    }
}

// ---------- MINI-GAMES (PONG + SNAKE) ----------

// Helpers: show/hide overlay, keyboard captures
function showGameOverlay(title = 'GAME') {
    gameTitle.textContent = title;
    gameOverlay.style.display = 'flex';
    gameOverlay.setAttribute('aria-hidden', 'false');
    // Resize canvas to fit container width while keeping ratio
    const maxW = Math.min(window.innerWidth * 0.9, 900);
    const maxH = Math.min(window.innerHeight * 0.8, 600);
    const ratio = gameCanvas.width / gameCanvas.height;
    let w = maxW;
    let h = Math.round(w / ratio);
    if (h > maxH) { h = maxH; w = Math.round(h * ratio); }
    gameCanvas.style.width = w + 'px';
    gameCanvas.style.height = h + 'px';
}

function hideGameOverlay() {
    gameOverlay.style.display = 'none';
    gameOverlay.setAttribute('aria-hidden', 'true');
    stopGame();
}

// Pong implementation (simple)
function startPong() {
    stopGame();
    currentGame = 'PONG';
    showGameOverlay('PONG');
    const ctx = gameCanvas.getContext('2d');
    const W = 640, H = 360;
    gameCanvas.width = W; gameCanvas.height = H;

    let pa = { x: 10, y: H/2 - 30, w: 10, h: 60, dy: 0 };
    let pb = { x: W - 20, y: H/2 - 30, w: 10, h: 60, dy: 0 };
    let ball = { x: W/2, y: H/2, r: 6, dx: 3.5, dy: 2.5 };
    let scoreA = 0, scoreB = 0;

    const keys = {};
    function keyDown(e) { keys[e.key] = true; }
    function keyUp(e) { keys[e.key] = false; }

    function update() {
        // player A: W/S, player B: ArrowUp/ArrowDown
        pa.dy = (keys['w'] || keys['W']) ? -6 : (keys['s'] || keys['S']) ? 6 : 0;
        pb.dy = (keys['ArrowUp']) ? -6 : (keys['ArrowDown']) ? 6 : 0;
        pa.y += pa.dy; pb.y += pb.dy;
        pa.y = Math.max(0, Math.min(H - pa.h, pa.y));
        pb.y = Math.max(0, Math.min(H - pb.h, pb.y));

        ball.x += ball.dx; ball.y += ball.dy;
        if (ball.y - ball.r < 0 || ball.y + ball.r > H) ball.dy *= -1;

        // collisions
        if (ball.x - ball.r < pa.x + pa.w && ball.y > pa.y && ball.y < pa.y + pa.h) {
            ball.dx = Math.abs(ball.dx) + 0.2;
            ball.dx *= -1;
            ball.dy += (Math.random() - 0.5);
            playSound('CONFIRM').catch(()=>{});
        }
        if (ball.x + ball.r > pb.x && ball.y > pb.y && ball.y < pb.y + pb.h) {
            ball.dx = -Math.abs(ball.dx) - 0.2;
            ball.dy += (Math.random() - 0.5);
            playSound('CONFIRM').catch(()=>{});
        }

        if (ball.x < 0) { scoreB++; resetBall(); }
        if (ball.x > W) { scoreA++; resetBall(); }
    }

    function resetBall() {
        ball.x = W/2; ball.y = H/2;
        ball.dx = (Math.random() > 0.5 ? 3.5 : -3.5);
        ball.dy = (Math.random() - 0.5) * 3;
    }

    function render() {
        ctx.clearRect(0,0,W,H);
        // midline
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(W/2 - 2, 0, 4, H);
        // paddles
        ctx.fillStyle = '#00ff41';
        ctx.fillRect(pa.x, pa.y, pa.w, pa.h);
        ctx.fillRect(pb.x, pb.y, pb.w, pb.h);
        // ball
        ctx.beginPath();
        ctx.fillStyle = '#ffaa00';
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2);
        ctx.fill();
        // scores
        ctx.fillStyle = '#00aaff'; ctx.font = '28px VT323, monospace';
        ctx.fillText(scoreA.toString(), W/2 - 70, 40);
        ctx.fillText(scoreB.toString(), W/2 + 46, 40);
    }

    function loop() {
        if (gamePaused || currentGame !== 'PONG') return;
        update();
        render();
        gameLoopHandle = requestAnimationFrame(loop);
    }

    function start() {
        window.addEventListener('keydown', keyDown);
        window.addEventListener('keyup', keyUp);
        gamePaused = false;
        loop();
    }

    function stop() {
        window.removeEventListener('keydown', keyDown);
        window.removeEventListener('keyup', keyUp);
        cancelAnimationFrame(gameLoopHandle);
        gameLoopHandle = null;
    }

    // expose stop/controls
    currentGame = { name: 'PONG', stop, pause: () => { gamePaused = !gamePaused; } };
    start();
}

// Snake implementation (simple)
function startSnake() {
    stopGame();
    currentGame = 'SNAKE';
    showGameOverlay('SNAKE');
    const ctx = gameCanvas.getContext('2d');
    const tile = 16;
    const cols = 40;
    const rows = 22;
    gameCanvas.width = cols * tile;
    gameCanvas.height = rows * tile;

    let snake = [{x:10,y:10}];
    let dir = {x:1, y:0};
    let apple = {x:15, y:10};
    let speed = 6; // ticks per second
    let tickCounter = 0;
    const keys = {};

    function keyDown(e) { keys[e.key] = true; }
    function keyUp(e) { keys[e.key] = false; }

    function spawnApple() {
        apple.x = Math.floor(Math.random()*cols);
        apple.y = Math.floor(Math.random()*rows);
    }

    function update() {
        // directional input
        if (keys['ArrowLeft'] && dir.x === 0) dir = {x:-1,y:0};
        if (keys['ArrowRight'] && dir.x === 0) dir = {x:1,y:0};
        if (keys['ArrowUp'] && dir.y === 0) dir = {x:0,y:-1};
        if (keys['ArrowDown'] && dir.y === 0) dir = {x:0,y:1};

        const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};
        // wrap
        head.x = (head.x + cols) % cols;
        head.y = (head.y + rows) % rows;
        // collision
        for (let i=0;i<snake.length;i++){
            if (snake[i].x===head.x && snake[i].y===head.y) {
                // game over
                writeOutput('SNAKE: Collision detected. Game over.', 'var(--error-color)');
                playSound('ALARM').catch(()=>{});
                stopGame();
                return;
            }
        }
        snake.unshift(head);
        if (head.x === apple.x && head.y === apple.y) {
            // eat
            spawnApple();
            playSound('CONFIRM').catch(()=>{});
        } else {
            snake.pop();
        }
    }

    function render() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,gameCanvas.width, gameCanvas.height);
        // apple
        ctx.fillStyle = '#ff5555';
        ctx.fillRect(apple.x*tile, apple.y*tile, tile, tile);
        // snake
        ctx.fillStyle = '#00ff41';
        for (const s of snake) ctx.fillRect(s.x*tile, s.y*tile, tile-1, tile-1);
    }

    function loop(ts) {
        if (gamePaused || currentGame !== 'SNAKE') return;
        gameLoopHandle = requestAnimationFrame(loop);
        tickCounter++;
        const ticksPerFrame = Math.max(1, Math.round(60 / speed));
        if (tickCounter % ticksPerFrame === 0) {
            update();
            render();
        }
    }

    function start() {
        window.addEventListener('keydown', keyDown);
        window.addEventListener('keyup', keyUp);
        spawnApple();
        gamePaused = false;
        loop();
    }

    function stop() {
        window.removeEventListener('keydown', keyDown);
        window.removeEventListener('keyup', keyUp);
        cancelAnimationFrame(gameLoopHandle);
        gameLoopHandle = null;
    }

    currentGame = { name: 'SNAKE', stop, pause: () => { gamePaused = !gamePaused; } };
    start();
}

function stopGame() {
    if (currentGame && typeof currentGame === 'object' && typeof currentGame.stop === 'function') {
        try { currentGame.stop(); } catch (e) {}
    }
    currentGame = null;
    cancelAnimationFrame(gameLoopHandle);
    gameLoopHandle = null;
    hideGameOverlay();
}

// game controls UI
gameExitBtn.addEventListener('click', () => { hideGameOverlay(); });
gamePauseBtn.addEventListener('click', () => {
    if (currentGame && currentGame.pause) currentGame.pause();
    gamePauseBtn.textContent = gamePaused ? 'RESUME' : 'PAUSE';
    gamePaused = !gamePaused;
});

// ---------- COMMAND PROCESSING ----------
function initiateLockdown(reason) {
    if (isLockedDown) return;
    isLockedDown = reason || 'UNKNOWN';
    stopIncomingInterval();
    // don't rely on unavailable sound names
    try { playSound('ALARM').catch(()=>{}); } catch(e){}
    writeOutput('----------------------------------------------------', 'var(--error-color)');
    writeOutput(`!!! CRITICAL ALERT: SYSTEM LOCKDOWN INITIATED !!!`, 'var(--error-color)');
    writeOutput(`REASON: ${reason}`, 'var(--error-color)');
    writeOutput('ALL ACCESS RESTRICTED. CONTACT SECURITY ADMIN.', 'var(--error-color)');
    writeOutput('----------------------------------------------------', 'var(--error-color)');
    commandPrompt.textContent = 'LOCKED> ';
}

async function processCommand(command) {
    if (isLockedDown) {
        writeOutput(`ERROR: SYSTEM LOCKED DOWN. Reason: ${isLockedDown}`, 'var(--error-color)', true);
        return;
    }
    if (!isLoggedIn) {
        writeOutput('ERROR: NOT LOGGED IN.', 'var(--error-color)', true);
        return;
    }

    const raw = command || '';
    const trimmed = raw.trim();
    const normalizedInput = normalizeSoundKey(trimmed);
    const parts = normalizedInput.split(/\s+/).filter(Boolean);
    const cmd = parts[0] || '';
    const args = parts.slice(1);

    writeOutput(command, 'var(--terminal-color)', true);

    // If full normalized input matches a sound name, play it
    if (SOUND_COMMAND_MAP[normalizedInput]) {
        playSound(normalizedInput);
        return;
    }

    switch (cmd) {
        case 'HELP':
            writeOutput('=== ATLAS COMMAND DIRECTORY ===', 'var(--highlight-color)');
            writeOutput('', 'var(--terminal-color)');
            writeOutput('--- SYSTEM COMMANDS ---', 'var(--highlight-color)');
            writeOutput('  HELP             - Display this command directory', 'var(--terminal-color)');
            writeOutput('  COMMANDS         - List all available system commands', 'var(--terminal-color)');
            writeOutput('  SOUNDS           - List all available sound effects', 'var(--terminal-color)');
            writeOutput('  CLEAR            - Clear the console output', 'var(--terminal-color)');
            writeOutput('  LOGOUT           - Log out and return to login screen', 'var(--terminal-color)');
            writeOutput('  LOCKDOWN <TEXT>  - Initiate system-wide lockdown', 'var(--terminal-color)');
            writeOutput('  INIT AUDIO       - Initialize Web Audio Context', 'var(--terminal-color)');
            writeOutput('  ECHO <TEXT>      - Repeat the text input', 'var(--terminal-color)');
            writeOutput('  GAMES            - List playable legacy games', 'var(--terminal-color)');
            writeOutput('  PONG / SNAKE     - Start an embedded game', 'var(--terminal-color)');
            writeOutput('  HACK <TARGET>    - Simulate a \"hack\" demo log', 'var(--terminal-color)');
            writeOutput('  SCAN <IP>        - Fake port scan output (fun)', 'var(--terminal-color)');
            writeOutput('  TRACE <HOST>     - Simulated traceroute', 'var(--terminal-color)');
            writeOutput('  LOOP <SOUND>     - Play a sound in loop mode', 'var(--terminal-color)');
            writeOutput('  STOP SOUND <NAME> - Stop a looping sound', 'var(--terminal-color)');
            writeOutput('', 'var(--terminal-color)');
            writeOutput('Type COMMANDS or SOUNDS for detailed listings.', 'var(--prompt-caret)');
            writeOutput('Tip: To play a sound, type JUST THE SOUND NAME (e.g., SIREN) and press Enter. Multi-word names work too (e.g., GET OUT).', 'var(--prompt-caret)');
            break;

        case 'COMMANDS':
            writeOutput('=== SYSTEM COMMANDS LIST ===', 'var(--highlight-color)');
            writeOutput('', 'var(--terminal-color)');
            writeOutput('1.  HELP             - Display command directory', 'var(--terminal-color)');
            writeOutput('2.  COMMANDS         - Show this list', 'var(--terminal-color)');
            writeOutput('3.  SOUNDS           - Show all sound effects', 'var(--terminal-color)');
            writeOutput('4.  CLEAR            - Clear console output', 'var(--terminal-color)');
            writeOutput('5.  LOGOUT           - Log out of system', 'var(--terminal-color)');
            writeOutput('6.  LOCKDOWN <TEXT>  - Initiate lockdown protocol', 'var(--terminal-color)');
            writeOutput('7.  INIT AUDIO       - Enable sound system', 'var(--terminal-color)');
            writeOutput('8.  ECHO <TEXT>      - Echo text to console', 'var(--terminal-color)');
            writeOutput('9.  GAMES            - Show playable legacy games', 'var(--terminal-color)');
            writeOutput('10. PONG / SNAKE     - Launch classic arcade games', 'var(--terminal-color)');
            writeOutput('', 'var(--terminal-color)');
            writeOutput('Total Commands: 10', 'var(--prompt-caret)');
            break;

        case 'SOUNDS':
            writeOutput('=== AVAILABLE SOUND EFFECTS ===', 'var(--highlight-color)');
            writeOutput('', 'var(--terminal-color)');
            writeOutput('To play a sound, type JUST THE SOUND NAME (exact text). Case and spacing do not matter.', 'var(--prompt-caret)');
            SOUND_COMMAND_NAMES.forEach((orig, i) => {
                writeOutput(`  ${i + 1}. ${orig}`, 'var(--terminal-color)');
            });
            break;

        case 'CLEAR':
            clearOutput();
            break;

        case 'LOGOUT':
            writeOutput('LOGGING OUT...', 'var(--highlight-color)');
            setTimeout(() => {
                authUsername = '';
                isLoggedIn = false;
                isLockedDown = false;
                stopIncomingInterval();
                showLoginModal();
                clearOutput();
                stopTimeInterval();
            }, 1000);
            break;

        case 'LOCKDOWN':
            const reason = args.join(' ') || 'UNKNOWN THREAT';
            initiateLockdown(reason);
            break;

        case 'INIT':
            if (args[0] === 'AUDIO') {
                ensureAudioContextRunning().then(() => {
                    writeOutput('WEB AUDIO CONTEXT RESUMED. Loading sound files...', 'var(--highlight-color)');
                    SOUND_COMMAND_NAMES.forEach(key => loadSound(key).catch(()=>{}));
                });
            } else {
                writeOutput('ERROR: Unknown command. Type HELP for a list of commands.', 'var(--error-color)');
            }
            break;

        case 'ECHO':
            writeOutput(args.join(' '), 'var(--game-color)');
            break;

        // New game-related commands:
        case 'GAMES':
            writeOutput('=== LEGACY GAMES ===', 'var(--highlight-color)');
            writeOutput('  PONG        - Classic two-player pong (W/S and Up/Down)', 'var(--terminal-color)');
            writeOutput('  SNAKE       - Retro snake. Arrow keys to move.', 'var(--terminal-color)');
            writeOutput('To start a game, type its name (e.g., PONG). Type EXIT in-game to return.', 'var(--prompt-caret)');
            break;

        case 'PONG':
            writeOutput('Launching PONG. Controls: W/S (left) | Up/Down (right). Close with EXIT or click EXIT button.', 'var(--prompt-caret)');
            startPong();
            break;

        case 'SNAKE':
            writeOutput('Launching SNAKE. Controls: Arrow keys. Close with EXIT or click EXIT button.', 'var(--prompt-caret)');
            startSnake();
            break;

        // Fun simulation commands
        case 'HACK':
            {
                const target = args.join(' ') || 'REMOTE_HOST';
                writeOutput(`Initiating simulated exploit chain against ${target}...`, 'var(--highlight-color)');
                // print a series of "hacker-y" logs
                const steps = [
                    `Resolving ${target}...`,
                    `Found open ports: 22, 80, 443, 1337`,
                    `Brute forcing creds...`,
                    `Obtaining shell...`,
                    `Escalating privileges...`,
                    `Dropping beacons...`,
                    `EXFILTRATING DATA...`,
                    `CLEANING LOGS...`,
                    `ACCESS GRANTED - ${target}`
                ];
                (async () => {
                    for (const s of steps) {
                        writeOutput(s, 'var(--terminal-color)');
                        await new Promise(r => setTimeout(r, 600 + Math.random()*800));
                    }
                    playSound('RIZZ').catch(()=>{});
                })();
            }
            break;

        case 'SCAN':
        case 'NMAP':
            {
                const target = args[0] || '192.168.0.1';
                writeOutput(`Running quick scan on ${target}...`, 'var(--highlight-color)');
                const fakePorts = [
                    {port:22, proto:'tcp', state:'open', svc:'ssh'},
                    {port:80, proto:'tcp', state:'open', svc:'http'},
                    {port:443, proto:'tcp', state:'open', svc:'https'},
                    {port:3306, proto:'tcp', state:'closed', svc:'mysql'},
                    {port:8080, proto:'tcp', state:'open', svc:'http-proxy'}
                ];
                (async () => {
                    for (const p of fakePorts) {
                        writeOutput(`${p.port}/tcp ${p.state} ${p.svc}`, 'var(--terminal-color)');
                        await new Promise(r => setTimeout(r, 300 + Math.random()*300));
                    }
                    writeOutput('Scan complete. (simulated)', 'var(--prompt-caret)');
                })();
            }
            break;

        case 'TRACE':
        case 'TRACEROUTE':
            {
                const host = args[0] || 'example.com';
                writeOutput(`Tracing route to ${host}...`, 'var(--highlight-color)');
                const hops = [
                    '10.0.0.1', '172.16.0.1', '203.0.113.5',
                    '198.51.100.22', '93.184.216.34'
                ];
                (async () => {
                    let i = 1;
                    for (const h of hops) {
                        writeOutput(`${i}\t${h}\t${(20 + Math.floor(Math.random()*30))} ms`, 'var(--terminal-color)');
                        i++; await new Promise(r => setTimeout(r, 250 + Math.random()*400));
                    }
                    writeOutput('Trace complete (simulated).', 'var(--prompt-caret)');
                })();
            }
            break;

        case 'LOOP':
            {
                const soundName = args.join(' ');
                if (!soundName) { writeOutput('LOOP <SOUNDNAME> - play a sound in loop mode.', 'var(--prompt-caret)'); break; }
                const normalized = normalizeSoundKey(soundName);
                const canonical = SOUND_COMMAND_MAP[normalized] || soundName.toUpperCase();
                playSound(canonical, true).catch(()=>{});
            }
            break;

        case 'STOP':
            if (args[0] === 'SOUND') {
                const name = args.slice(1).join(' ');
                if (!name) { writeOutput('STOP SOUND <NAME> - stop a named sound.', 'var(--prompt-caret)'); break; }
                stopSound(name);
            } else if (args[0] === 'ALL') {
                Object.keys(audioPlayers).forEach(k => stopSound(k));
                writeOutput('All sounds stopped.', 'var(--prompt-caret)');
            } else {
                writeOutput('Unknown STOP usage. Try: STOP SOUND <NAME> or STOP ALL', 'var(--prompt-caret)');
            }
            break;

        default:
            writeOutput('ERROR: Unknown command. Type HELP for a list of commands.', 'var(--error-color)');
    }
}

// ---------- LOGIN HANDLER ----------
async function handleLoginAttempt(event) {
    event && event.preventDefault && event.preventDefault();

    const username = document.getElementById('username').value.trim().toUpperCase();
    const password = passwordInput.value;
    const key = keyInput.value;
    let success = false;
    let targetUser = null;

    for (const userKey in USERS) {
        const user = USERS[userKey];
        if (username === userKey && password === user.password && key === user.passkey) {
            authUsername = userKey;
            userType = user.role;
            targetUser = user;
            success = true;
            break;
        }
    }

    document.getElementById('loading-screen').style.display = 'flex';
    await new Promise(resolve => setTimeout(resolve, 1000));
    document.getElementById('loading-screen').style.display = 'none';

    if (!success) {
        failedAttempts++;
        loginError.textContent = 'AUTHENTICATION FAILURE. ACCESS DENIED.';
        // try to play a failure sound, but failure should not break if audio is blocked
        playSound('ALARM').catch(()=>{});
        return;
    }

    // Successful login
    isLoggedIn = true;
    hideLoginModal();
    clearOutput();
    consoleContainer.style.display = 'flex';
    commandPrompt.textContent = 'ATLAS> ';
    writeOutput(`Welcome ${authUsername}.`, 'var(--highlight-color)');
    startTimeInterval();

    // Attempt to preload basic audio after a user gesture (we have one now)
    ensureAudioContextRunning().then(() => {
        // optionally preload common sounds
        ['SIREN','CONFIRM','LAVA CHICKEN','I AM STEVE','RICKROLL'].forEach(k => loadSound(k).catch(()=>{}));
    });
}

// ---------- USER INTERACTIONS ----------
loginButton.addEventListener('click', handleLoginAttempt);

consoleInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        const v = consoleInput.value;
        if (!v.trim()) { consoleInput.value = ''; return; }
        processCommand(v);
        consoleInput.value = '';
    }
});

// Enable clicking or keydown anywhere to help resume audio in restrictive browsers
async function userGestureUnlock() {
    try {
        await ensureAudioContextRunning();
    } catch (e) {}
    // remove listeners after first successful attempt to avoid spamming
    document.body.removeEventListener('click', userGestureUnlock);
    document.body.removeEventListener('keydown', userGestureUnlock);
}
document.body.addEventListener('click', userGestureUnlock);
document.body.addEventListener('keydown', userGestureUnlock);

// Initialize
showLoginModal();
</script>
</body>
</html>
