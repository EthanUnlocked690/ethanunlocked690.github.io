<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATLAS: DATA FLOW CONSOLE v4.0 (HIGH-LEVEL ACCESS)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <style>
        /* General Console Theme */
        body {
            background-color: #000;
            font-family: 'VT323', monospace;
            color: #00ff41; /* Console Green */
            font-size: 1.1rem;
            line-height: 1.4;
        }

        /* Simulated CRT/Scanline Effect */
        body::before {
            content: "";
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            background: repeating-linear-gradient(
                #000, 
                #000 1px, 
                rgba(0, 255, 65, 0.08) 2px, 
                #000 3px
            );
            opacity: 0.8;
            z-index: -1;
        }

        .console-container {
            border: 3px solid #00ff41;
            box-shadow: 0 0 10px #00ff41;
            height: 95vh;
            display: flex;
            flex-direction: column;
            margin: 10px auto;
            max-width: 1000px;
        }

        /* Output Area */
        #output-area {
            flex-grow: 1;
            overflow-y: auto;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.9);
            white-space: pre-wrap; /* Preserve formatting for dynamic text */
        }

        /* Input Area */
        #input-line {
            padding: 1rem;
            border-top: 1px solid #00ff41;
            display: flex;
        }

        #input-prefix {
            color: #ff00ff; /* Magenta for the prompt */
        }

        #command-input {
            background: transparent;
            border: none;
            color: #00ff41;
            flex-grow: 1;
            outline: none;
            margin-left: 5px;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
        }

        /* Status Bar */
        #status-bar {
            background: #004d1a;
            color: #fff;
            padding: 0.5rem 1rem;
            text-align: right;
            font-size: 0.9rem;
        }

        /* SCAN - Lie Detector Simulation */
        #lie-detector-panel {
            background-color: #111;
            border: 2px solid #00ffff;
            padding: 20px;
            margin: 10px 0;
            text-align: center;
        }
        #video-feed {
            width: 100%;
            max-width: 400px;
            margin: 10px auto;
            display: block;
            border: 1px solid #00ffff;
        }
        #indicator-box {
            font-size: 2rem;
            font-weight: bold;
            padding: 15px;
            margin-top: 10px;
            border: 3px solid #00ff41;
            transition: all 0.5s;
        }
        #record-btn {
            background: #ff0000;
            color: #fff;
            padding: 10px 20px;
            cursor: pointer;
            margin-top: 15px;
            border: none;
            font-family: 'VT323', monospace;
            font-size: 1.2rem;
        }
    </style>
</head>
<body class="p-4">

    <div class="console-container">
        
        <div id="status-bar">
            ATLAS CONSOLE v4.0 | OPERATOR: E.I. | STATUS: ONLINE | DATABASE: STANDALONE
        </div>

        <div id="output-area">
            [[INITIATING ACCESS. . .]]<br>
            [[WELCOME, OPERATOR. LEVEL DELTA CLEARANCE CONFIRMED.]]<br>
            <br>
            Type **HELP** for available commands.
            <br>
        </div>

        <div id="input-line">
            <span id="input-prefix">ATLAS ></span>
            <input type="text" id="command-input" autofocus>
        </div>
        
    </div>

    <script>
        const outputArea = document.getElementById('output-area');
        const commandInput = document.getElementById('command-input');

        let isBusy = false; // Flag to prevent command overlap
        let scanActive = false;
        let decryptState = 0; // 0: Ready, 1: Guess, 2: Decrypting
        let scanInterval; // New variable to hold the continuous scan interval

        // --- Simulated Target Data ---
        const SECRET_EMAIL = 'secret@gmail.com';
        const SIMULATED_PASSWORD = 'p4ssw0rd!';
        const PASSWORD_LENGTH = SIMULATED_PASSWORD.length;
        const DECRYPT_TIMER_SECONDS = 5.0; // Timer remains at 5 seconds

        /**
         * Core utility to add output.
         */
        function writeOutput(text, color = '#00ff41') {
            const line = document.createElement('span');
            line.style.color = color;
            line.textContent = text;
            outputArea.appendChild(line);
            outputArea.appendChild(document.createElement('br'));
            outputArea.scrollTop = outputArea.scrollHeight;
        }

        function showPrompt() {
            if (!isBusy) {
                writeOutput("", '#00ff41'); // Newline
                commandInput.value = '';
            }
            commandInput.focus();
        }

        // --- COMMAND HANDLERS ---

        async function runSearch(query) {
            isBusy = true;
            writeOutput(`INITIATING PUBLIC WEB SCAN FOR: "${query}"...`, '#ffff00');

            // Simulate delay
            await new Promise(resolve => setTimeout(resolve, 1500));

            // Simplified simulation of results
            const normalizedQuery = query.toLowerCase();

            if (normalizedQuery.includes("eiffel") || normalizedQuery.includes("paris")) {
                writeOutput(">> DATA RETRIEVAL SUCCESSFUL:", '#00ffff');
                writeOutput("[Source 1] Title: Eiffel Tower - Official Site", '#fff');
                writeOutput("          Snippet: An iron lattice tower on the Champ de Mars in Paris, France...", '#00ff41');
                writeOutput("          URL: [SIMULATED]", '#55ffaa');
                writeOutput("[Source 2] Title: Gustave Eiffel Biography", '#fff');
                writeOutput("          Snippet: French civil engineer and architect. Designed the Eiffel Tower...", '#00ff41');
                writeOutput("          URL: [SIMULATED]", '#55ffaa');
            } else if (normalizedQuery.includes("ethan") || normalizedQuery.includes("ioannou")) {
                writeOutput(">> TARGET: ETHAN IOANNOU. DATA RETRIEVAL BLOCKED BY LEVEL DELTA OVERRIDE.", '#ff0000');
                writeOutput("          REASON: PROHIBITED ACCESS TO SELF-IDENTITY FILES.", '#ff0000');
            } else {
                 writeOutput(">> NO SIGNIFICANT PUBLIC DATA FOUND. QUERY TOO VAGUE.", '#ff0000');
            }

            isBusy = false;
            showPrompt();
        }

        /**
         * COMMAND: DECRYPT (Mini-Game: Guess the email, then animate the password)
         */
        function runDecrypt(input) {
            if (decryptState === 0) {
                // State 0: Initial prompt
                writeOutput("ENCRYPTION MODULE ONLINE. Target email required for hash generation.", '#ffff00');
                writeOutput("FORMAT: DECRYPT [target@email.com]", '#ffff00');
                decryptState = 1; // Move to Guess state
                
            } else if (decryptState === 1) {
                // State 1: Check the email guess
                const emailGuess = input.toLowerCase().trim();
                
                if (emailGuess === SECRET_EMAIL) {
                    writeOutput(`TARGET ACQUIRED: ${SECRET_EMAIL}. Initiating Level-4 Decryption...`, '#00ffff');
                    decryptState = 2; // Move to Decrypting state
                    isBusy = true;
                    animateDecryption();
                } else {
                    writeOutput(`WARNING: ${emailGuess} - Target email not in high-priority registry. Aborting.`, '#ff0000');
                    decryptState = 0; // Reset
                }
            }
        }

        function animateDecryption() {
            const passwordContainer = document.createElement('span');
            passwordContainer.id = 'decrypted-pass';
            writeOutput("PASSWORD HASH: ", '#fff');
            outputArea.appendChild(passwordContainer);
            outputArea.appendChild(document.createElement('br'));
            outputArea.scrollTop = outputArea.scrollHeight;
            
            let decryptedPassword = '';
            let index = 0;
            
            // Set up the timer for the decryption game
            let timeRemaining = DECRYPT_TIMER_SECONDS;
            
            const timerElement = document.createElement('div');
            timerElement.style.color = '#ffff00';
            timerElement.textContent = `TIME: ${timeRemaining.toFixed(1)}s`;
            outputArea.appendChild(timerElement);

            const timerInterval = setInterval(() => {
                timeRemaining -= 0.1;
                timerElement.textContent = `TIME: ${timeRemaining.toFixed(1)}s`;
                
                if (timeRemaining <= 0 || index >= PASSWORD_LENGTH) {
                    clearInterval(timerInterval);
                    outputArea.removeChild(timerElement);
                    if (index >= PASSWORD_LENGTH) {
                        writeOutput(`DECRYPTION COMPLETE. PASSWORD: ${SIMULATED_PASSWORD}`, '#ffff00');
                    } else {
                        writeOutput("DECRYPTION FAILED. PROCESS ABORTED DUE TO TIMEOUT.", '#ff0000');
                    }
                    decryptState = 0;
                    isBusy = false;
                    showPrompt();
                    return;
                }

                // Decryption animation step
                const randomChars = Array.from({length: 5}, () => Math.random().toString(36)[2]).join('');
                const currentChar = SIMULATED_PASSWORD[index];
                
                passwordContainer.innerHTML = `<span style='color:#00ff41;'>${decryptedPassword}</span>` + 
                                              `<span style='color:#ff00ff;'>${randomChars.substring(0, 1)}</span>`;
                
                // Simulate the "lock-in" of the correct character
                setTimeout(() => {
                    if (index < PASSWORD_LENGTH) {
                        decryptedPassword += currentChar;
                        passwordContainer.innerHTML = `<span style='color:#00ff41;'>${decryptedPassword}</span>`;
                        index++;
                    }
                }, 100); 

            }, 500); // Animation cycle rate
        }
        
        /**
         * COMMAND: SCAN (Simulates Lie Detector)
         */
        function runScan(input) {
            if (!scanActive) {
                // State 0: Initial setup
                writeOutput("ATLAS POLYGRAPH INITIATED. Requires Camera/Mic access for bio-feedback scan.", '#ffff00');
                
                const panel = document.createElement('div');
                panel.id = 'lie-detector-panel';
                panel.innerHTML = `
                    <p style='color:#00ffff;'>TARGET: <input type="text" id="target-name" placeholder="Enter Target Name" style="background: transparent; border: 1px solid #00ffff; color: #fff;"></p>
                    <video id="video-feed" autoplay></video>
                    <div id="indicator-box" style="border-color: #00ff41;">AWAITING START</div>
                    <button id="record-btn">START ANALYSIS</button>
                    <p style='font-size: 0.8rem; color: #555;'>**NOTE: Camera access is simulated for security compliance.**</p>
                `;
                outputArea.appendChild(panel);
                outputArea.scrollTop = outputArea.scrollHeight;
                scanActive = true;
                
                // Get the video feed (using a simulated permission prompt)
                const videoFeed = document.getElementById('video-feed');
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia({ video: true })
                    .then(stream => {
                        videoFeed.srcObject = stream;
                    })
                    .catch(err => {
                        writeOutput("ACCESS ERROR: Cannot acquire live camera feed. Proceeding with simulated data...", '#ff0000');
                        videoFeed.style.display = 'none';
                    });
                } else {
                    videoFeed.style.display = 'none';
                }

                document.getElementById('record-btn').onclick = startLieDetection;
            } else {
                writeOutput("POLYGRAPH ALREADY ACTIVE. Type 'STOP SCAN' to terminate.", '#ff0000');
            }
        }

        function startLieDetection() {
            const targetName = document.getElementById('target-name').value || "Unknown Subject";
            const indicatorBox = document.getElementById('indicator-box');
            const recordBtn = document.getElementById('record-btn');
            
            if (recordBtn.textContent === "STOP ANALYSIS") {
                // Stop the simulation
                endLieDetection(targetName);
                return;
            }

            writeOutput(`ANALYZING BIO-FEEDBACK FOR: ${targetName}...`, '#ffff00');
            recordBtn.textContent = "STOP ANALYSIS";
            recordBtn.style.background = '#00ffff';

            // Initial calibration
            indicatorBox.textContent = "CALIBRATING...";
            indicatorBox.style.borderColor = '#00ffff';
            indicatorBox.style.color = '#00ffff';

            // After a short calibration delay, start the continuous analysis
            setTimeout(() => {
                writeOutput("LIVE ANALYSIS INITIATED. Indicator updating continuously...", '#00ff41');

                // Start continuous analysis flicker
                scanInterval = setInterval(() => {
                    // 50% chance of detecting deception vs truth
                    const isLying = Math.random() < 0.5; 
                    const resultText = isLying ? "DECEPTION DETECTED" : "VERIFIED TRUTH";
                    const resultColor = isLying ? '#ff0000' : '#00ff41';
                    
                    indicatorBox.textContent = resultText;
                    indicatorBox.style.borderColor = resultColor;
                    indicatorBox.style.color = resultColor;
                    indicatorBox.style.boxShadow = `0 0 15px ${resultColor}`;
                }, 500); // Update every half second

            }, 2000); // 2-second calibration
        }

        function endLieDetection(targetName) {
            // Stop the continuous flickering interval
            clearInterval(scanInterval); 
            
            const indicatorBox = document.getElementById('indicator-box');
            // Finalize result (Simulate logging the last state)
            const finalResult = indicatorBox.textContent;
            const finalColor = indicatorBox.style.color;

            const panel = document.getElementById('lie-detector-panel');
            outputArea.removeChild(panel);
            scanActive = false;

            writeOutput(`POLYGRAPH SCAN TERMINATED. Final State Logged: ${finalResult}.`, finalColor);
            showPrompt();
        }


        // --- MAIN COMMAND PROCESSOR ---
        
        function processCommand(command) {
            const parts = command.trim().split(/\s+/);
            const cmd = parts[0].toUpperCase();
            const args = parts.slice(1).join(' ');

            if (isBusy && cmd !== 'LOGOUT') {
                writeOutput("!! System Busy. Please wait for current sequence to finish.", '#ff0000');
                return;
            }
            
            // Handle decryption input during its specific state
            if (decryptState === 1 && cmd !== 'LOGOUT' && cmd !== 'HELP') {
                runDecrypt(command);
                commandInput.value = '';
                return;
            }
            
            // Handle STOP SCAN command
            if (cmd === 'STOP' && args.toUpperCase() === 'SCAN' && scanActive) {
                // Manually trigger the end sequence if running the text command
                endLieDetection("Unknown Subject"); 
                return;
            }

            // Echo the command
            writeOutput(`> ${command}`, '#ff00ff'); 
            
            switch (cmd) {
                case 'HELP':
                    writeOutput("--- AVAILABLE COMMANDS ---", '#ffff00');
                    writeOutput("SEARCH [query] : Fetch public data (people/locations).", '#00ff41');
                    writeOutput("DECRYPT        : Start email password extraction module.", '#00ff41');
                    writeOutput("SCAN           : Start bio-feedback analysis (lie detector).", '#00ff41');
                    writeOutput("LOGOUT         : Terminate session.", '#00ff41');
                    break;
                case 'SEARCH':
                    if (args.length > 2) {
                        runSearch(args);
                        return;
                    } else {
                        writeOutput("ERROR: SEARCH requires a query (e.g., SEARCH Eiffel Tower).", '#ff0000');
                    }
                    break;
                case 'DECRYPT':
                    runDecrypt(args);
                    break;
                case 'SCAN':
                    runScan();
                    break;
                case 'LOGOUT':
                    writeOutput("SESSION TERMINATED. Redirecting to source...", '#ff0000');
                    setTimeout(() => {
                        window.location.href = 'https://ethanunlocked690.github.io';
                    }, 1000);
                    return;
                default:
                    writeOutput(`ERROR: Command '${cmd}' not recognized. Try HELP.`, '#ff0000');
                    break;
            }
            showPrompt();
        }

        // --- Event Listeners ---

        commandInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                processCommand(commandInput.value);
                commandInput.value = '';
            }
        });

        // Initialize on load
        window.onload = function() {
            commandInput.focus();
        };
    </script>
</body>
</html>
