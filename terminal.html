<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATLAS: DATA FLOW CONSOLE v5.6</title>
    <!-- Assuming VT323 is loaded via the link provided in the original file -->
    <link href="./ATLAS_ DATA FLOW CONSOLE v5.5_files/css2" rel="stylesheet"> 
    <style>
        /* General Console Theme */
        body {
            background-color: #000;
            font-family: 'VT323', monospace;
            color: #00ff41; /* Console Green (Default) */
            font-size: 1.1rem;
            line-height: 1.4;
            height: 100vh;
            margin: 0;
            overflow: hidden; 
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative; 
            transition: color 0.5s, border-color 0.5s, background-color 0.1s; 
        }

        /* --- Animated Background Layer --- */
        #terminal-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.1; 
            background: 
                linear-gradient(rgba(0, 255, 65, 0), rgba(0, 255, 65, 0.4)),
                repeating-linear-gradient(0deg, #000, #000 1px, #00ff41 1px, #00ff41 2px); 
            background-size: 100% 100%;
            pointer-events: none; 
            animation: scanline-fade 10s infinite alternate;
        }

        @keyframes scanline-fade {
            0% { opacity: 0.05; }
            100% { opacity: 0.15; }
        }

        /* --- Console Window --- */
        #terminal-container {
            width: 95%;
            max-width: 800px;
            height: 90vh;
            border: 2px solid #00ff41;
            padding: 20px;
            box-sizing: border-box;
            box-shadow: 0 0 10px #00ff41, inset 0 0 10px #00ff41;
            overflow: hidden; /* Only the output scrolls */
            display: flex;
            flex-direction: column;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 10;
        }

        /* --- Output Area --- */
        #output {
            flex-grow: 1;
            overflow-y: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-bottom: 10px;
            scroll-behavior: smooth;
        }

        #output::-webkit-scrollbar {
            width: 8px;
        }
        #output::-webkit-scrollbar-thumb {
            background-color: #008822; 
            border-radius: 4px;
        }
        #output::-webkit-scrollbar-track {
            background-color: #000;
        }

        /* --- Input Area --- */
        #input-area {
            display: flex;
            align-items: center;
        }

        #prompt-prefix {
            color: #00ff41;
            margin-right: 5px;
            white-space: nowrap;
        }

        #command-input {
            background: none;
            border: none;
            color: #00ff41;
            font-family: 'VT323', monospace;
            font-size: 1.1rem;
            flex-grow: 1;
            outline: none;
            caret-color: #00ff41;
            padding: 0;
            margin: 0;
            line-height: 1.4;
            transition: color 0.3s; 
        }

        #command-input:focus {
            color: #ffff00; /* Highlight input on focus */
        }
    </style>
</head>
<body>

    <div id="terminal-background"></div>

    <div id="terminal-container">
        <div id="output"></div>
        <div id="input-area">
            <span id="prompt-prefix">ATLAS&gt;</span>
            <input type="text" id="command-input" disabled="">
        </div>
    </div>

    <script>
        // =========================================================================
        // --- Core Variables and State ---
        // =========================================================================

        const outputDiv = document.getElementById('output');
        const commandInput = document.getElementById('command-input');
        const promptPrefix = document.getElementById('prompt-prefix');
        let commandHistory = [];
        let historyIndex = -1;
        let isBusy = false;
        let isLockedDown = false;
        let audioContext = null;
        let audioUnlocked = false;

        // --- Console Utilities ---

        /**
         * Writes a line of output to the terminal window.
         * @param {string} text The text to output.
         * @param {string} color The CSS color for the text (e.g., '#00ff41').
         * @param {boolean} [isHtml=false] True if the text contains HTML.
         */
        function writeOutput(text, color = '#00ff41', isHtml = false) {
            const line = document.createElement('span');
            line.style.color = color;
            if (isHtml) {
                line.innerHTML = text;
            } else {
                line.textContent = text;
            }
            outputDiv.appendChild(line);
            outputDiv.appendChild(document.createElement('br'));
            outputDiv.scrollTop = outputDiv.scrollHeight;
        }

        /** Shows the command prompt and enables input. */
        function showPrompt() {
            promptPrefix.style.color = '#00ff41';
            commandInput.disabled = false;
            commandInput.focus();
        }

        /** Hides the command prompt and disables input. */
        function hidePrompt() {
            commandInput.disabled = true;
        }

        // =========================================================================
        // --- Audio System (Updated for Buffering) ---
        // =========================================================================

        const SOUND_EFFECTS = {
            // Audio assets mapped to their files. 'buffer' will be filled on successful load.
            'ALERT': { filename: 'alert.mp3', buffer: null, status: 'PENDING' },
            'CONFIRM': { filename: 'confirm.mp3', buffer: null, status: 'PENDING' },
            'SIREN': { filename: 'siren.mp3', buffer: null, status: 'PENDING' },
            'BOOM': { filename: 'vine-boom.mp3', buffer: null, status: 'PENDING' },
            'RIZZ': { filename: 'get-out-meme.mp3', buffer: null, status: 'PENDING' }, // Mapped RIZZ to a provided file
            'ERROR': { filename: 'alert.mp3', buffer: null, status: 'PENDING' }
        };

        /**
         * Unlocks the AudioContext by calling resume() on a user gesture.
         */
        function unlockAudioContext() {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    audioUnlocked = true;
                    writeOutput('AUDIO CONTEXT: Resumed after user interaction.', '#00ffff');
                }).catch(err => {
                    writeOutput('AUDIO CONTEXT ERROR: Failed to resume. ' + err.message, '#ff0000');
                });
            } else if (audioContext && audioContext.state === 'running') {
                audioUnlocked = true;
            }
        }

        /**
         * Fetches and decodes an audio file into an AudioBuffer.
         * @param {string} key The key in SOUND_EFFECTS.
         */
        async function bufferAudio(key) {
            const asset = SOUND_EFFECTS[key];
            if (!asset || !audioContext) return;

            try {
                const response = await fetch(asset.filename);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const arrayBuffer = await response.arrayBuffer();
                asset.buffer = await audioContext.decodeAudioData(arrayBuffer);
                asset.status = 'BUFFERED';
                writeOutput(`LOAD: Audio asset ${key} buffered successfully.`, '#00ff41');
            } catch (error) {
                asset.status = 'FAILED';
                writeOutput(`ERROR: Failed to buffer audio asset ${key} (${asset.filename}). ${error.message}`, '#ff0000');
                asset.buffer = null; // Ensure buffer is null on failure
            }
        }

        /**
         * Plays a sound effect from the buffered data.
         * @param {string} key The key of the sound effect to play.
         */
        function playSound(key) {
            const asset = SOUND_EFFECTS[key];

            if (!audioUnlocked) {
                writeOutput(`WARN: Audio context not yet active. Click anywhere to activate sound.`, '#ffff00');
                return;
            }
            
            if (!asset) {
                writeOutput(`ERROR: Audio asset ${key} does not exist in database.`, '#ff0000');
                return;
            }

            if (asset.status !== 'BUFFERED' || !asset.buffer) {
                // This is the check that fixes the RIZZ error!
                writeOutput(`ERROR: Audio asset ${key} not yet buffered (Status: ${asset.status}). Try again.`, '#ff0000');
                return;
            }

            try {
                const source = audioContext.createBufferSource();
                source.buffer = asset.buffer;
                source.connect(audioContext.destination);
                source.start(0);
                // Optionally log success
                // writeOutput(`SFX: Playing ${key}...`, '#00ffff');
            } catch (e) {
                writeOutput(`CRITICAL AUDIO ERROR: Could not play ${key}. ${e.message}`, '#ff0000');
            }
        }

        // =========================================================================
        // --- Game Engine Logic (Simplified for console) ---
        // =========================================================================

        const GAMES = {
            'NULL': { name: 'NULL-TEST-ENGINE', run: () => writeOutput('ENGINE NULL-TEST-ENGINE loaded. No functionality implemented.', '#00ffff') },
        };
        
        // =========================================================================
        // --- Command Processing ---
        // =========================================================================

        function processCommand(input) {
            if (isBusy) return;

            const fullCommand = input.trim();
            if (!fullCommand) return showPrompt();

            commandHistory.push(fullCommand);
            historyIndex = -1; // Reset history index

            writeOutput(`ATLAS> ${fullCommand}`);

            const parts = fullCommand.toUpperCase().split(/\s+/);
            const cmd = parts[0];
            const args = parts.slice(1);

            hidePrompt();
            isBusy = true;
            
            // Simulate a brief processing delay
            setTimeout(() => {
                executeCommand(cmd, args);
                isBusy = false;
                if (!isLockedDown) showPrompt();
            }, 50); 
        }

        function executeCommand(cmd, args) {
            switch (cmd) {
                case 'HELP':
                    writeOutput("--- ATLAS CONSOLE COMMANDS ---", '#ffff00');
                    writeOutput("HELP          - Display this list of commands.", '#00ff41');
                    writeOutput("CLEAR         - Clears the console output.", '#00ff41');
                    writeOutput("STATUS        - Displays current system status and variables.", '#00ff41');
                    writeOutput("LOCKDOWN      - Initiates system lockdown (disables input).", '#ff0000');
                    writeOutput("UNLOCK [CODE] - Releases lockdown using the override code.", '#ff0000');
                    writeOutput("GAME [NAME]   - Loads and runs a game engine (e.g., GAME NULL).", '#00ffff');
                    writeOutput("SOUND [KEY]   - Plays a specific sound effect (e.g., SOUND RIZZ).", '#00ffff');
                    writeOutput("--- AVAILABLE SOUNDS ---", '#ffff00');
                    writeOutput(Object.keys(SOUND_EFFECTS).join(', '), '#00ffff');
                    break;
                
                case 'CLEAR':
                    outputDiv.innerHTML = '';
                    break;

                case 'STATUS':
                    writeOutput("--- SYSTEM STATUS REPORT ---", '#ffff00');
                    writeOutput(`AUTH_USER: J.ATLAS (ADMIN_LEVEL 5)`, '#00ff41');
                    writeOutput(`SYSTEM_LOAD: 1.2% (Nominal)`, '#00ff41');
                    writeOutput(`NETWORK_PING: 4ms (Stable)`, '#00ff41');
                    writeOutput(`AUDIO_CONTEXT: ${audioContext ? audioContext.state.toUpperCase() : 'UNINITIALIZED'}`, '#00ffff');
                    writeOutput(`AUDIO_UNLOCKED: ${audioUnlocked ? 'TRUE' : 'FALSE (Click/Key required)'}`, '#00ffff');
                    writeOutput(`LOCKDOWN_STATE: ${isLockedDown ? 'ACTIVE' : 'INACTIVE'}`, isLockedDown ? '#ff0000' : '#00ff41');
                    writeOutput(`BUSY_STATE: ${isBusy ? 'TRUE' : 'FALSE'}`, isBusy ? '#ffff00' : '#00ff41');
                    break;

                case 'GAME':
                    const gameName = args[0] || 'NULL';
                    const game = GAMES[gameName];
                    if (game) {
                        writeOutput(`LOADING: Game Engine ${game.name}...`, '#00ffff');
                        setTimeout(() => game.run(), 200);
                    } else {
                        writeOutput(`ERROR: Game Engine '${gameName}' not found.`, '#ff0000');
                    }
                    break;
                
                case 'SOUND':
                    const soundKey = args[0];
                    if (soundKey) {
                        playSound(soundKey);
                    } else {
                        writeOutput("USAGE: SOUND [KEY]. Type HELP for available keys.", '#ffff00');
                    }
                    break;

                case 'LOCKDOWN':
                    isLockedDown = true;
                    hidePrompt();
                    playSound('SIREN');
                    promptPrefix.style.color = '#ff0000';
                    writeOutput("!!! WARNING !!! SYSTEM LOCKDOWN INITIATED. INPUT DISABLED. OVERRIDE REQUIRED.", '#ff0000');
                    break;

                case 'UNLOCK':
                    const code = args[0];
                    const overrideCode = '1701'; // The secret code
                    if (isLockedDown) {
                        if (code === overrideCode) {
                            isLockedDown = false;
                            playSound('CONFIRM');
                            writeOutput("OVERRIDE ACCEPTED. SYSTEM UNLOCKING...", '#00ff41');
                            writeOutput("LOCKDOWN RELEASED. Resuming normal operations.", '#00ff41');
                        } else {
                            playSound('ERROR');
                            writeOutput("ACCESS DENIED. INCORRECT OVERRIDE CODE. RETAINING LOCKDOWN.", '#ff0000');
                        }
                    } else {
                        writeOutput("STATUS: System is not in lockdown.", '#00ff41');
                    }
                    break;
                
                default:
                    writeOutput(`ERROR: Command '${cmd}' not recognized. Type HELP for a list of features.`, '#ff0000');
                    playSound('ERROR');
                    break;
            }
            
            if (!isBusy && !isLockedDown) showPrompt();
        }

        // =========================================================================
        // --- Initialization and Events ---
        // =========================================================================
        
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !commandInput.disabled) {
                processCommand(commandInput.value);
                commandInput.value = '';
            }
        });

        document.addEventListener('keydown', function(e) {
            if (commandInput.disabled) return;

            const historyKeys = Object.keys(SOUND_EFFECTS);
            
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                historyIndex = Math.min(historyIndex + 1, commandHistory.length - 1);
                if (historyIndex >= 0) {
                    commandInput.value = commandHistory[commandHistory.length - 1 - historyIndex];
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                historyIndex = Math.max(historyIndex - 1, -1);
                if (historyIndex === -1) {
                    commandInput.value = '';
                } else {
                    commandInput.value = commandHistory[commandHistory.length - 1 - historyIndex];
                }
            } else if (e.key === 'Tab') {
                e.preventDefault();
                // Basic sound key autocompletion for demonstration
                const partial = commandInput.value.toUpperCase().trim();
                if (partial.startsWith('SOUND ')) {
                    const soundPartial = partial.substring(6);
                    const match = historyKeys.find(key => key.startsWith(soundPartial));
                    if (match) {
                        commandInput.value = `SOUND ${match}`;
                    }
                }
            }
        });
        
        window.onload = function() {
            // 1. Initialize Audio Context
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                writeOutput('CRITICAL ERROR: Web Audio API not supported in this browser.', '#ff0000');
                return;
            }
            
            // 2. Set up Audio Unlock (for browsers requiring user interaction)
            document.body.addEventListener('click', unlockAudioContext, { once: true });
            document.body.addEventListener('keydown', unlockAudioContext, { once: true });

            // 3. Buffer all sound effects asynchronously
            const soundKeys = Object.keys(SOUND_EFFECTS);
            let bufferedCount = 0;
            const totalCount = soundKeys.length;

            writeOutput('SFX/GAME DATABASE: Initializing...', '#00ffff');
            
            soundKeys.forEach(key => {
                bufferAudio(key).then(() => {
                    bufferedCount++;
                    if (bufferedCount === totalCount) {
                        writeOutput(`SFX/GAME DATABASE: Local repository initialized with ${totalCount} assets and ${Object.keys(GAMES).length} game engines. All systems nominal.`, '#00ff41');
                        commandInput.focus();
                        showPrompt();
                    }
                });
            });

            // If buffering fails fast or is very slow, ensure the prompt shows up anyway
            setTimeout(() => {
                if (commandInput.disabled) {
                     writeOutput('INFO: Buffering check timeout. Enabling command line.', '#ffff00');
                     commandInput.focus();
                     showPrompt();
                }
            }, 3000); // 3-second timeout

        };
    </script>

</body></html>
