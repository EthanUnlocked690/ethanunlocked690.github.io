<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script>
window.alert("WARNING!! This game is SO hard that the creator himself could only beat it ONCE!! If you beat it, tell me in the comments of ANY of my videos and I will give you a shoutout!! Good luck and have fun!!");
</script>
<title>Dungeon Escape</title>
<style>
/* Provided Navbar CSS */
ul {
    list-style-type: none;
    margin: 0px;
    padding: 0px;
    overflow: hidden;
    background-color: #fa07e2;
    width: 800px;
    border-radius: 8px;
    margin-bottom: 10px;
}
li {
    float: left; /* Make list items go side-by-side */
}
li a {
    display: block;
    color: white;
    text-align: center;
    padding: 14px 16px;
    text-decoration: none; /* No underline for links */
}
li a:hover {
    background-color: #60fa07;
    color: #000000
}
/* Game & Page Styling */
body {
    font-family: 'Courier New', Courier, monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    background-color: #2fff00;
    color: white;
    margin-top: 20px;
}
#game-container {
    border: 4px solid #ff0000;
    border-radius: 8px;
    padding: 10px;
    background-color: #000;
    box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
}
canvas {
    background-color: #111;
    display: block;
}
#game-ui {
    width: 800px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 10px;
    padding: 0 5px;
}
#status-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #000000
}
#hp-text {
    font-size: 1.2em;
    font-weight: bold;
    color: #28a745; /* Green for health */
}
button#resetButton {
    background-color: #ff0000;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-family: inherit;
    font-size: 1em;
    font-weight: bold;
    transition: background-color 0.3s;
}
button#resetButton:hover {
    background-color: #32a852;
    color: black
}
</style>
</head>
<body>
<ul>
    <li><a class="active" href="index.html" style="color:black";>Home</a></li>
    <li><a href="news.html" style="color:black";>News</a></li>
    <li><a href="subscribe.html" style="color:black";>Subscribe</a></li>
    <li><a href="about.html" style="color:black";>About</a></li>
    <li><a href="shorts.html" style="color:black";>Shorts</a></li>
    <li><a href="videos.html" style="color:black";>Video Gallery</a></li>
    <li><a href="images.html" style="color:black";>Image Gallery</a></li>
    <li><a href="animate.html" style="color:black";>LEGO Animations</a></li>
    <li><a href="tutorial.html" style="color:black";>Tutorials & Speedruns</a></li>
    <li><a href="turtle.html" style="background-color:blue;">Game</a></li>
</ul>
<h1 style="color:black;">Controls</h1>
<p1 style="color:black;">Use arrow keys, WASD</p1>
<p1 style="color:black;">If you want to heal, get the heart (Potion) Max: 100 (Health in bottom-right corner)</p1>
<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
</div>
<div id="game-ui">
    <span id="status-text" style="color:black;">Find the key 🔑 and escape through the door🚪!</span>
    <button id="resetButton">New Game</button>
    <span id="hp-text">HP: 100</span>
</div>
<script>
    // --- Game Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const resetButton = document.getElementById('resetButton');
    const statusText = document.getElementById('status-text');
    const hpText = document.getElementById('hp-text');

    const TILE_SIZE = 40;
    const MAP_WIDTH_TILES = canvas.width / TILE_SIZE;
    const MAP_HEIGHT_TILES = canvas.height / TILE_SIZE;

    const Wall = '🪨';
    const Floor = ' ';
    const Player = '🙍';
    // Changed enemy to a dragon
    const Enemy = '🐉';
    const Key = '🔑';
    const Exit = '🚪';
    const Potion = '❤️';

    let gameState = {};

    // --- Game Logic ---
    /**
     * Initializes or resets the game state.
     */
    function initGame() {
        gameState = {
            map: generateMap(),
            player: { x: 0, y: 0, hp: 100, maxHp: 100 },
            enemies: [],
            key: { x: 0, y: 0 },
            exit: { x: 0, y: 0 },
            potions: [],
            hasKey: false,
            gameOver: false,
            gameWon: false,
            turn: 0 // Turn counter for enemy movement
        };
        placeEntities();
        updateUI();
        // Ensure the main game loop isn't running from a previous game
        if(gameState.animationFrameId) {
            cancelAnimationFrame(gameState.animationFrameId);
        }
        gameLoop();
    }

    /**
     * Procedurally generates a cave-like map using Cellular Automata.
     */
    function generateMap() {
        let map = Array.from({ length: MAP_HEIGHT_TILES }, () =>
            Array.from({ length: MAP_WIDTH_TILES }, () => Math.random() < 0.45 ? Wall : Floor)
        );

        // Automata simulation to smooth out the map into caves
        for (let i = 0; i < 4; i++) {
            let newMap = JSON.parse(JSON.stringify(map));
            for (let y = 1; y < MAP_HEIGHT_TILES - 1; y++) {
                for (let x = 1; x < MAP_WIDTH_TILES - 1; x++) {
                    let wallCount = 0;
                    for (let ny = y - 1; ny <= y + 1; ny++) {
                        for (let nx = x - 1; nx <= x + 1; nx++) {
                            if (map[ny][nx] === Wall) {
                                wallCount++;
                            }
                        }
                    }
                    newMap[y][x] = wallCount > 4 ? Wall : Floor;
                }
            }
            map = newMap;
        }

        // Add a border of walls
        for(let y = 0; y < MAP_HEIGHT_TILES; y++) {
            map[y][0] = Wall;
            map[y][MAP_WIDTH_TILES-1] = Wall;
        }
        for(let x = 0; x < MAP_WIDTH_TILES; x++) {
            map[0][x] = Wall;
            map[MAP_HEIGHT_TILES-1][x] = Wall;
        }
        return map;
    }

    /**
     * Places the player, enemies, key, exit, and potions on valid floor tiles.
     */
    function placeEntities() {
        const floorTiles = [];
        for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
            for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                if (gameState.map[y][x] === Floor) {
                    floorTiles.push({ x, y });
                }
            }
        }

        const getRandomTile = () => {
            const index = Math.floor(Math.random() * floorTiles.length);
            return floorTiles.splice(index, 1)[0];
        };

        // Place Player, Key, Exit
        Object.assign(gameState.player, getRandomTile());
        Object.assign(gameState.key, getRandomTile());
        Object.assign(gameState.exit, getRandomTile());

        // Place Enemies
        const NUM_ENEMIES = 5;
        for (let i = 0; i < NUM_ENEMIES; i++) {
            if (floorTiles.length > 0) gameState.enemies.push(getRandomTile());
        }

        // Place Potions
        const NUM_POTIONS = 3;
        for (let i = 0; i < NUM_POTIONS; i++) {
            if(floorTiles.length > 0) gameState.potions.push(getRandomTile());
        }
    }

    /**
     * The main game loop, responsible for updating and drawing.
     */
    function gameLoop() {
        if (gameState.gameOver || gameState.gameWon) {
            draw(); // Final draw to show win/loss message
            return;
        }
        update();
        draw();
        gameState.animationFrameId = requestAnimationFrame(gameLoop);
    }

    /**
     * Updates the game state (e.g., enemy movement).
     */
    function update() {
        // This function is intentionally simple for this turn-based structure.
        // Complex updates happen in response to player input.
    }

    /**
     * Moves all enemies based on simple AI.
     */
    function moveEnemies() {
        gameState.enemies.forEach(enemy => {
            // 50% chance to hunt the player, 50% chance to move randomly
            const huntPlayer = Math.random() > 0.5;
            let dx = 0, dy = 0;

            if (huntPlayer) {
                dx = Math.sign(gameState.player.x - enemy.x);
                dy = Math.sign(gameState.player.y - enemy.y);
            } else {
                dx = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
                dy = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
            }

            // Attempt to move
            const nextX = enemy.x + dx;
            const nextY = enemy.y + dy;

            if (isWalkable(nextX, nextY)) {
                enemy.x = nextX;
                enemy.y = nextY;
            }

            // Check for collision with player after moving
            if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
                takeDamage(15);
            }
        });
    }

    /**
     * Renders the entire game state to the canvas.
     */
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `${TILE_SIZE * 0.8}px monospace`;

        // Draw map
        for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
            for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                if (gameState.map[y][x] === Wall) {
                    ctx.fillText(Wall, x * TILE_SIZE, y * TILE_SIZE + TILE_SIZE);
                }
            }
        }

        // Draw entities
        const drawEntity = (entity, symbol) => ctx.fillText(symbol, entity.x * TILE_SIZE, entity.y * TILE_SIZE + TILE_SIZE);

        if(!gameState.hasKey) drawEntity(gameState.key, Key);
        drawEntity(gameState.exit, Exit);
        gameState.potions.forEach(potion => drawEntity(potion, Potion));

        // Conditionally draw enemies as skulls if game is won
        gameState.enemies.forEach(enemy => drawEntity(enemy, gameState.gameWon ? '💀' : Enemy));

        // Conditionally draw player as skull if game is over
        drawEntity(gameState.player, gameState.gameOver ? '💀' : Player);

        // Draw Game Over or Win message
        if (gameState.gameOver || gameState.gameWon) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = gameState.gameWon ? '#28a745' : '#dc3545';
            ctx.font = 'bold 60px Courier New';
            ctx.textAlign = 'center';
            const message = gameState.gameWon ? 'YOU ESCAPED!' : 'GAME OVER';
            ctx.fillText(message, canvas.width / 2, canvas.height / 2);
            ctx.textAlign = 'left'; // Reset alignment
        }
    }

    /**
     * Updates the UI elements (status and HP text).
     */
    function updateUI() {
        if (gameState.gameOver) {
            statusText.textContent = "You were defeated! 💀";
            hpText.style.color = "#dc3545";
        } else if (gameState.gameWon) {
            statusText.textContent = "Congratulations! You escaped! 🎉";
            hpText.style.color = "#28a745";
        } else if (gameState.hasKey) {
            statusText.textContent = "You have the key! Go to the door! 🚪";
        } else {
            statusText.textContent = "Find the key 🔑 and escape!";
        }
        hpText.textContent = `HP: ${gameState.player.hp}`;
        if(gameState.player.hp < 30) {
            hpText.style.color = "#ffc107"; // Warning yellow
        } else {
            hpText.style.color = "#28a745"; // Healthy green
        }
    }

    /**
     * Reduces player HP and checks for game over.
     */
    function takeDamage(amount) {
        gameState.player.hp = Math.max(0, gameState.player.hp - amount);
        if (gameState.player.hp <= 0) {
            gameState.gameOver = true;
        }
        updateUI();
    }

    /**
     * Handles player movement and interactions.
     */
    function handleInput(event) {
        if (gameState.gameOver || gameState.gameWon) return;

        let dx = 0, dy = 0;
        switch (event.key) {
            case 'ArrowUp':
            case 'w':
            case 'W':
                dy = -1;
                break;
            case 'ArrowDown':
            case 's':
            case 'S':
                dy = 1;
                break;
            case 'ArrowLeft':
            case 'a':
            case 'A':
                dx = -1;
                break;
            case 'ArrowRight':
            case 'd':
            case 'D':
                dx = 1;
                break;
            default:
                return; // Ignore other keys
        }

        const nextX = gameState.player.x + dx;
        const nextY = gameState.player.y + dy;

        if (isWalkable(nextX, nextY)) {
            gameState.player.x = nextX;
            gameState.player.y = nextY;

            // After player moves, enemies get a turn.
            moveEnemies();
            checkInteractions();
            updateUI();
        }
    }

    /**
     * Checks for player interactions with items, enemies, and the exit.
     */
    function checkInteractions() {
        // Check key
        if (!gameState.hasKey && gameState.player.x === gameState.key.x && gameState.player.y === gameState.key.y) {
            gameState.hasKey = true;
        }

        // Check exit
        if (gameState.hasKey && gameState.player.x === gameState.exit.x && gameState.player.y === gameState.exit.y) {
            gameState.gameWon = true;
        }

        // Check potions
        gameState.potions = gameState.potions.filter(potion => {
            if (potion.x === gameState.player.x && potion.y === gameState.player.y) {
                gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 50);
                return false; // Remove potion from array
            }
            return true;
        });

        // Check enemies (collision after enemy move)
        gameState.enemies.forEach(enemy => {
            if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
                takeDamage(15);
            }
        });
    }

    /**
     * Checks if a tile at given coordinates is walkable (not a wall).
     */
    function isWalkable(x, y) {
        return x >= 0 && x < MAP_WIDTH_TILES && y >= 0 && y < MAP_HEIGHT_TILES && gameState.map[y][x] === Floor;
    }

    // --- Event Listeners ---
    window.addEventListener('keydown', handleInput);
    resetButton.addEventListener('click', initGame);

    // --- Initial Start ---
    initGame();
</script>
</body>
</html>
