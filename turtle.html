<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Escape</title>
    <style>
        /* Provided Navbar CSS */
        ul {
            list-style-type: none;
            margin: 0px;
            padding: 0px;
            overflow: hidden;
            background-color: #ff0000; /* Red background for the nav bar */
            width: 800px; /* Make it the same width as the game box for neatness */
            border-radius: 8px; /* Rounded corners for the nav bar */
            margin-bottom: 10px; /* Space between nav bar and game box */
        }
        
        li {
            float: left; /* Make list items go side-by-side */
        }

        li a {
            display: block;
            color: white;
            text-align: center;
            padding: 14px 16px;
            text-decoration: none; /* No underline for links */
        }

        li a:hover {
            background-color: #964B00; /* Brown background when you hover over a link */
        }

        /* Game & Page Styling */
        body {
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #1a1a1a;
            color: white;
            margin-top: 20px;
        }

        #game-container {
            border: 4px solid #ff0000;
            border-radius: 8px;
            padding: 10px;
            background-color: #000;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        canvas {
            background-color: #111;
            display: block;
        }

        #game-ui {
            width: 800px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding: 0 5px;
        }

        #status-text {
            font-size: 1.2em;
            font-weight: bold;
        }
        
        #hp-text {
            font-size: 1.2em;
            font-weight: bold;
            color: #28a745; /* Green for health */
        }

        button#resetButton {
            background-color: #ff0000;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-family: inherit;
            font-size: 1em;
            font-weight: bold;
            transition: background-color 0.3s;
        }

        button#resetButton:hover {
            background-color: #964B00;
        }
    </style>
</head>
<body>
    <ul>
        <li><a href="#home">Home</a></li>
        <li><a href="#news">News</a></li>
        <li><a href="#subscribe">Subscribe</a></li>
        <li><a href="#about">About</a></li>
        <li><a href="#shorts">Shorts</a></li>
        <li><a href="#videos">Video Gallery</a></li>
        <li><a href="#images">Image Gallery</a></li>
        <li><a href="#animate">LEGO Animations</a></li>
        <li><a href="#tutorial">Tutorials & Speedruns</a></li>
        <li><a class="active" href="#game" style="background-color:yellow;">Game</a></li>
    </ul>

    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
    </div>
    
    <div id="game-ui">
        <span id="status-text">Find the key 🔑 and escape!</span>
        <button id="resetButton">New Game</button>
        <span id="hp-text">HP: 100</span>
    </div>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const resetButton = document.getElementById('resetButton');
        const statusText = document.getElementById('status-text');
        const hpText = document.getElementById('hp-text');

        const TILE_SIZE = 40;
        const MAP_WIDTH_TILES = canvas.width / TILE_SIZE;
        const MAP_HEIGHT_TILES = canvas.height / TILE_SIZE;

        const Wall = '🪨';
        const Floor = ' ';
        const Player = '😎';
        const Enemy = '💀';
        const Key = '🔑';
        const Exit = '🚪';
        const Potion = '❤️';
        
        let gameState = {};

        // --- Game Logic ---

        /**
         * Initializes or resets the game state.
         */
        function initGame() {
            gameState = {
                map: generateMap(),
                player: { x: 0, y: 0, hp: 100, maxHp: 100 },
                enemies: [],
                key: { x: 0, y: 0 },
                exit: { x: 0, y: 0 },
                potions: [],
                hasKey: false,
                gameOver: false,
                gameWon: false,
                turn: 0 // Turn counter for enemy movement
            };
            
            placeEntities();
            updateUI();
            
            // Ensure the main game loop isn't running from a previous game
            if(gameState.animationFrameId) {
                cancelAnimationFrame(gameState.animationFrameId);
            }
            gameLoop();
        }

        /**
         * Procedurally generates a cave-like map using Cellular Automata.
         */
        function generateMap() {
            let map = Array.from({ length: MAP_HEIGHT_TILES }, () => 
                Array.from({ length: MAP_WIDTH_TILES }, () => Math.random() < 0.45 ? Wall : Floor)
            );

            // Automata simulation to smooth out the map into caves
            for (let i = 0; i < 4; i++) {
                let newMap = JSON.parse(JSON.stringify(map));
                for (let y = 1; y < MAP_HEIGHT_TILES - 1; y++) {
                    for (let x = 1; x < MAP_WIDTH_TILES - 1; x++) {
                        let wallCount = 0;
                        for (let ny = y - 1; ny <= y + 1; ny++) {
                            for (let nx = x - 1; nx <= x + 1; nx++) {
                                if (map[ny][nx] === Wall) {
                                    wallCount++;
                                }
                            }
                        }
                        newMap[y][x] = wallCount > 4 ? Wall : Floor;
                    }
                }
                map = newMap;
            }
            // Add a border of walls
            for(let y = 0; y < MAP_HEIGHT_TILES; y++) {
                map[y][0] = Wall;
                map[y][MAP_WIDTH_TILES-1] = Wall;
            }
             for(let x = 0; x < MAP_WIDTH_TILES; x++) {
                map[0][x] = Wall;
                map[MAP_HEIGHT_TILES-1][x] = Wall;
            }
            return map;
        }

        /**
         * Places the player, enemies, key, exit, and potions on valid floor tiles.
         */
        function placeEntities() {
            const floorTiles = [];
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    if (gameState.map[y][x] === Floor) {
                        floorTiles.push({ x, y });
                    }
                }
            }

            const getRandomTile = () => {
                const index = Math.floor(Math.random() * floorTiles.length);
                return floorTiles.splice(index, 1)[0];
            };

            // Place Player, Key, Exit
            Object.assign(gameState.player, getRandomTile());
            Object.assign(gameState.key, getRandomTile());
            Object.assign(gameState.exit, getRandomTile());
            
            // Place Enemies
            const NUM_ENEMIES = 5;
            for (let i = 0; i < NUM_ENEMIES; i++) {
                if (floorTiles.length > 0) gameState.enemies.push(getRandomTile());
            }

            // Place Potions
            const NUM_POTIONS = 3;
            for (let i = 0; i < NUM_POTIONS; i++) {
                if(floorTiles.length > 0) gameState.potions.push(getRandomTile());
            }
        }
        
        /**
         * The main game loop, responsible for updating and drawing.
         */
        function gameLoop() {
            if (gameState.gameOver || gameState.gameWon) {
                draw(); // Final draw to show win/loss message
                return;
            }
            
            update();
            draw();
            gameState.animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Updates the game state (e.g., enemy movement).
         */
        function update() {
            // This function is intentionally simple for this turn-based structure.
            // Complex updates happen in response to player input.
        }
        
        /**
         * Moves all enemies based on simple AI.
         */
        function moveEnemies() {
            gameState.enemies.forEach(enemy => {
                // 50% chance to hunt the player, 50% chance to move randomly
                const huntPlayer = Math.random() > 0.5;
                let dx = 0, dy = 0;

                if (huntPlayer) {
                    dx = Math.sign(gameState.player.x - enemy.x);
                    dy = Math.sign(gameState.player.y - enemy.y);
                } else {
                    dx = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
                    dy = Math.floor(Math.random() * 3) - 1; // -1, 0, or 1
                }
                
                // Attempt to move
                const nextX = enemy.x + dx;
                const nextY = enemy.y + dy;

                if (isWalkable(nextX, nextY)) {
                    enemy.x = nextX;
                    enemy.y = nextY;
                }
                 // Check for collision with player after moving
                if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
                    takeDamage(15);
                }
            });
        }

        /**
         * Renders the entire game state to the canvas.
         */
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.font = `${TILE_SIZE * 0.8}px monospace`;

            // Draw map
            for (let y = 0; y < MAP_HEIGHT_TILES; y++) {
                for (let x = 0; x < MAP_WIDTH_TILES; x++) {
                    if (gameState.map[y][x] === Wall) {
                        ctx.fillText(Wall, x * TILE_SIZE, y * TILE_SIZE + TILE_SIZE);
                    }
                }
            }
            // Draw entities
            const drawEntity = (entity, symbol) => ctx.fillText(symbol, entity.x * TILE_SIZE, entity.y * TILE_SIZE + TILE_SIZE);
            
            if(!gameState.hasKey) drawEntity(gameState.key, Key);
            drawEntity(gameState.exit, Exit);
            gameState.potions.forEach(potion => drawEntity(potion, Potion));
            gameState.enemies.forEach(enemy => drawEntity(enemy, Enemy));
            drawEntity(gameState.player, Player);

            // Draw Game Over or Win message
            if (gameState.gameOver || gameState.gameWon) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = gameState.gameWon ? '#28a745' : '#dc3545';
                ctx.font = 'bold 60px Courier New';
                ctx.textAlign = 'center';
                const message = gameState.gameWon ? 'YOU ESCAPED!' : 'GAME OVER';
                ctx.fillText(message, canvas.width / 2, canvas.height / 2);
                ctx.textAlign = 'left'; // Reset alignment
            }
        }
        
        /**
         * Updates the UI elements (status and HP text).
         */
        function updateUI() {
            if (gameState.gameOver) {
                statusText.textContent = "You were defeated! 💀";
                hpText.style.color = "#dc3545";
            } else if (gameState.gameWon) {
                statusText.textContent = "Congratulations! You escaped! 🎉";
                hpText.style.color = "#28a745";
            } else if (gameState.hasKey) {
                statusText.textContent = "You have the key! Go to the door! 🚪";
            } else {
                statusText.textContent = "Find the key 🔑 and escape!";
            }
            hpText.textContent = `HP: ${gameState.player.hp}`;
             if(gameState.player.hp < 30) {
                hpText.style.color = "#ffc107"; // Warning yellow
            } else {
                 hpText.style.color = "#28a745"; // Healthy green
            }
        }

        /**
         * Reduces player HP and checks for game over.
         */
        function takeDamage(amount) {
            gameState.player.hp = Math.max(0, gameState.player.hp - amount);
            if (gameState.player.hp <= 0) {
                gameState.gameOver = true;
            }
            updateUI();
        }

        /**
         * Handles player movement and interactions.
         */
        function handleInput(event) {
            if (gameState.gameOver || gameState.gameWon) return;

            let dx = 0, dy = 0;
            switch (event.key) {
                case 'ArrowUp': dy = -1; break;
                case 'ArrowDown': dy = 1; break;
                case 'ArrowLeft': dx = -1; break;
                case 'ArrowRight': dx = 1; break;
                default: return; // Ignore other keys
            }

            const nextX = gameState.player.x + dx;
            const nextY = gameState.player.y + dy;

            if (isWalkable(nextX, nextY)) {
                gameState.player.x = nextX;
                gameState.player.y = nextY;
                
                // After player moves, enemies get a turn.
                moveEnemies();
                checkInteractions();
                updateUI();
            }
        }
        
        /**
         * Checks for player interactions with items, enemies, and the exit.
         */
        function checkInteractions() {
            // Check key
            if (!gameState.hasKey && gameState.player.x === gameState.key.x && gameState.player.y === gameState.key.y) {
                gameState.hasKey = true;
            }
            // Check exit
            if (gameState.hasKey && gameState.player.x === gameState.exit.x && gameState.player.y === gameState.exit.y) {
                gameState.gameWon = true;
            }
            // Check potions
            gameState.potions = gameState.potions.filter(potion => {
                if (potion.x === gameState.player.x && potion.y === gameState.player.y) {
                    gameState.player.hp = Math.min(gameState.player.maxHp, gameState.player.hp + 50);
                    return false; // Remove potion from array
                }
                return true;
            });
            // Check enemies (collision after enemy move)
             gameState.enemies.forEach(enemy => {
                if (enemy.x === gameState.player.x && enemy.y === gameState.player.y) {
                    takeDamage(15);
                }
            });
        }

        /**
         * Checks if a tile at given coordinates is walkable (not a wall).
         */
        function isWalkable(x, y) {
            return x >= 0 && x < MAP_WIDTH_TILES &&
                   y >= 0 && y < MAP_HEIGHT_TILES &&
                   gameState.map[y][x] === Floor;
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', handleInput);
        resetButton.addEventListener('click', initGame);

        // --- Initial Start ---
        initGame();
    </script>
</body>
</html>
